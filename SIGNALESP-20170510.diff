diff -ruwN ./bitstore.cpp ../../trebron106/SIGNALEsp-20170510/bitstore.cpp
--- ./bitstore.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/bitstore.cpp	2017-05-01 08:54:58.000000000 +0200
@@ -0,0 +1,2 @@
+#include "bitstore.h"
+
diff -ruwN ./bitstore.h ../../trebron106/SIGNALEsp-20170510/bitstore.h
--- ./bitstore.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/bitstore.h	2017-05-01 08:54:58.000000000 +0200
@@ -0,0 +1,170 @@
+/*
+*   Library for storing and retrieving multibple bits in one byte
+*   Copyright (C) 2014  S.Butzek
+*
+*   This program is free software: you can redistribute it and/or modify
+*   it under the terms of the GNU General Public License as published by
+*   the Free Software Foundation, either version 3 of the License, or
+*   (at your option) any later version.
+*
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU General Public License
+*   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef BITSTORE_H
+#define BITSTORE_H
+
+#include "Arduino.h"
+
+template<uint8_t bufSize>
+class BitStore
+{
+    public:
+        /** Default constructor */
+        BitStore(uint8_t bitlength);
+        //~BitStore();
+        void addValue(char value);
+        unsigned char getValue(const uint16_t pos);
+        const uint16_t getSize();
+        //unsigned char *datastore;  // Reserve 40 Bytes for our store. Should be edited to aa dynamic way
+        unsigned char datastore[bufSize];
+        void reset();
+        unsigned char getByte(const uint8_t idx);
+        uint8_t bytecount;  // Number of stored bytes
+        uint16_t valcount;  // Number of total values stored
+#ifndef UNITTEST
+	protected:
+
+    private:
+#endif
+		uint8_t valuelen;   // Number of bits for every value
+        uint8_t bmask;
+        uint8_t bcnt;
+        const uint8_t buffsize;
+
+};
+
+
+/*
+*   Library for storing and retrieving multibple bits in one byte
+*   Copyright (C) 2014  S.Butzek
+*
+*   This program is free software: you can redistribute it and/or modify
+*   it under the terms of the GNU General Public License as published by
+*   the Free Software Foundation, either version 3 of the License, or
+*   (at your option) any later version.
+*
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU General Public License
+*   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+template<uint8_t bufSize>
+BitStore<bufSize>::BitStore(uint8_t bitlength):buffsize(bufSize)
+{
+    valuelen = bitlength; // How many bits shoudl be reserved for one value added ?
+    bmask=0;
+    //buffsize = bufsize;
+    //datastore= (unsigned char*) calloc(bufsize,sizeof(char)); // Speicher allokieren und 0 zuweisen
+    reset();
+    for (uint8_t x=7;x>(7-valuelen);x--)
+    {
+        bmask = bmask | (1<<x);
+    }
+}
+
+/** @brief (one liner)
+  *
+  * (documentation goes here)
+  */
+/*template<uint8_t bufSize>
+ BitStore<bufSize>::~BitStore()
+{
+	//free(datastore);
+}
+*/
+template<uint8_t bufSize>
+
+void BitStore<bufSize>::addValue(char value)
+{
+    if (bytecount >=buffsize ) return; // Out of Buffer
+	if (bcnt==7 &&valcount > 0)
+	{ 
+		bytecount++;
+		datastore[bytecount] = 0;
+	}
+
+    //store[bytecount]=datastore[bytecount] | (value<<bcnt)
+    datastore[bytecount]=datastore[bytecount] | (value<<bcnt);  // (valcount*valuelen%8)
+	/*
+	Serial.println("");
+
+    Serial.print("Adding value:");   Serial.print(value,DEC);
+    Serial.print(" at byte: ");   Serial.print(bytecount,DEC);
+    Serial.print(" at pos: ");   Serial.print(bcnt,DEC);
+    Serial.print("  datastore is (bin)");   Serial.print(datastore[bytecount],BIN);
+    Serial.print("  (dec)");   Serial.print(datastore[bytecount],DEC);
+	Serial.print(" : ");
+	*/
+    valcount++;
+    if (int8_t(bcnt-valuelen) >= 0)  // Soalnge nicht 8 Bit gepeichert wurden, erhoehen wir den counter zum verschieben
+    {
+        bcnt=bcnt-valuelen; //+valuelen
+    } else {
+        bcnt=7;
+    }
+
+}
+template<uint8_t bufSize>
+const uint16_t BitStore<bufSize>::getSize()
+{
+    return valcount-1;
+}
+
+
+
+template<uint8_t bufSize>
+unsigned char BitStore<bufSize>::getValue(const uint16_t pos)
+{
+   if ((pos*valuelen/8) >=buffsize ) return -1; // Out of Buffer
+
+   uint8_t mask; // Local modified bitmask
+   unsigned char ret;
+   //Serial.print("Bitmask:");   Serial.println(bmask,DEC);
+   //ret= (datastore[pos*valuelen/8]>>(pos*valuelen%8))&bmask;
+   mask = bmask >> (pos*valuelen%8);            //Mask the position we want to retrieve
+   ret= datastore[pos*valuelen/8]&mask;         // Combine the mask with our store to extract the bit
+   ret=ret>>(7-(pos*valuelen%8));               // Align the the bits to the right edge
+   return ret;
+}
+
+template<uint8_t bufSize>
+unsigned char BitStore<bufSize>::getByte(const uint8_t idx)
+{
+  if (idx >= buffsize) return -1; // Out of buffer range
+  return (datastore[idx]);
+}
+
+template<uint8_t bufSize>
+void BitStore<bufSize>::reset()
+{
+  for (uint8_t i=0;i<buffsize;i++)
+  {
+      datastore[i]=0;
+  }
+  bytecount=0;
+  valcount=0;
+  bcnt=7;
+}
+
+
+#endif // BITSTORE_H
diff -ruwN ./cc1101.h ../../trebron106/SIGNALEsp-20170510/cc1101.h
--- ./cc1101.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/cc1101.h	2017-05-09 08:52:18.000000000 +0200
@@ -0,0 +1,456 @@
+// cc1101.h
+#include <SPI.h>
+
+#ifndef _CC1101_h
+#define _CC1101_h
+
+#if defined(ARDUINO) && ARDUINO >= 100
+	#include "Arduino.h"
+#else
+	#include "WProgram.h"
+#endif
+
+#include <EEPROM.h>
+#include "output.h"
+
+extern String cmdstring;
+
+namespace cc1101 {
+
+	#define csPin	SS	      // CSN  out
+	#define mosiPin MOSI    // MOSI out
+	#define misoPin MISO    // MISO in
+	#define sckPin  SCK     // SCLK out	
+	
+	#define CC1101_CONFIG      0x80
+	#define CC1101_STATUS      0xC0
+	#define CC1100_WRITE_BURST 0x40
+  #define CC1100_READ_BURST  0x80	
+//  #define CC1100_READ_BURST  0xC0
+	
+	#define CC1100_FREQ2       0x0D  // Frequency control word, high byte
+	#define CC1100_FREQ1       0x0E  // Frequency control word, middle byte
+	#define CC1100_FREQ0       0x0F  // Frequency control word, low byte
+	#define CC1100_PATABLE     0x3E  // 8 byte memory
+	#define CC1100_IOCFG2      0x00  // GDO2 output configuration
+	#define CC1100_PKTCTRL0    0x08  // Packet config register
+
+	// Status registers
+	#define CC1100_RSSI      0x34 // Received signal strength indication
+	#define CC1100_MARCSTATE 0x35 // Control state machine state
+	 
+	// Strobe commands
+	#define CC1101_SRES     0x30  // reset
+	#define CC1100_SFSTXON  0x31  // Enable and calibrate frequency synthesizer (if MCSM0.FS_AUTOCAL=1).
+	#define CC1100_SCAL     0x33  // Calibrate frequency synthesizer and turn it off
+	#define CC1100_SRX      0x34  // Enable RX. Perform calibration first if coming from IDLE and MCSM0.FS_AUTOCAL=1
+	#define CC1100_STX      0x35  // In IDLE state: Enable TX. Perform calibration first if MCSM0.FS_AUTOCAL=1
+	#define CC1100_SIDLE    0x36  // Exit RX / TX, turn off frequency synthesizer
+	#define CC1100_SAFC     0x37  // Perform AFC adjustment of the frequency synthesizer
+	#define CC1100_SFTX     0x3B  // Flush the TX FIFO buffer.
+
+  #define wait_Miso() delay(10)
+	#define cc1101_Select() SPI.begin()          // select (SPI) CC1101
+	#define cc1101_Deselect() SPI.end() 
+	
+	#define EE_CC1100_CFG        2
+	#define EE_CC1100_CFG_SIZE   0x29
+	#define EE_CC1100_PA         0x30  //  (EE_CC1100_CFG+EE_CC1100_CFG_SIZE)  // 2B
+	#define EE_CC1100_PA_SIZE    8
+	
+	#define PATABLE_DEFAULT      0x84   // 5 dB default value for factory reset 0x84
+
+	//------------------------------------------------------------------------------
+	// Chip Status Byte
+	//------------------------------------------------------------------------------
+
+	// Bit fields in the chip status byte
+	#define CC1100_STATUS_CHIP_RDYn_BM             0x80
+	#define CC1100_STATUS_STATE_BM                 0x70
+	#define CC1100_STATUS_FIFO_BYTES_AVAILABLE_BM  0x0F
+
+		// Chip states
+	#define CC1100_STATE_IDLE                      0x00
+	#define CC1100_STATE_RX                        0x10
+	#define CC1100_STATE_TX                        0x20
+	#define CC1100_STATE_FSTXON                    0x30
+	#define CC1100_STATE_CALIBRATE                 0x40
+	#define CC1100_STATE_SETTLING                  0x50
+	#define CC1100_STATE_RX_OVERFLOW               0x60
+	#define CC1100_STATE_TX_UNDERFLOW              0x70
+  
+	static const uint8_t initVal[] PROGMEM = 
+	{
+		      // IDX NAME     RESET   COMMENT
+		0x0D, // 00 IOCFG2    29     GDO2 as serial output
+		0x2E, // 01 IOCFG1           Tri-State
+		0x2D, // 02 IOCFG0    3F     GDO0 for input
+		0x07, // 03 FIFOTHR   
+		0xD3, // 04 SYNC1     
+		0x91, // 05 SYNC0     
+		0x3D, // 06 PKTLEN    0F
+		0x04, // 07 PKTCTRL1  
+		0x32, // 08 PKTCTRL0  45     
+		0x00, // 09 ADDR     
+		0x00, // 0A CHANNR   
+		0x06, // 0B FSCTRL1   0F     152kHz IF Frquency
+		0x00, // 0C FSCTRL0
+		0x10, // 0D FREQ2     1E     Freq
+		0xB0, // 0E FREQ1     C4     
+		0x71, // 0F FREQ0     EC     
+		0x57, // 10 MDMCFG4   8C     bWidth 325kHz
+		0xC4, // 11 MDMCFG3   22     DataRate
+		0x30, // 12 MDMCFG2   02     Modulation: ASK
+		0x23, // 13 MDMCFG1   22     
+		0xb9, // 14 MDMCFG0   F8     ChannelSpace: 350kHz
+		0x00, // 15 DEVIATN   47     
+		0x07, // 16 MCSM2     07     
+		0x00, // 17 MCSM1     30     Bit 3:2  RXOFF_MODE:  Select what should happen when a packet has been received: 0 = IDLE  3 =  Stay in RX ####
+		0x18, // 18 MCSM0     04     Calibration: RX/TX->IDLE
+		0x14, // 19 FOCCFG    36     
+		0x6C, // 1A BSCFG
+		0x07, // 1B AGCCTRL2  03     42 dB instead of 33dB
+		0x00, // 1C AGCCTRL1  40     
+		0x90, // 1D AGCCTRL0  91     4dB decision boundery
+		0x87, // 1E WOREVT1
+		0x6B, // 1F WOREVT0
+		0xF8, // 20 WORCTRL
+		0x56, // 21 FREND1
+		0x11, // 22 FREND0    16     0x11 for no PA ramping
+		0xE9, // 23 FSCAL3    A9    E9 ?? 
+		0x2A, // 24 FSCAL2    0A    
+		0x00, // 25 FSCAL1    20    19 ??
+		0x1F, // 26 FSCAL0    0D     
+		0x41, // 27 RCCTRL1
+		0x00, // 28 RCCTRL0
+	};
+  
+  byte hex2int(byte hex) {    // convert a hexdigit to int    // Todo: printf oder scanf nutzen
+    if (hex >= '0' && hex <= '9') hex = hex - '0';
+    else if (hex >= 'a' && hex <= 'f') hex = hex - 'a' + 10;
+    else if (hex >= 'A' && hex <= 'F') hex = hex - 'A' + 10;
+    return hex;
+    // printf ("%d\n",$hex) ??
+  }
+
+  void printHex2(const byte hex) {   // Todo: printf oder scanf nutzen
+    if (hex < 16) {
+      MSG_PRINT("0");
+    }
+    // char hexstr[2] = {0};
+    //sprintf(hexstr, "%02X", hex);
+
+    MSG_PRINT(hex, HEX);
+  }
+
+	uint8_t cmdStrobe(const uint8_t cmd) {                  // send command strobe to the CC1101 IC via SPI
+		cc1101_Select();                                // select CC1101
+		wait_Miso();                                    // wait until MISO goes low
+		uint8_t ret = SPI.transfer(cmd);                     // send strobe command
+		wait_Miso();                                    // wait until MISO goes low
+		cc1101_Deselect();                              // deselect CC1101
+		return ret;					// Chip Status Byte
+	}
+
+	uint8_t readReg(const uint8_t regAddr, const uint8_t regType) {       // read CC1101 register via SPI
+    uint8_t addr, val;
+    
+    addr = regAddr | regType;
+		cc1101_Select();                                // select CC1101
+		wait_Miso();                                    // wait until MISO goes low
+    SPI.transfer(addr);                       // Send register address
+    val = SPI.transfer(0x00);                 // Read result
+		cc1101_Deselect();                              // deselect CC1101
+		return val;
+	}
+
+	void writeReg(const uint8_t regAddr, const uint8_t val) {     // write single register into the CC1101 IC via SPI
+		cc1101_Select();                                // select CC1101
+		wait_Miso();                                    // wait until MISO goes low
+    SPI.transfer(regAddr);                    // Send register address
+    SPI.transfer(val);                      // Send value 
+		cc1101_Deselect();                              // deselect CC1101
+}
+
+  void readPatable(void) {
+    DBG_PRINTLN("readPatable");
+    uint8_t PatableArray[8];  
+    for (uint8_t i = 0; i < 8; i++) {
+      PatableArray[i] = readReg(CC1100_PATABLE, 0x80);
+     }
+
+    for (uint8_t i = 0; i < 8; i++) {
+      printHex2(PatableArray[i]);
+      MSG_PRINT(" ");
+ //     DBG_PRINT("RPT:");DBG_PRINT(i);DBG_PRINT(" ");DBG_PRINTLN(PatableArray[i]);
+    }
+    MSG_PRINTLN("");
+  }
+
+void writePatable(void) {
+    DBG_PRINTLN("EEPROM writePatable");  
+
+    EEPROM.begin(512); //Max bytes of eeprom to use
+    yield();
+    for (uint8_t i = 0; i < 8; i++) {
+      writeReg(CC1100_PATABLE, EEPROM.read(EE_CC1100_PA+i)); 
+    } 
+   EEPROM.end(); 
+ }
+
+  void readCCreg(const uint8_t reg) {   // read CC11001 register
+    uint8_t var;
+    uint8_t hex;
+    uint8_t n;
+    char t[6];
+
+       if (cmdstring.charAt(3) == 'n' && isHexadecimalDigit(cmdstring.charAt(4))) {   // C<reg>n<anz>  gibt anz+2 fortlaufende register zurueck
+           hex = (uint8_t)cmdstring.charAt(4);
+           n = hex2int(hex);
+           if (reg < 0x2F) {
+              MSG_PRINT("C");
+              printHex2(reg);
+              MSG_PRINT("n");
+              n += 2;
+              printHex2(n);
+              MSG_PRINT("=");
+              for (uint8_t i = 0; i < n; i++) {
+                 var = readReg(reg + i, CC1101_CONFIG);
+                 printHex2(var);
+              }
+              MSG_PRINTLN("");
+           }
+       }
+       else {
+       if (reg < 0x3E) {
+          if (reg < 0x2F) {
+             var = readReg(reg, CC1101_CONFIG);
+          }
+          else {
+             var = readReg(reg, CC1101_STATUS);
+          }
+          MSG_PRINT("C");
+          printHex2(reg);
+          MSG_PRINT(" = ");
+          printHex2(var);
+          MSG_PRINTLN("");
+       }
+       else if (reg == 0x3E) {                   // patable
+          MSG_PRINT(F("C3E = "));
+          readPatable();
+       }
+       else if (reg == 0x99) {                   // alle register
+         for (uint8_t i = 0; i < 0x2f; i++) {
+           if (i == 0 || i == 0x10 || i == 0x20) {
+             if (i > 0) {
+               MSG_PRINT(" ");
+               DBG_PRINTLN(" ");
+             }
+             MSG_PRINT(F("ccreg "));
+             DBG_PRINT(F("ccreg "));
+             printHex2(i);
+             MSG_PRINT(F(": "));
+             sprintf(t, "%02X", i);          
+             DBG_PRINT(t);
+             DBG_PRINT(F(": "));
+           }
+           var = readReg(i, CC1101_CONFIG);
+           sprintf(t, "%02X", var);   
+           DBG_PRINT(t);
+           DBG_PRINT(" ");
+           
+           printHex2(var);
+           MSG_PRINT(" ");
+         }
+         MSG_PRINTLN("");
+         DBG_PRINTLN("");
+       }
+     }
+  }
+  void commandStrobes(void) {
+    uint8_t hex;
+    uint8_t reg;
+    uint8_t val;
+    uint8_t val1;
+
+   if (isHexadecimalDigit(cmdstring.charAt(3))) {
+        hex = (uint8_t)cmdstring.charAt(3);
+        reg = hex2int(hex) + 0x30;
+        if (reg < 0x3e) {
+             val = cmdStrobe(reg);
+             delay(1);
+             val1 = cmdStrobe(0x3D);        //  No operation. May be used to get access to the chip status byte.
+             MSG_PRINT(F("cmdStrobeReg "));
+             printHex2(reg);
+             MSG_PRINT(F(" chipStatus "));
+             val = val >> 4;
+             MSG_PRINT(val, HEX);
+             MSG_PRINT(F(" delay1 "));
+             val = val1 >> 4;
+             MSG_PRINT(val, HEX);
+             MSG_PRINTLN("");
+         }
+     }
+  }
+
+  void writeCCreg(uint8_t reg, uint8_t var) {    // write CC11001 register
+
+    if (reg > 1 && reg < 0x40) {
+           writeReg(reg-2, var);
+           MSG_PRINT("W");
+           printHex2(reg);
+           printHex2(var);
+           MSG_PRINTLN("");
+    }
+  }
+
+void writeCCpatable(uint8_t var) {           // write 8 byte to patable (kein pa ramping)
+//  DBG_PRINTLN("writeCCpatable");  
+  EEPROM.begin(512);
+	for (uint8_t i = 0; i < 8; i++) {
+		if (i == 1) {
+			EEPROM.write(EE_CC1100_PA + i, var);
+		} else {
+			EEPROM.write(EE_CC1100_PA + i, 0);
+		}
+	 }
+  EEPROM.commit();
+  EEPROM.end();
+
+	writePatable();
+//  readPatable();
+}
+  
+void ccFactoryReset() {
+    DBG_PRINTLN("Write EEPROM Defaults");
+
+    EEPROM.begin(512); //Max bytes of eeprom to use
+    yield();
+
+    for (uint8_t i = 0; i<sizeof(initVal); i++) {
+            EEPROM.write(EE_CC1100_CFG + i, pgm_read_byte(&initVal[i]));
+    } 
+    
+    for (uint8_t i = 0; i < 8; i++) {
+      if (i == 1) {
+        EEPROM.write(EE_CC1100_PA + i, PATABLE_DEFAULT);
+      } else {
+        EEPROM.write(EE_CC1100_PA + i, 0);
+      }
+    }
+
+    EEPROM.commit();
+    EEPROM.end();
+    
+    MSG_PRINTLN("ccFactoryReset done");  
+ }
+
+	bool checkCC1101() {
+
+		uint8_t partnum = readReg(0xF0,0x80);  // Partnum
+		uint8_t version = readReg(0xF1,0x80);  // Version
+		DBG_PRINT("CCVersion=");	DBG_PRINTLN(version);
+		DBG_PRINT("CCPartnum=");	DBG_PRINTLN(partnum);
+
+		//checks if valid Chip ID is found. Usualy 0x03 or 0x14. if not -> abort
+		if (version == 0x00 || version == 0xFF)
+		{
+			DBG_PRINTLN(F("no CC11xx found!"));
+			DBG_PRINTLN();
+			return false;  // Todo: power down SPI etc
+		}
+		return true;
+	}
+
+	uint8_t getRSSI()
+	{
+		return readReg(CC1100_RSSI, CC1101_STATUS);// Pruefen ob Umwandung von uint to int den richtigen Wert zurueck gibt
+	}
+	
+	inline void setIdleMode()
+	{
+		cmdStrobe(CC1100_SIDLE);                             // Idle mode
+		delay(1);
+	}
+
+	void setReceiveMode()
+	{
+		setIdleMode();
+		uint8_t maxloop = 0xff;
+
+		while (maxloop-- &&	(cmdStrobe(CC1100_SRX) & CC1100_STATUS_STATE_BM) != CC1100_STATE_RX) // RX enable
+			delay(1);
+		if (maxloop == 0 )		DBG_PRINTLN("CC1101: Setting RX failed");
+
+	}
+
+	void setTransmitMode()
+	{
+		cmdStrobe(CC1100_SFTX);   // wird dies benoetigt? Wir verwenden kein FIFO
+		setIdleMode();
+		uint8_t maxloop = 0xff;
+		while (maxloop-- && (cmdStrobe(CC1100_STX) & CC1100_STATUS_STATE_BM) != CC1100_STATE_TX)  // TX enable
+			delay(1);
+		if (maxloop == 0) DBG_PRINTLN("CC1101: Setting TX failed");
+	}
+
+  void reset(void) 
+{
+  cc1101_Deselect();                    // Deselect CC1101
+  delayMicroseconds(5);
+  cc1101_Select();                      // Select CC1101
+  delayMicroseconds(10);
+  cc1101_Deselect();                    // Deselect CC1101
+  delayMicroseconds(41);
+  cc1101_Select();                      // Select CC1101
+
+  wait_Miso();                          // Wait until MISO goes low
+  SPI.transfer(CC1101_SRES);                // Send reset command strobe
+  wait_Miso();                          // Wait until MISO goes low
+
+  cc1101_Deselect();                    // Deselect CC1101
+  
+//  setCCregs();                          // Reconfigure CC1101
+}
+
+void setCCregs(void) 
+{
+  EEPROM.begin(512);
+  for (uint8_t i = 0; i<sizeof(initVal); i++) {              // write EEPROM value to cc11001
+      writeReg(i,EEPROM.read(EE_CC1100_CFG + i));
+//      DBG_PRINT("I:");DBG_PRINT(i);DBG_PRINT(" "); DBG_PRINT(EEPROM.read(EE_CC1100_CFG + i));DBG_PRINT(" ");
+      delayMicroseconds(20);
+    }
+  EEPROM.end();
+  DBG_PRINTLN("Write Defaults done");
+}
+
+
+	void CCinit(void) {                         // initialize CC1101
+    pinMode(PIN_SEND, INPUT);                 // gdo0Pi, sicherheitshalber bis zum CC1101 init erstmal input     
+    SPI.begin();                              // Initialize SPI interface
+    
+    DBG_PRINTLN("SRES Started");
+    reset();
+    DBG_PRINTLN("POR Done");
+
+    setCCregs();
+		writePatable();                                 // write PatableArray to patable reg
+//    readPatable();
+		delay(1);
+    setReceiveMode();
+//   readCCreg(0x99);
+	}
+
+	bool regCheck() {
+		DBG_PRINT("CC1100_PKTCTRL0="); DBG_PRINT(readReg(CC1100_PKTCTRL0, CC1101_CONFIG));
+		DBG_PRINT(" vs EEPROM PKTCTRL0="); DBG_PRINTLN(initVal[CC1100_PKTCTRL0]);
+
+		DBG_PRINT("C1100_IOCFG2="); DBG_PRINT(readReg(CC1100_IOCFG2, CC1101_CONFIG));
+		DBG_PRINT(" vs EEPROM IOCFG2="); DBG_PRINTLN(initVal[CC1100_IOCFG2]);
+		
+		return (readReg(CC1100_PKTCTRL0, CC1101_CONFIG) == initVal[CC1100_PKTCTRL0]) && (readReg(CC1100_IOCFG2, CC1101_CONFIG) == initVal[CC1100_IOCFG2]);
+	}
+}
+
+#endif
diff -ruwN ./configwifi.cpp ../../trebron106/SIGNALEsp-20170510/configwifi.cpp
--- ./configwifi.cpp	2017-08-17 12:42:53.362692489 +0200
+++ ../../trebron106/SIGNALEsp-20170510/configwifi.cpp	1970-01-01 01:00:00.000000000 +0100
@@ -1,7 +0,0 @@
-// 
-// 
-// 
-
-#include "configwifi.h"
-
-
diff -ruwN ./FastDelegateBind.h ../../trebron106/SIGNALEsp-20170510/FastDelegateBind.h
--- ./FastDelegateBind.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/FastDelegateBind.h	2017-05-01 08:54:58.000000000 +0200
@@ -0,0 +1,243 @@
+//						FastDelegateBind.h 
+//  Helper file for FastDelegates. Provides bind() function, enabling
+//  FastDelegates to be rapidly compared to programs using boost::function and boost::bind.
+//
+//  Documentation is found at http://www.codeproject.com/cpp/FastDelegate.asp
+//
+//		Original author: Jody Hagins.
+//		 Minor changes by Don Clugston.
+//
+// Warning: The arguments to 'bind' are ignored! No actual binding is performed.
+// The behaviour is equivalent to boost::bind only when the basic placeholder 
+// arguments _1, _2, _3, etc are used in order.
+//
+// HISTORY:
+//	1.4 Dec 2004. Initial release as part of FastDelegate 1.4.
+
+
+#ifndef FASTDELEGATEBIND_H
+#define FASTDELEGATEBIND_H
+#if _MSC_VER > 1000
+#pragma once
+#endif // _MSC_VER > 1000
+
+////////////////////////////////////////////////////////////////////////////////
+//						FastDelegate bind()
+//
+//				bind() helper function for boost compatibility.
+//				(Original author: Jody Hagins).
+//
+// Add another helper, so FastDelegate can be a dropin replacement
+// for boost::bind (in a fair number of cases).
+// Note the elipses, because boost::bind() takes place holders
+// but FastDelegate does not care about them.  Getting the place holder
+// mechanism to work, and play well with boost is a bit tricky, so
+// we do the "easy" thing...
+// Assume we have the following code...
+//      using boost::bind;
+//      bind(&Foo:func, &foo, _1, _2);
+// we should be able to replace the "using" with...
+//      using fastdelegate::bind;
+// and everything should work fine...
+////////////////////////////////////////////////////////////////////////////////
+
+#ifdef FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
+
+namespace fastdelegate {
+
+//N=0
+template <class X, class Y, class RetType>
+FastDelegate< RetType (  ) >
+bind(
+    RetType (X::*func)(  ),
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType (  ) >(y, func);
+}
+
+template <class X, class Y, class RetType>
+FastDelegate< RetType (  ) >
+bind(
+    RetType (X::*func)(  ) const,
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType (  ) >(y, func);
+}
+
+//N=1
+template <class X, class Y, class RetType, class Param1>
+FastDelegate< RetType ( Param1 p1 ) >
+bind(
+    RetType (X::*func)( Param1 p1 ),
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1 ) >(y, func);
+}
+
+template <class X, class Y, class RetType, class Param1>
+FastDelegate< RetType ( Param1 p1 ) >
+bind(
+    RetType (X::*func)( Param1 p1 ) const,
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1 ) >(y, func);
+}
+
+//N=2
+template <class X, class Y, class RetType, class Param1, class Param2>
+FastDelegate< RetType ( Param1 p1, Param2 p2 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2 ),
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2 ) >(y, func);
+}
+
+template <class X, class Y, class RetType, class Param1, class Param2>
+FastDelegate< RetType ( Param1 p1, Param2 p2 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2 ) const,
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2 ) >(y, func);
+}
+
+//N=3
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3 ),
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3 ) >(y, func);
+}
+
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3 ) const,
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3 ) >(y, func);
+}
+
+//N=4
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ),
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) >(y, func);
+}
+
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) const,
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4 ) >(y, func);
+}
+
+//N=5
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ),
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) >(y, func);
+}
+
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) const,
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5 ) >(y, func);
+}
+
+//N=6
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ),
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) >(y, func);
+}
+
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) const,
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6 ) >(y, func);
+}
+
+//N=7
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ),
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) >(y, func);
+}
+
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) const,
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7 ) >(y, func);
+}
+
+//N=8
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ),
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) >(y, func);
+}
+
+template <class X, class Y, class RetType, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
+FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) >
+bind(
+    RetType (X::*func)( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) const,
+    Y * y,
+    ...)
+{ 
+  return FastDelegate< RetType ( Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8 ) >(y, func);
+}
+
+
+#endif //FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
+
+} // namespace fastdelegate
+
+#endif // !defined(FASTDELEGATEBIND_H)
+
diff -ruwN ./FastDelegate.h ../../trebron106/SIGNALEsp-20170510/FastDelegate.h
--- ./FastDelegate.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/FastDelegate.h	2017-05-01 08:54:58.000000000 +0200
@@ -0,0 +1,2296 @@
+//						FastDelegate.h
+//	Efficient delegates in C++ that generate only two lines of asm code!
+//  Documentation is found at http://www.codeproject.com/cpp/FastDelegate.asp
+//
+//						- Don Clugston, Mar 2004.
+//		Major contributions were made by Jody Hagins.
+// History:
+// 24-Apr-04 1.0  * Submitted to CodeProject.
+// 28-Apr-04 1.1  * Prevent most unsafe uses of evil static function hack.
+//				  * Improved syntax for horrible_cast (thanks Paul Bludov).
+//				  * Tested on Metrowerks MWCC and Intel ICL (IA32)
+//				  * Compiled, but not run, on Comeau C++ and Intel Itanium ICL.
+//	27-Jun-04 1.2 * Now works on Borland C++ Builder 5.5
+//				  * Now works on /clr "managed C++" code on VC7, VC7.1
+//				  * Comeau C++ now compiles without warnings.
+//				  * Prevent the virtual inheritance case from being used on
+//					  VC6 and earlier, which generate incorrect code.
+//				  * Improved warning and error messages. Non-standard hacks
+//					 now have compile-time checks to make them safer.
+//				  * implicit_cast used instead of static_cast in many cases.
+//				  * If calling a const member function, a const class pointer can be used.
+//				  * MakeDelegate() global helper function added to simplify pass-by-value.
+//				  * Added fastdelegate.clear()
+// 16-Jul-04 1.2.1* Workaround for gcc bug (const member function pointers in templates)
+// 30-Oct-04 1.3  * Support for (non-void) return values.
+//				  * No more workarounds in client code!
+//					 MSVC and Intel now use a clever hack invented by John Dlugosz:
+//				     - The FASTDELEGATEDECLARE workaround is no longer necessary.
+//					 - No more warning messages for VC6
+//				  * Less use of macros. Error messages should be more comprehensible.
+//				  * Added include guards
+//				  * Added FastDelegate::empty() to test if invocation is safe (Thanks Neville Franks).
+//				  * Now tested on VS 2005 Express Beta, PGI C++
+// 24-Dec-04 1.4  * Added DelegateMemento, to allow collections of disparate delegates.
+//                * <,>,<=,>= comparison operators to allow storage in ordered containers.
+//				  * Substantial reduction of code size, especially the 'Closure' class.
+//				  * Standardised all the compiler-specific workarounds.
+//                * MFP conversion now works for CodePlay (but not yet supported in the full code).
+//                * Now compiles without warnings on _any_ supported compiler, including BCC 5.5.1
+//				  * New syntax: FastDelegate< int (char *, double) >.
+// 14-Feb-05 1.4.1* Now treats =0 as equivalent to .clear(), ==0 as equivalent to .empty(). (Thanks elfric).
+//				  * Now tested on Intel ICL for AMD64, VS2005 Beta for AMD64 and Itanium.
+// 30-Mar-05 1.5  * Safebool idiom: "if (dg)" is now equivalent to "if (!dg.empty())"
+//				  * Fully supported by CodePlay VectorC
+//                * Bugfix for Metrowerks: empty() was buggy because a valid MFP can be 0 on MWCC!
+//                * More optimal assignment,== and != operators for static function pointers.
+
+#ifndef FASTDELEGATE_H
+#define FASTDELEGATE_H
+
+#if defined(ARDUINO) && ARDUINO >= 100
+#include "Arduino.h"
+#else
+#include "WProgram.h"
+#endif
+
+//#include <memory.h> // to allow <,> comparisons
+
+////////////////////////////////////////////////////////////////////////////////
+//						Configuration options
+//
+////////////////////////////////////////////////////////////////////////////////
+
+// Uncomment the following #define for optimally-sized delegates.
+// In this case, the generated asm code is almost identical to the code you'd get
+// if the compiler had native support for delegates.
+// It will not work on systems where sizeof(dataptr) < sizeof(codeptr).
+// Thus, it will not work for DOS compilers using the medium model.
+// It will also probably fail on some DSP systems.
+#define FASTDELEGATE_USESTATICFUNCTIONHACK
+
+// Uncomment the next line to allow function declarator syntax.
+// It is automatically enabled for those compilers where it is known to work.
+//#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
+
+////////////////////////////////////////////////////////////////////////////////
+//						Compiler identification for workarounds
+//
+////////////////////////////////////////////////////////////////////////////////
+
+// Compiler identification. It's not easy to identify Visual C++ because
+// many vendors fraudulently define Microsoft's identifiers.
+#if defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__VECTOR_C) && !defined(__ICL) && !defined(__BORLANDC__)
+#define FASTDLGT_ISMSVC
+
+#if (_MSC_VER <1300) // Many workarounds are required for VC6.
+#define FASTDLGT_VC6
+#pragma warning(disable:4786) // disable this ridiculous warning
+#endif
+
+#endif
+
+// Does the compiler uses Microsoft's member function pointer structure?
+// If so, it needs special treatment.
+// Metrowerks CodeWarrior, Intel, and CodePlay fraudulently define Microsoft's
+// identifier, _MSC_VER. We need to filter Metrowerks out.
+#if defined(_MSC_VER) && !defined(__MWERKS__)
+#define FASTDLGT_MICROSOFT_MFP
+
+#if !defined(__VECTOR_C)
+// CodePlay doesn't have the __single/multi/virtual_inheritance keywords
+#define FASTDLGT_HASINHERITANCE_KEYWORDS
+#endif
+#endif
+
+// Does it allow function declarator syntax? The following compilers are known to work:
+#if defined(FASTDLGT_ISMSVC) && (_MSC_VER >=1310) // VC 7.1
+#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
+#endif
+
+// Gcc(2.95+), and versions of Digital Mars, Intel and Comeau in common use.
+#if defined (__DMC__) || defined(__GNUC__) || defined(__ICL) || defined(__COMO__)
+#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
+#endif
+
+// It works on Metrowerks MWCC 3.2.2. From boost.Config it should work on earlier ones too.
+#if defined (__MWERKS__)
+#define FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
+#endif
+
+#ifdef __GNUC__ // Workaround GCC bug #8271
+// At present, GCC doesn't recognize constness of MFPs in templates
+#define FASTDELEGATE_GCC_BUG_8271
+#endif
+
+
+
+////////////////////////////////////////////////////////////////////////////////
+//						General tricks used in this code
+//
+// (a) Error messages are generated by typdefing an array of negative size to
+//     generate compile-time errors.
+// (b) Warning messages on MSVC are generated by declaring unused variables, and
+//	    enabling the "variable XXX is never used" warning.
+// (c) Unions are used in a few compiler-specific cases to perform illegal casts.
+// (d) For Microsoft and Intel, when adjusting the 'this' pointer, it's cast to
+//     (char *) first to ensure that the correct number of *bytes* are added.
+//
+////////////////////////////////////////////////////////////////////////////////
+//						Helper templates
+//
+////////////////////////////////////////////////////////////////////////////////
+
+
+namespace fastdelegate {
+	namespace detail {	// we'll hide the implementation details in a nested namespace.
+
+						//		implicit_cast< >
+						// I believe this was originally going to be in the C++ standard but
+						// was left out by accident. It's even milder than static_cast.
+						// I use it instead of static_cast<> to emphasize that I'm not doing
+						// anything nasty.
+						// Usage is identical to static_cast<>
+		template <class OutputClass, class InputClass>
+		inline OutputClass implicit_cast(InputClass input) {
+			return input;
+		}
+
+		//		horrible_cast< >
+		// This is truly evil. It completely subverts C++'s type system, allowing you
+		// to cast from any class to any other class. Technically, using a union
+		// to perform the cast is undefined behaviour (even in C). But we can see if
+		// it is OK by checking that the union is the same size as each of its members.
+		// horrible_cast<> should only be used for compiler-specific workarounds.
+		// Usage is identical to reinterpret_cast<>.
+
+		// This union is declared outside the horrible_cast because BCC 5.5.1
+		// can't inline a function with a nested class, and gives a warning.
+		template <class OutputClass, class InputClass>
+		union horrible_union {
+			OutputClass out;
+			InputClass in;
+		};
+
+		template <class OutputClass, class InputClass>
+		inline OutputClass horrible_cast(const InputClass input) {
+			horrible_union<OutputClass, InputClass> u;
+			// Cause a compile-time error if in, out and u are not the same size.
+			// If the compile fails here, it means the compiler has peculiar
+			// unions which would prevent the cast from working.
+			typedef int ERROR_CantUseHorrible_cast[sizeof(InputClass) == sizeof(u)
+				&& sizeof(InputClass) == sizeof(OutputClass) ? 1 : -1];
+			u.in = input;
+			return u.out;
+		}
+
+		////////////////////////////////////////////////////////////////////////////////
+		//						Workarounds
+		//
+		////////////////////////////////////////////////////////////////////////////////
+
+		// Backwards compatibility: This macro used to be necessary in the virtual inheritance
+		// case for Intel and Microsoft. Now it just forward-declares the class.
+#define FASTDELEGATEDECLARE(CLASSNAME)	class CLASSNAME;
+
+		// Prevent use of the static function hack with the DOS medium model.
+#ifdef __MEDIUM__
+#undef FASTDELEGATE_USESTATICFUNCTIONHACK
+#endif
+
+		//			DefaultVoid - a workaround for 'void' templates in VC6.
+		//
+		//  (1) VC6 and earlier do not allow 'void' as a default template argument.
+		//  (2) They also doesn't allow you to return 'void' from a function.
+		//
+		// Workaround for (1): Declare a dummy type 'DefaultVoid' which we use
+		//   when we'd like to use 'void'. We convert it into 'void' and back
+		//   using the templates DefaultVoidToVoid<> and VoidToDefaultVoid<>.
+		// Workaround for (2): On VC6, the code for calling a void function is
+		//   identical to the code for calling a non-void function in which the
+		//   return value is never used, provided the return value is returned
+		//   in the EAX register, rather than on the stack.
+		//   This is true for most fundamental types such as int, enum, void *.
+		//   Const void * is the safest option since it doesn't participate
+		//   in any automatic conversions. But on a 16-bit compiler it might
+		//   cause extra code to be generated, so we disable it for all compilers
+		//   except for VC6 (and VC5).
+#ifdef FASTDLGT_VC6
+		// VC6 workaround
+		typedef const void * DefaultVoid;
+#else
+		// On any other compiler, just use a normal void.
+		typedef void DefaultVoid;
+#endif
+
+		// Translate from 'DefaultVoid' to 'void'.
+		// Everything else is unchanged
+		template <class T>
+		struct DefaultVoidToVoid { typedef T type; };
+
+		template <>
+		struct DefaultVoidToVoid<DefaultVoid> { typedef void type; };
+
+		// Translate from 'void' into 'DefaultVoid'
+		// Everything else is unchanged
+		template <class T>
+		struct VoidToDefaultVoid { typedef T type; };
+
+		template <>
+		struct VoidToDefaultVoid<void> { typedef DefaultVoid type; };
+
+
+
+		////////////////////////////////////////////////////////////////////////////////
+		//						Fast Delegates, part 1:
+		//
+		//		Conversion of member function pointer to a standard form
+		//
+		////////////////////////////////////////////////////////////////////////////////
+
+		// GenericClass is a fake class, ONLY used to provide a type.
+		// It is vitally important that it is never defined, so that the compiler doesn't
+		// think it can optimize the invocation. For example, Borland generates simpler
+		// code if it knows the class only uses single inheritance.
+
+		// Compilers using Microsoft's structure need to be treated as a special case.
+#ifdef  FASTDLGT_MICROSOFT_MFP
+
+#ifdef FASTDLGT_HASINHERITANCE_KEYWORDS
+		// For Microsoft and Intel, we want to ensure that it's the most efficient type of MFP
+		// (4 bytes), even when the /vmg option is used. Declaring an empty class
+		// would give 16 byte pointers in this case....
+		class __single_inheritance GenericClass;
+#endif
+		// ...but for Codeplay, an empty class *always* gives 4 byte pointers.
+		// If compiled with the /clr option ("managed C++"), the JIT compiler thinks
+		// it needs to load GenericClass before it can call any of its functions,
+		// (compiles OK but crashes at runtime!), so we need to declare an
+		// empty class to make it happy.
+		// Codeplay and VC4 can't cope with the unknown_inheritance case either.
+		class GenericClass {};
+#else
+		class GenericClass;
+#endif
+
+		// The size of a single inheritance member function pointer.
+		const int SINGLE_MEMFUNCPTR_SIZE = sizeof(void (GenericClass::*)());
+
+		//						SimplifyMemFunc< >::Convert()
+		//
+		//	A template function that converts an arbitrary member function pointer into the
+		//	simplest possible form of member function pointer, using a supplied 'this' pointer.
+		//  According to the standard, this can be done legally with reinterpret_cast<>.
+		//	For (non-standard) compilers which use member function pointers which vary in size
+		//  depending on the class, we need to use	knowledge of the internal structure of a
+		//  member function pointer, as used by the compiler. Template specialization is used
+		//  to distinguish between the sizes. Because some compilers don't support partial
+		//	template specialisation, I use full specialisation of a wrapper struct.
+
+		// general case -- don't know how to convert it. Force a compile failure
+		template <int N>
+		struct SimplifyMemFunc {
+			template <class X, class XFuncType, class GenericMemFuncType>
+			inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
+				GenericMemFuncType &bound_func) {
+				// Unsupported member function type -- force a compile failure.
+				// (it's illegal to have a array with negative size).
+				typedef char ERROR_Unsupported_member_function_pointer_on_this_compiler[N - 100];
+				return 0;
+			}
+		};
+
+		// For compilers where all member func ptrs are the same size, everything goes here.
+		// For non-standard compilers, only single_inheritance classes go here.
+		template <>
+		struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE> {
+			template <class X, class XFuncType, class GenericMemFuncType>
+			inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
+				GenericMemFuncType &bound_func) {
+#if defined __DMC__
+				// Digital Mars doesn't allow you to cast between abitrary PMF's,
+				// even though the standard says you can. The 32-bit compiler lets you
+				// static_cast through an int, but the DOS compiler doesn't.
+				bound_func = horrible_cast<GenericMemFuncType>(function_to_bind);
+#else
+				bound_func = reinterpret_cast<GenericMemFuncType>(function_to_bind);
+#endif
+				return reinterpret_cast<GenericClass *>(pthis);
+			}
+		};
+
+		////////////////////////////////////////////////////////////////////////////////
+		//						Fast Delegates, part 1b:
+		//
+		//					Workarounds for Microsoft and Intel
+		//
+		////////////////////////////////////////////////////////////////////////////////
+
+
+		// Compilers with member function pointers which violate the standard (MSVC, Intel, Codeplay),
+		// need to be treated as a special case.
+#ifdef FASTDLGT_MICROSOFT_MFP
+
+		// We use unions to perform horrible_casts. I would like to use #pragma pack(push, 1)
+		// at the start of each function for extra safety, but VC6 seems to ICE
+		// intermittently if you do this inside a template.
+
+		// __multiple_inheritance classes go here
+		// Nasty hack for Microsoft and Intel (IA32 and Itanium)
+		template<>
+		struct SimplifyMemFunc< SINGLE_MEMFUNCPTR_SIZE + sizeof(int) > {
+			template <class X, class XFuncType, class GenericMemFuncType>
+			inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
+				GenericMemFuncType &bound_func) {
+				// We need to use a horrible_cast to do this conversion.
+				// In MSVC, a multiple inheritance member pointer is internally defined as:
+				union {
+					XFuncType func;
+					struct {
+						GenericMemFuncType funcaddress; // points to the actual member function
+						int delta;	     // #BYTES to be added to the 'this' pointer
+					}s;
+				} u;
+				// Check that the horrible_cast will work
+				typedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind) == sizeof(u.s) ? 1 : -1];
+				u.func = function_to_bind;
+				bound_func = u.s.funcaddress;
+				return reinterpret_cast<GenericClass *>(reinterpret_cast<char *>(pthis) + u.s.delta);
+			}
+		};
+
+		// virtual inheritance is a real nuisance. It's inefficient and complicated.
+		// On MSVC and Intel, there isn't enough information in the pointer itself to
+		// enable conversion to a closure pointer. Earlier versions of this code didn't
+		// work for all cases, and generated a compile-time error instead.
+		// But a very clever hack invented by John M. Dlugosz solves this problem.
+		// My code is somewhat different to his: I have no asm code, and I make no
+		// assumptions about the calling convention that is used.
+
+		// In VC++ and ICL, a virtual_inheritance member pointer
+		// is internally defined as:
+		struct MicrosoftVirtualMFP {
+			void (GenericClass::*codeptr)(); // points to the actual member function
+			int delta;		// #bytes to be added to the 'this' pointer
+			int vtable_index; // or 0 if no virtual inheritance
+		};
+		// The CRUCIAL feature of Microsoft/Intel MFPs which we exploit is that the
+		// m_codeptr member is *always* called, regardless of the values of the other
+		// members. (This is *not* true for other compilers, eg GCC, which obtain the
+		// function address from the vtable if a virtual function is being called).
+		// Dlugosz's trick is to make the codeptr point to a probe function which
+		// returns the 'this' pointer that was used.
+
+		// Define a generic class that uses virtual inheritance.
+		// It has a trival member function that returns the value of the 'this' pointer.
+		struct GenericVirtualClass : virtual public GenericClass
+		{
+			typedef GenericVirtualClass * (GenericVirtualClass::*ProbePtrType)();
+			GenericVirtualClass * GetThis() { return this; }
+		};
+
+		// __virtual_inheritance classes go here
+		template <>
+		struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 2 * sizeof(int) >
+		{
+
+			template <class X, class XFuncType, class GenericMemFuncType>
+			inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
+				GenericMemFuncType &bound_func) {
+				union {
+					XFuncType func;
+					GenericClass* (X::*ProbeFunc)();
+					MicrosoftVirtualMFP s;
+				} u;
+				u.func = function_to_bind;
+				bound_func = reinterpret_cast<GenericMemFuncType>(u.s.codeptr);
+				union {
+					GenericVirtualClass::ProbePtrType virtfunc;
+					MicrosoftVirtualMFP s;
+				} u2;
+				// Check that the horrible_cast<>s will work
+				typedef int ERROR_CantUsehorrible_cast[sizeof(function_to_bind) == sizeof(u.s)
+					&& sizeof(function_to_bind) == sizeof(u.ProbeFunc)
+					&& sizeof(u2.virtfunc) == sizeof(u2.s) ? 1 : -1];
+				// Unfortunately, taking the address of a MF prevents it from being inlined, so
+				// this next line can't be completely optimised away by the compiler.
+				u2.virtfunc = &GenericVirtualClass::GetThis;
+				u.s.codeptr = u2.s.codeptr;
+				return (pthis->*u.ProbeFunc)();
+			}
+		};
+
+#if (_MSC_VER <1300)
+
+		// Nasty hack for Microsoft Visual C++ 6.0
+		// unknown_inheritance classes go here
+		// There is a compiler bug in MSVC6 which generates incorrect code in this case!!
+		template <>
+		struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3 * sizeof(int) >
+		{
+			template <class X, class XFuncType, class GenericMemFuncType>
+			inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
+				GenericMemFuncType &bound_func) {
+				// There is an apalling but obscure compiler bug in MSVC6 and earlier:
+				// vtable_index and 'vtordisp' are always set to 0 in the
+				// unknown_inheritance case!
+				// This means that an incorrect function could be called!!!
+				// Compiling with the /vmg option leads to potentially incorrect code.
+				// This is probably the reason that the IDE has a user interface for specifying
+				// the /vmg option, but it is disabled -  you can only specify /vmg on
+				// the command line. In VC1.5 and earlier, the compiler would ICE if it ever
+				// encountered this situation.
+				// It is OK to use the /vmg option if /vmm or /vms is specified.
+
+				// Fortunately, the wrong function is only called in very obscure cases.
+				// It only occurs when a derived class overrides a virtual function declared
+				// in a virtual base class, and the member function
+				// points to the *Derived* version of that function. The problem can be
+				// completely averted in 100% of cases by using the *Base class* for the
+				// member fpointer. Ie, if you use the base class as an interface, you'll
+				// stay out of trouble.
+				// Occasionally, you might want to point directly to a derived class function
+				// that isn't an override of a base class. In this case, both vtable_index
+				// and 'vtordisp' are zero, but a virtual_inheritance pointer will be generated.
+				// We can generate correct code in this case. To prevent an incorrect call from
+				// ever being made, on MSVC6 we generate a warning, and call a function to
+				// make the program crash instantly.
+				typedef char ERROR_VC6CompilerBug[-100];
+				return 0;
+			}
+		};
+
+
+#else
+
+		// Nasty hack for Microsoft and Intel (IA32 and Itanium)
+		// unknown_inheritance classes go here
+		// This is probably the ugliest bit of code I've ever written. Look at the casts!
+		// There is a compiler bug in MSVC6 which prevents it from using this code.
+		template <>
+		struct SimplifyMemFunc<SINGLE_MEMFUNCPTR_SIZE + 3 * sizeof(int) >
+		{
+			template <class X, class XFuncType, class GenericMemFuncType>
+			inline static GenericClass *Convert(X *pthis, XFuncType function_to_bind,
+				GenericMemFuncType &bound_func) {
+				// The member function pointer is 16 bytes long. We can't use a normal cast, but
+				// we can use a union to do the conversion.
+				union {
+					XFuncType func;
+					// In VC++ and ICL, an unknown_inheritance member pointer
+					// is internally defined as:
+					struct {
+						GenericMemFuncType m_funcaddress; // points to the actual member function
+						int delta;		// #bytes to be added to the 'this' pointer
+						int vtordisp;		// #bytes to add to 'this' to find the vtable
+						int vtable_index; // or 0 if no virtual inheritance
+					} s;
+				} u;
+				// Check that the horrible_cast will work
+				typedef int ERROR_CantUsehorrible_cast[sizeof(XFuncType) == sizeof(u.s) ? 1 : -1];
+				u.func = function_to_bind;
+				bound_func = u.s.funcaddress;
+				int virtual_delta = 0;
+				if (u.s.vtable_index) { // Virtual inheritance is used
+										// First, get to the vtable.
+										// It is 'vtordisp' bytes from the start of the class.
+					const int * vtable = *reinterpret_cast<const int *const*>(
+						reinterpret_cast<const char *>(pthis) + u.s.vtordisp);
+
+					// 'vtable_index' tells us where in the table we should be looking.
+					virtual_delta = u.s.vtordisp + *reinterpret_cast<const int *>(
+						reinterpret_cast<const char *>(vtable) + u.s.vtable_index);
+				}
+				// The int at 'virtual_delta' gives us the amount to add to 'this'.
+				// Finally we can add the three components together. Phew!
+				return reinterpret_cast<GenericClass *>(
+					reinterpret_cast<char *>(pthis) + u.s.delta + virtual_delta);
+			};
+		};
+#endif // MSVC 7 and greater
+
+#endif // MS/Intel hacks
+
+	}  // namespace detail
+
+	   ////////////////////////////////////////////////////////////////////////////////
+	   //						Fast Delegates, part 2:
+	   //
+	   //	Define the delegate storage, and cope with static functions
+	   //
+	   ////////////////////////////////////////////////////////////////////////////////
+
+	   // DelegateMemento -- an opaque structure which can hold an arbitary delegate.
+	   // It knows nothing about the calling convention or number of arguments used by
+	   // the function pointed to.
+	   // It supplies comparison operators so that it can be stored in STL collections.
+	   // It cannot be set to anything other than null, nor invoked directly:
+	   //   it must be converted to a specific delegate.
+
+	   // Implementation:
+	   // There are two possible implementations: the Safe method and the Evil method.
+	   //				DelegateMemento - Safe version
+	   //
+	   // This implementation is standard-compliant, but a bit tricky.
+	   // A static function pointer is stored inside the class.
+	   // Here are the valid values:
+	   // +-- Static pointer --+--pThis --+-- pMemFunc-+-- Meaning------+
+	   // |   0				|  0       |   0        | Empty          |
+	   // |   !=0              |(dontcare)|  Invoker   | Static function|
+	   // |   0                |  !=0     |  !=0*      | Method call    |
+	   // +--------------------+----------+------------+----------------+
+	   //  * For Metrowerks, this can be 0. (first virtual function in a
+	   //       single_inheritance class).
+	   // When stored stored inside a specific delegate, the 'dontcare' entries are replaced
+	   // with a reference to the delegate itself. This complicates the = and == operators
+	   // for the delegate class.
+
+	   //				DelegateMemento - Evil version
+	   //
+	   // For compilers where data pointers are at least as big as code pointers, it is
+	   // possible to store the function pointer in the this pointer, using another
+	   // horrible_cast. In this case the DelegateMemento implementation is simple:
+	   // +--pThis --+-- pMemFunc-+-- Meaning---------------------+
+	   // |    0     |  0         | Empty                         |
+	   // |  !=0     |  !=0*      | Static function or method call|
+	   // +----------+------------+-------------------------------+
+	   //  * For Metrowerks, this can be 0. (first virtual function in a
+	   //       single_inheritance class).
+	   // Note that the Sun C++ and MSVC documentation explicitly state that they
+	   // support static_cast between void * and function pointers.
+
+	class DelegateMemento {
+	protected:
+		// the data is protected, not private, because many
+		// compilers have problems with template friends.
+		typedef void (detail::GenericClass::*GenericMemFuncType)(); // arbitrary MFP.
+		detail::GenericClass *m_pthis;
+		GenericMemFuncType m_pFunction;
+
+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+		typedef void(*GenericFuncPtr)(); // arbitrary code pointer
+		GenericFuncPtr m_pStaticFunction;
+#endif
+
+	public:
+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+		DelegateMemento() : m_pthis(0), m_pFunction(0), m_pStaticFunction(0) {};
+		void clear() {
+			m_pthis = 0; m_pFunction = 0; m_pStaticFunction = 0;
+		}
+#else
+		DelegateMemento() : m_pthis(0), m_pFunction(0) {};
+		void clear() { m_pthis = 0; m_pFunction = 0; }
+#endif
+	public:
+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+		inline bool IsEqual(const DelegateMemento &x) const {
+			// We have to cope with the static function pointers as a special case
+			if (m_pFunction != x.m_pFunction) return false;
+			// the static function ptrs must either both be equal, or both be 0.
+			if (m_pStaticFunction != x.m_pStaticFunction) return false;
+			if (m_pStaticFunction != 0) return m_pthis == x.m_pthis;
+			else return true;
+		}
+#else // Evil Method
+		inline bool IsEqual(const DelegateMemento &x) const {
+			return m_pthis == x.m_pthis && m_pFunction == x.m_pFunction;
+		}
+#endif
+		// Provide a strict weak ordering for DelegateMementos.
+		inline bool IsLess(const DelegateMemento &right) const {
+			// deal with static function pointers first
+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+			if (m_pStaticFunction != 0 || right.m_pStaticFunction != 0)
+				return m_pStaticFunction < right.m_pStaticFunction;
+#endif
+			if (m_pthis != right.m_pthis) return m_pthis < right.m_pthis;
+			// There are no ordering operators for member function pointers,
+			// but we can fake one by comparing each byte. The resulting ordering is
+			// arbitrary (and compiler-dependent), but it permits storage in ordered STL containers.
+			return memcmp(&m_pFunction, &right.m_pFunction, sizeof(m_pFunction)) < 0;
+
+		}
+		// BUGFIX (Mar 2005):
+		// We can't just compare m_pFunction because on Metrowerks,
+		// m_pFunction can be zero even if the delegate is not empty!
+		inline bool operator ! () const		// Is it bound to anything?
+		{
+			return m_pthis == 0 && m_pFunction == 0;
+		}
+		inline bool empty() const		// Is it bound to anything?
+		{
+			return m_pthis == 0 && m_pFunction == 0;
+		}
+	public:
+		DelegateMemento & operator = (const DelegateMemento &right) {
+			SetMementoFrom(right);
+			return *this;
+		}
+		inline bool operator <(const DelegateMemento &right) {
+			return IsLess(right);
+		}
+		inline bool operator >(const DelegateMemento &right) {
+			return right.IsLess(*this);
+		}
+		DelegateMemento(const DelegateMemento &right) :
+			m_pFunction(right.m_pFunction), m_pthis(right.m_pthis)
+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+			, m_pStaticFunction(right.m_pStaticFunction)
+#endif
+		{}
+	protected:
+		void SetMementoFrom(const DelegateMemento &right) {
+			m_pFunction = right.m_pFunction;
+			m_pthis = right.m_pthis;
+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+			m_pStaticFunction = right.m_pStaticFunction;
+#endif
+		}
+	};
+
+
+	//						ClosurePtr<>
+	//
+	// A private wrapper class that adds function signatures to DelegateMemento.
+	// It's the class that does most of the actual work.
+	// The signatures are specified by:
+	// GenericMemFunc: must be a type of GenericClass member function pointer.
+	// StaticFuncPtr:  must be a type of function pointer with the same signature
+	//                 as GenericMemFunc.
+	// UnvoidStaticFuncPtr: is the same as StaticFuncPtr, except on VC6
+	//                 where it never returns void (returns DefaultVoid instead).
+
+	// An outer class, FastDelegateN<>, handles the invoking and creates the
+	// necessary typedefs.
+	// This class does everything else.
+
+	namespace detail {
+
+		template < class GenericMemFunc, class StaticFuncPtr, class UnvoidStaticFuncPtr>
+		class ClosurePtr : public DelegateMemento {
+		public:
+			// These functions are for setting the delegate to a member function.
+
+			// Here's the clever bit: we convert an arbitrary member function into a
+			// standard form. XMemFunc should be a member function of class X, but I can't
+			// enforce that here. It needs to be enforced by the wrapper class.
+			template < class X, class XMemFunc >
+			inline void bindmemfunc(X *pthis, XMemFunc function_to_bind) {
+				m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
+					::Convert(pthis, function_to_bind, m_pFunction);
+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+				m_pStaticFunction = 0;
+#endif
+			}
+			// For const member functions, we only need a const class pointer.
+			// Since we know that the member function is const, it's safe to
+			// remove the const qualifier from the 'this' pointer with a const_cast.
+			// VC6 has problems if we just overload 'bindmemfunc', so we give it a different name.
+			template < class X, class XMemFunc>
+			inline void bindconstmemfunc(const X *pthis, XMemFunc function_to_bind) {
+				m_pthis = SimplifyMemFunc< sizeof(function_to_bind) >
+					::Convert(const_cast<X*>(pthis), function_to_bind, m_pFunction);
+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+				m_pStaticFunction = 0;
+#endif
+			}
+#ifdef FASTDELEGATE_GCC_BUG_8271	// At present, GCC doesn't recognize constness of MFPs in templates
+			template < class X, class XMemFunc>
+			inline void bindmemfunc(const X *pthis, XMemFunc function_to_bind) {
+				bindconstmemfunc(pthis, function_to_bind);
+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+				m_pStaticFunction = 0;
+#endif
+			}
+#endif
+			// These functions are required for invoking the stored function
+			inline GenericClass *GetClosureThis() const { return m_pthis; }
+			inline GenericMemFunc GetClosureMemPtr() const { return reinterpret_cast<GenericMemFunc>(m_pFunction); }
+
+			// There are a few ways of dealing with static function pointers.
+			// There's a standard-compliant, but tricky method.
+			// There's also a straightforward hack, that won't work on DOS compilers using the
+			// medium memory model. It's so evil that I can't recommend it, but I've
+			// implemented it anyway because it produces very nice asm code.
+
+#if !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+
+			//				ClosurePtr<> - Safe version
+			//
+			// This implementation is standard-compliant, but a bit tricky.
+			// I store the function pointer inside the class, and the delegate then
+			// points to itself. Whenever the delegate is copied, these self-references
+			// must be transformed, and this complicates the = and == operators.
+		public:
+			// The next two functions are for operator ==, =, and the copy constructor.
+			// We may need to convert the m_pthis pointers, so that
+			// they remain as self-references.
+			template< class DerivedClass >
+			inline void CopyFrom(DerivedClass *pParent, const DelegateMemento &x) {
+				SetMementoFrom(x);
+				if (m_pStaticFunction != 0) {
+					// transform self references...
+					m_pthis = reinterpret_cast<GenericClass *>(pParent);
+				}
+			}
+			// For static functions, the 'static_function_invoker' class in the parent
+			// will be called. The parent then needs to call GetStaticFunction() to find out
+			// the actual function to invoke.
+			template < class DerivedClass, class ParentInvokerSig >
+			inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker,
+				StaticFuncPtr function_to_bind) {
+				if (function_to_bind == 0) { // cope with assignment to 0
+					m_pFunction = 0;
+				}
+				else {
+					bindmemfunc(pParent, static_function_invoker);
+				}
+				m_pStaticFunction = reinterpret_cast<GenericFuncPtr>(function_to_bind);
+			}
+			inline UnvoidStaticFuncPtr GetStaticFunction() const {
+				return reinterpret_cast<UnvoidStaticFuncPtr>(m_pStaticFunction);
+			}
+#else
+
+			//				ClosurePtr<> - Evil version
+			//
+			// For compilers where data pointers are at least as big as code pointers, it is
+			// possible to store the function pointer in the this pointer, using another
+			// horrible_cast. Invocation isn't any faster, but it saves 4 bytes, and
+			// speeds up comparison and assignment. If C++ provided direct language support
+			// for delegates, they would produce asm code that was almost identical to this.
+			// Note that the Sun C++ and MSVC documentation explicitly state that they
+			// support static_cast between void * and function pointers.
+
+			template< class DerivedClass >
+			inline void CopyFrom(DerivedClass *pParent, const DelegateMemento &right) {
+				SetMementoFrom(right);
+			}
+			// For static functions, the 'static_function_invoker' class in the parent
+			// will be called. The parent then needs to call GetStaticFunction() to find out
+			// the actual function to invoke.
+			// ******** EVIL, EVIL CODE! *******
+			template < 	class DerivedClass, class ParentInvokerSig>
+			inline void bindstaticfunc(DerivedClass *pParent, ParentInvokerSig static_function_invoker,
+				StaticFuncPtr function_to_bind) {
+				if (function_to_bind == 0) { // cope with assignment to 0
+					m_pFunction = 0;
+				}
+				else {
+					// We'll be ignoring the 'this' pointer, but we need to make sure we pass
+					// a valid value to bindmemfunc().
+					bindmemfunc(pParent, static_function_invoker);
+				}
+
+				// WARNING! Evil hack. We store the function in the 'this' pointer!
+				// Ensure that there's a compilation failure if function pointers
+				// and data pointers have different sizes.
+				// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
+				typedef int ERROR_CantUseEvilMethod[sizeof(GenericClass *) == sizeof(function_to_bind) ? 1 : -1];
+				m_pthis = horrible_cast<GenericClass *>(function_to_bind);
+				// MSVC, SunC++ and DMC accept the following (non-standard) code:
+				//		m_pthis = static_cast<GenericClass *>(static_cast<void *>(function_to_bind));
+				// BCC32, Comeau and DMC accept this method. MSVC7.1 needs __int64 instead of long
+				//		m_pthis = reinterpret_cast<GenericClass *>(reinterpret_cast<long>(function_to_bind));
+			}
+			// ******** EVIL, EVIL CODE! *******
+			// This function will be called with an invalid 'this' pointer!!
+			// We're just returning the 'this' pointer, converted into
+			// a function pointer!
+			inline UnvoidStaticFuncPtr GetStaticFunction() const {
+				// Ensure that there's a compilation failure if function pointers
+				// and data pointers have different sizes.
+				// If you get this error, you need to #undef FASTDELEGATE_USESTATICFUNCTIONHACK.
+				typedef int ERROR_CantUseEvilMethod[sizeof(UnvoidStaticFuncPtr) == sizeof(this) ? 1 : -1];
+				return horrible_cast<UnvoidStaticFuncPtr>(this);
+			}
+#endif // !defined(FASTDELEGATE_USESTATICFUNCTIONHACK)
+
+			// Does the closure contain this static function?
+			inline bool IsEqualToStaticFuncPtr(StaticFuncPtr funcptr) {
+				if (funcptr == 0) return empty();
+				// For the Evil method, if it doesn't actually contain a static function, this will return an arbitrary
+				// value that is not equal to any valid function pointer.
+				else return funcptr == reinterpret_cast<StaticFuncPtr>(GetStaticFunction());
+			}
+		};
+
+
+	} // namespace detail
+
+	  ////////////////////////////////////////////////////////////////////////////////
+	  //						Fast Delegates, part 3:
+	  //
+	  //				Wrapper classes to ensure type safety
+	  //
+	  ////////////////////////////////////////////////////////////////////////////////
+
+
+	  // Once we have the member function conversion templates, it's easy to make the
+	  // wrapper classes. So that they will work with as many compilers as possible,
+	  // the classes are of the form
+	  //   FastDelegate3<int, char *, double>
+	  // They can cope with any combination of parameters. The max number of parameters
+	  // allowed is 8, but it is trivial to increase this limit.
+	  // Note that we need to treat const member functions seperately.
+	  // All this class does is to enforce type safety, and invoke the delegate with
+	  // the correct list of parameters.
+
+	  // Because of the weird rule about the class of derived member function pointers,
+	  // you sometimes need to apply a downcast to the 'this' pointer.
+	  // This is the reason for the use of "implicit_cast<X*>(pthis)" in the code below.
+	  // If CDerivedClass is derived from CBaseClass, but doesn't override SimpleVirtualFunction,
+	  // without this trick you'd need to write:
+	  //		MyDelegate(static_cast<CBaseClass *>(&d), &CDerivedClass::SimpleVirtualFunction);
+	  // but with the trick you can write
+	  //		MyDelegate(&d, &CDerivedClass::SimpleVirtualFunction);
+
+	  // RetType is the type the compiler uses in compiling the template. For VC6,
+	  // it cannot be void. DesiredRetType is the real type which is returned from
+	  // all of the functions. It can be void.
+
+	  // Implicit conversion to "bool" is achieved using the safe_bool idiom,
+	  // using member data pointers (MDP). This allows "if (dg)..." syntax
+	  // Because some compilers (eg codeplay) don't have a unique value for a zero
+	  // MDP, an extra padding member is added to the SafeBool struct.
+	  // Some compilers (eg VC6) won't implicitly convert from 0 to an MDP, so
+	  // in that case the static function constructor is not made explicit; this
+	  // allows "if (dg==0) ..." to compile.
+
+	  //N=0
+	template<class RetType = detail::DefaultVoid>
+	class FastDelegate0 {
+	private:
+		typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
+		typedef DesiredRetType(*StaticFunctionPtr)();
+		typedef RetType(*UnvoidStaticFunctionPtr)();
+		typedef RetType(detail::GenericClass::*GenericMemFn)();
+		typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
+		ClosureType m_Closure;
+	public:
+		// Typedefs to aid generic programming
+		typedef FastDelegate0 type;
+
+		// Construction and comparison functions
+		FastDelegate0() { clear(); }
+		FastDelegate0(const FastDelegate0 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		void operator = (const FastDelegate0 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		bool operator ==(const FastDelegate0 &x) const {
+			return m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator !=(const FastDelegate0 &x) const {
+			return !m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator <(const FastDelegate0 &x) const {
+			return m_Closure.IsLess(x.m_Closure);
+		}
+		bool operator >(const FastDelegate0 &x) const {
+			return x.m_Closure.IsLess(m_Closure);
+		}
+		// Binding to non-const member functions
+		template < class X, class Y >
+		FastDelegate0(Y *pthis, DesiredRetType(X::* function_to_bind)()) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(Y *pthis, DesiredRetType(X::* function_to_bind)()) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		// Binding to const member functions.
+		template < class X, class Y >
+		FastDelegate0(const Y *pthis, DesiredRetType(X::* function_to_bind)() const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(const Y *pthis, DesiredRetType(X::* function_to_bind)() const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
+		}
+		// Static functions. We convert them into a member function call.
+		// This constructor also provides implicit conversion
+		FastDelegate0(DesiredRetType(*function_to_bind)()) {
+			bind(function_to_bind);
+		}
+		// for efficiency, prevent creation of a temporary
+		void operator = (DesiredRetType(*function_to_bind)()) {
+			bind(function_to_bind);
+		}
+		inline void bind(DesiredRetType(*function_to_bind)()) {
+			m_Closure.bindstaticfunc(this, &FastDelegate0::InvokeStaticFunction,
+				function_to_bind);
+		}
+		// Invoke the delegate
+		RetType operator() () const {
+			return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))();
+		}
+		// Implicit conversion to "bool" using the safe_bool idiom
+	private:
+		typedef struct SafeBoolStruct {
+			int a_data_pointer_to_this_is_0_on_buggy_compilers;
+			StaticFunctionPtr m_nonzero;
+		} UselessTypedef;
+		typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
+	public:
+		operator unspecified_bool_type() const {
+			return empty() ? 0 : &SafeBoolStruct::m_nonzero;
+		}
+		// necessary to allow ==0 to work despite the safe_bool idiom
+		inline bool operator==(StaticFunctionPtr funcptr) {
+			return m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator!=(StaticFunctionPtr funcptr) {
+			return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator ! () const {	// Is it bound to anything?
+			return !m_Closure;
+		}
+		inline bool empty() const {
+			return !m_Closure;
+		}
+		void clear() { m_Closure.clear(); }
+		// Conversion to and from the DelegateMemento storage class
+		const DelegateMemento & GetMemento() { return m_Closure; }
+		void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
+
+	private:	// Invoker for static functions
+		RetType InvokeStaticFunction() const {
+			return (*(m_Closure.GetStaticFunction()))();
+		}
+	};
+
+	//N=1
+	template<class Param1, class RetType = detail::DefaultVoid>
+	class FastDelegate1 {
+	private:
+		typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
+		typedef DesiredRetType(*StaticFunctionPtr)(Param1 p1);
+		typedef RetType(*UnvoidStaticFunctionPtr)(Param1 p1);
+		typedef RetType(detail::GenericClass::*GenericMemFn)(Param1 p1);
+		typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
+		ClosureType m_Closure;
+	public:
+		// Typedefs to aid generic programming
+		typedef FastDelegate1 type;
+
+		// Construction and comparison functions
+		FastDelegate1() { clear(); }
+		FastDelegate1(const FastDelegate1 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		void operator = (const FastDelegate1 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		bool operator ==(const FastDelegate1 &x) const {
+			return m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator !=(const FastDelegate1 &x) const {
+			return !m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator <(const FastDelegate1 &x) const {
+			return m_Closure.IsLess(x.m_Closure);
+		}
+		bool operator >(const FastDelegate1 &x) const {
+			return x.m_Closure.IsLess(m_Closure);
+		}
+		// Binding to non-const member functions
+		template < class X, class Y >
+		FastDelegate1(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		// Binding to const member functions.
+		template < class X, class Y >
+		FastDelegate1(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
+		}
+		// Static functions. We convert them into a member function call.
+		// This constructor also provides implicit conversion
+		FastDelegate1(DesiredRetType(*function_to_bind)(Param1 p1)) {
+			bind(function_to_bind);
+		}
+		// for efficiency, prevent creation of a temporary
+		void operator = (DesiredRetType(*function_to_bind)(Param1 p1)) {
+			bind(function_to_bind);
+		}
+		inline void bind(DesiredRetType(*function_to_bind)(Param1 p1)) {
+			m_Closure.bindstaticfunc(this, &FastDelegate1::InvokeStaticFunction,
+				function_to_bind);
+		}
+		// Invoke the delegate
+		RetType operator() (Param1 p1) const {
+			return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1);
+		}
+		// Implicit conversion to "bool" using the safe_bool idiom
+	private:
+		typedef struct SafeBoolStruct {
+			int a_data_pointer_to_this_is_0_on_buggy_compilers;
+			StaticFunctionPtr m_nonzero;
+		} UselessTypedef;
+		typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
+	public:
+		operator unspecified_bool_type() const {
+			return empty() ? 0 : &SafeBoolStruct::m_nonzero;
+		}
+		// necessary to allow ==0 to work despite the safe_bool idiom
+		inline bool operator==(StaticFunctionPtr funcptr) {
+			return m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator!=(StaticFunctionPtr funcptr) {
+			return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator ! () const {	// Is it bound to anything?
+			return !m_Closure;
+		}
+		inline bool empty() const {
+			return !m_Closure;
+		}
+		void clear() { m_Closure.clear(); }
+		// Conversion to and from the DelegateMemento storage class
+		const DelegateMemento & GetMemento() { return m_Closure; }
+		void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
+
+	private:	// Invoker for static functions
+		RetType InvokeStaticFunction(Param1 p1) const {
+			return (*(m_Closure.GetStaticFunction()))(p1);
+		}
+	};
+
+	//N=2
+	template<class Param1, class Param2, class RetType = detail::DefaultVoid>
+	class FastDelegate2 {
+	private:
+		typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
+		typedef DesiredRetType(*StaticFunctionPtr)(Param1 p1, Param2 p2);
+		typedef RetType(*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2);
+		typedef RetType(detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2);
+		typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
+		ClosureType m_Closure;
+	public:
+		// Typedefs to aid generic programming
+		typedef FastDelegate2 type;
+
+		// Construction and comparison functions
+		FastDelegate2() { clear(); }
+		FastDelegate2(const FastDelegate2 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		void operator = (const FastDelegate2 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		bool operator ==(const FastDelegate2 &x) const {
+			return m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator !=(const FastDelegate2 &x) const {
+			return !m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator <(const FastDelegate2 &x) const {
+			return m_Closure.IsLess(x.m_Closure);
+		}
+		bool operator >(const FastDelegate2 &x) const {
+			return x.m_Closure.IsLess(m_Closure);
+		}
+		// Binding to non-const member functions
+		template < class X, class Y >
+		FastDelegate2(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		// Binding to const member functions.
+		template < class X, class Y >
+		FastDelegate2(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
+		}
+		// Static functions. We convert them into a member function call.
+		// This constructor also provides implicit conversion
+		FastDelegate2(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2)) {
+			bind(function_to_bind);
+		}
+		// for efficiency, prevent creation of a temporary
+		void operator = (DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2)) {
+			bind(function_to_bind);
+		}
+		inline void bind(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2)) {
+			m_Closure.bindstaticfunc(this, &FastDelegate2::InvokeStaticFunction,
+				function_to_bind);
+		}
+		// Invoke the delegate
+		RetType operator() (Param1 p1, Param2 p2) const {
+			return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2);
+		}
+		// Implicit conversion to "bool" using the safe_bool idiom
+	private:
+		typedef struct SafeBoolStruct {
+			int a_data_pointer_to_this_is_0_on_buggy_compilers;
+			StaticFunctionPtr m_nonzero;
+		} UselessTypedef;
+		typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
+	public:
+		operator unspecified_bool_type() const {
+			return empty() ? 0 : &SafeBoolStruct::m_nonzero;
+		}
+		// necessary to allow ==0 to work despite the safe_bool idiom
+		inline bool operator==(StaticFunctionPtr funcptr) {
+			return m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator!=(StaticFunctionPtr funcptr) {
+			return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator ! () const {	// Is it bound to anything?
+			return !m_Closure;
+		}
+		inline bool empty() const {
+			return !m_Closure;
+		}
+		void clear() { m_Closure.clear(); }
+		// Conversion to and from the DelegateMemento storage class
+		const DelegateMemento & GetMemento() { return m_Closure; }
+		void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
+
+	private:	// Invoker for static functions
+		RetType InvokeStaticFunction(Param1 p1, Param2 p2) const {
+			return (*(m_Closure.GetStaticFunction()))(p1, p2);
+		}
+	};
+
+	//N=3
+	template<class Param1, class Param2, class Param3, class RetType = detail::DefaultVoid>
+	class FastDelegate3 {
+	private:
+		typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
+		typedef DesiredRetType(*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
+		typedef RetType(*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3);
+		typedef RetType(detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3);
+		typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
+		ClosureType m_Closure;
+	public:
+		// Typedefs to aid generic programming
+		typedef FastDelegate3 type;
+
+		// Construction and comparison functions
+		FastDelegate3() { clear(); }
+		FastDelegate3(const FastDelegate3 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		void operator = (const FastDelegate3 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		bool operator ==(const FastDelegate3 &x) const {
+			return m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator !=(const FastDelegate3 &x) const {
+			return !m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator <(const FastDelegate3 &x) const {
+			return m_Closure.IsLess(x.m_Closure);
+		}
+		bool operator >(const FastDelegate3 &x) const {
+			return x.m_Closure.IsLess(m_Closure);
+		}
+		// Binding to non-const member functions
+		template < class X, class Y >
+		FastDelegate3(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		// Binding to const member functions.
+		template < class X, class Y >
+		FastDelegate3(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
+		}
+		// Static functions. We convert them into a member function call.
+		// This constructor also provides implicit conversion
+		FastDelegate3(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
+			bind(function_to_bind);
+		}
+		// for efficiency, prevent creation of a temporary
+		void operator = (DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
+			bind(function_to_bind);
+		}
+		inline void bind(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3)) {
+			m_Closure.bindstaticfunc(this, &FastDelegate3::InvokeStaticFunction,
+				function_to_bind);
+		}
+		// Invoke the delegate
+		RetType operator() (Param1 p1, Param2 p2, Param3 p3) const {
+			return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3);
+		}
+		// Implicit conversion to "bool" using the safe_bool idiom
+	private:
+		typedef struct SafeBoolStruct {
+			int a_data_pointer_to_this_is_0_on_buggy_compilers;
+			StaticFunctionPtr m_nonzero;
+		} UselessTypedef;
+		typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
+	public:
+		operator unspecified_bool_type() const {
+			return empty() ? 0 : &SafeBoolStruct::m_nonzero;
+		}
+		// necessary to allow ==0 to work despite the safe_bool idiom
+		inline bool operator==(StaticFunctionPtr funcptr) {
+			return m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator!=(StaticFunctionPtr funcptr) {
+			return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator ! () const {	// Is it bound to anything?
+			return !m_Closure;
+		}
+		inline bool empty() const {
+			return !m_Closure;
+		}
+		void clear() { m_Closure.clear(); }
+		// Conversion to and from the DelegateMemento storage class
+		const DelegateMemento & GetMemento() { return m_Closure; }
+		void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
+
+	private:	// Invoker for static functions
+		RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3) const {
+			return (*(m_Closure.GetStaticFunction()))(p1, p2, p3);
+		}
+	};
+
+	//N=4
+	template<class Param1, class Param2, class Param3, class Param4, class RetType = detail::DefaultVoid>
+	class FastDelegate4 {
+	private:
+		typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
+		typedef DesiredRetType(*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
+		typedef RetType(*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
+		typedef RetType(detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4);
+		typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
+		ClosureType m_Closure;
+	public:
+		// Typedefs to aid generic programming
+		typedef FastDelegate4 type;
+
+		// Construction and comparison functions
+		FastDelegate4() { clear(); }
+		FastDelegate4(const FastDelegate4 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		void operator = (const FastDelegate4 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		bool operator ==(const FastDelegate4 &x) const {
+			return m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator !=(const FastDelegate4 &x) const {
+			return !m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator <(const FastDelegate4 &x) const {
+			return m_Closure.IsLess(x.m_Closure);
+		}
+		bool operator >(const FastDelegate4 &x) const {
+			return x.m_Closure.IsLess(m_Closure);
+		}
+		// Binding to non-const member functions
+		template < class X, class Y >
+		FastDelegate4(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		// Binding to const member functions.
+		template < class X, class Y >
+		FastDelegate4(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
+		}
+		// Static functions. We convert them into a member function call.
+		// This constructor also provides implicit conversion
+		FastDelegate4(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
+			bind(function_to_bind);
+		}
+		// for efficiency, prevent creation of a temporary
+		void operator = (DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
+			bind(function_to_bind);
+		}
+		inline void bind(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
+			m_Closure.bindstaticfunc(this, &FastDelegate4::InvokeStaticFunction,
+				function_to_bind);
+		}
+		// Invoke the delegate
+		RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4) const {
+			return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4);
+		}
+		// Implicit conversion to "bool" using the safe_bool idiom
+	private:
+		typedef struct SafeBoolStruct {
+			int a_data_pointer_to_this_is_0_on_buggy_compilers;
+			StaticFunctionPtr m_nonzero;
+		} UselessTypedef;
+		typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
+	public:
+		operator unspecified_bool_type() const {
+			return empty() ? 0 : &SafeBoolStruct::m_nonzero;
+		}
+		// necessary to allow ==0 to work despite the safe_bool idiom
+		inline bool operator==(StaticFunctionPtr funcptr) {
+			return m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator!=(StaticFunctionPtr funcptr) {
+			return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator ! () const {	// Is it bound to anything?
+			return !m_Closure;
+		}
+		inline bool empty() const {
+			return !m_Closure;
+		}
+		void clear() { m_Closure.clear(); }
+		// Conversion to and from the DelegateMemento storage class
+		const DelegateMemento & GetMemento() { return m_Closure; }
+		void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
+
+	private:	// Invoker for static functions
+		RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const {
+			return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4);
+		}
+	};
+
+	//N=5
+	template<class Param1, class Param2, class Param3, class Param4, class Param5, class RetType = detail::DefaultVoid>
+	class FastDelegate5 {
+	private:
+		typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
+		typedef DesiredRetType(*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
+		typedef RetType(*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
+		typedef RetType(detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5);
+		typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
+		ClosureType m_Closure;
+	public:
+		// Typedefs to aid generic programming
+		typedef FastDelegate5 type;
+
+		// Construction and comparison functions
+		FastDelegate5() { clear(); }
+		FastDelegate5(const FastDelegate5 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		void operator = (const FastDelegate5 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		bool operator ==(const FastDelegate5 &x) const {
+			return m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator !=(const FastDelegate5 &x) const {
+			return !m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator <(const FastDelegate5 &x) const {
+			return m_Closure.IsLess(x.m_Closure);
+		}
+		bool operator >(const FastDelegate5 &x) const {
+			return x.m_Closure.IsLess(m_Closure);
+		}
+		// Binding to non-const member functions
+		template < class X, class Y >
+		FastDelegate5(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		// Binding to const member functions.
+		template < class X, class Y >
+		FastDelegate5(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
+		}
+		// Static functions. We convert them into a member function call.
+		// This constructor also provides implicit conversion
+		FastDelegate5(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
+			bind(function_to_bind);
+		}
+		// for efficiency, prevent creation of a temporary
+		void operator = (DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
+			bind(function_to_bind);
+		}
+		inline void bind(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
+			m_Closure.bindstaticfunc(this, &FastDelegate5::InvokeStaticFunction,
+				function_to_bind);
+		}
+		// Invoke the delegate
+		RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const {
+			return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5);
+		}
+		// Implicit conversion to "bool" using the safe_bool idiom
+	private:
+		typedef struct SafeBoolStruct {
+			int a_data_pointer_to_this_is_0_on_buggy_compilers;
+			StaticFunctionPtr m_nonzero;
+		} UselessTypedef;
+		typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
+	public:
+		operator unspecified_bool_type() const {
+			return empty() ? 0 : &SafeBoolStruct::m_nonzero;
+		}
+		// necessary to allow ==0 to work despite the safe_bool idiom
+		inline bool operator==(StaticFunctionPtr funcptr) {
+			return m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator!=(StaticFunctionPtr funcptr) {
+			return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator ! () const {	// Is it bound to anything?
+			return !m_Closure;
+		}
+		inline bool empty() const {
+			return !m_Closure;
+		}
+		void clear() { m_Closure.clear(); }
+		// Conversion to and from the DelegateMemento storage class
+		const DelegateMemento & GetMemento() { return m_Closure; }
+		void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
+
+	private:	// Invoker for static functions
+		RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const {
+			return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5);
+		}
+	};
+
+	//N=6
+	template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType = detail::DefaultVoid>
+	class FastDelegate6 {
+	private:
+		typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
+		typedef DesiredRetType(*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
+		typedef RetType(*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
+		typedef RetType(detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6);
+		typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
+		ClosureType m_Closure;
+	public:
+		// Typedefs to aid generic programming
+		typedef FastDelegate6 type;
+
+		// Construction and comparison functions
+		FastDelegate6() { clear(); }
+		FastDelegate6(const FastDelegate6 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		void operator = (const FastDelegate6 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		bool operator ==(const FastDelegate6 &x) const {
+			return m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator !=(const FastDelegate6 &x) const {
+			return !m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator <(const FastDelegate6 &x) const {
+			return m_Closure.IsLess(x.m_Closure);
+		}
+		bool operator >(const FastDelegate6 &x) const {
+			return x.m_Closure.IsLess(m_Closure);
+		}
+		// Binding to non-const member functions
+		template < class X, class Y >
+		FastDelegate6(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		// Binding to const member functions.
+		template < class X, class Y >
+		FastDelegate6(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
+		}
+		// Static functions. We convert them into a member function call.
+		// This constructor also provides implicit conversion
+		FastDelegate6(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
+			bind(function_to_bind);
+		}
+		// for efficiency, prevent creation of a temporary
+		void operator = (DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
+			bind(function_to_bind);
+		}
+		inline void bind(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
+			m_Closure.bindstaticfunc(this, &FastDelegate6::InvokeStaticFunction,
+				function_to_bind);
+		}
+		// Invoke the delegate
+		RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const {
+			return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6);
+		}
+		// Implicit conversion to "bool" using the safe_bool idiom
+	private:
+		typedef struct SafeBoolStruct {
+			int a_data_pointer_to_this_is_0_on_buggy_compilers;
+			StaticFunctionPtr m_nonzero;
+		} UselessTypedef;
+		typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
+	public:
+		operator unspecified_bool_type() const {
+			return empty() ? 0 : &SafeBoolStruct::m_nonzero;
+		}
+		// necessary to allow ==0 to work despite the safe_bool idiom
+		inline bool operator==(StaticFunctionPtr funcptr) {
+			return m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator!=(StaticFunctionPtr funcptr) {
+			return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator ! () const {	// Is it bound to anything?
+			return !m_Closure;
+		}
+		inline bool empty() const {
+			return !m_Closure;
+		}
+		void clear() { m_Closure.clear(); }
+		// Conversion to and from the DelegateMemento storage class
+		const DelegateMemento & GetMemento() { return m_Closure; }
+		void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
+
+	private:	// Invoker for static functions
+		RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const {
+			return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6);
+		}
+	};
+
+	//N=7
+	template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType = detail::DefaultVoid>
+	class FastDelegate7 {
+	private:
+		typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
+		typedef DesiredRetType(*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
+		typedef RetType(*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
+		typedef RetType(detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7);
+		typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
+		ClosureType m_Closure;
+	public:
+		// Typedefs to aid generic programming
+		typedef FastDelegate7 type;
+
+		// Construction and comparison functions
+		FastDelegate7() { clear(); }
+		FastDelegate7(const FastDelegate7 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		void operator = (const FastDelegate7 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		bool operator ==(const FastDelegate7 &x) const {
+			return m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator !=(const FastDelegate7 &x) const {
+			return !m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator <(const FastDelegate7 &x) const {
+			return m_Closure.IsLess(x.m_Closure);
+		}
+		bool operator >(const FastDelegate7 &x) const {
+			return x.m_Closure.IsLess(m_Closure);
+		}
+		// Binding to non-const member functions
+		template < class X, class Y >
+		FastDelegate7(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		// Binding to const member functions.
+		template < class X, class Y >
+		FastDelegate7(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
+		}
+		// Static functions. We convert them into a member function call.
+		// This constructor also provides implicit conversion
+		FastDelegate7(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
+			bind(function_to_bind);
+		}
+		// for efficiency, prevent creation of a temporary
+		void operator = (DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
+			bind(function_to_bind);
+		}
+		inline void bind(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
+			m_Closure.bindstaticfunc(this, &FastDelegate7::InvokeStaticFunction,
+				function_to_bind);
+		}
+		// Invoke the delegate
+		RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const {
+			return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7);
+		}
+		// Implicit conversion to "bool" using the safe_bool idiom
+	private:
+		typedef struct SafeBoolStruct {
+			int a_data_pointer_to_this_is_0_on_buggy_compilers;
+			StaticFunctionPtr m_nonzero;
+		} UselessTypedef;
+		typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
+	public:
+		operator unspecified_bool_type() const {
+			return empty() ? 0 : &SafeBoolStruct::m_nonzero;
+		}
+		// necessary to allow ==0 to work despite the safe_bool idiom
+		inline bool operator==(StaticFunctionPtr funcptr) {
+			return m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator!=(StaticFunctionPtr funcptr) {
+			return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator ! () const {	// Is it bound to anything?
+			return !m_Closure;
+		}
+		inline bool empty() const {
+			return !m_Closure;
+		}
+		void clear() { m_Closure.clear(); }
+		// Conversion to and from the DelegateMemento storage class
+		const DelegateMemento & GetMemento() { return m_Closure; }
+		void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
+
+	private:	// Invoker for static functions
+		RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const {
+			return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7);
+		}
+	};
+
+	//N=8
+	template<class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType = detail::DefaultVoid>
+	class FastDelegate8 {
+	private:
+		typedef typename detail::DefaultVoidToVoid<RetType>::type DesiredRetType;
+		typedef DesiredRetType(*StaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
+		typedef RetType(*UnvoidStaticFunctionPtr)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
+		typedef RetType(detail::GenericClass::*GenericMemFn)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8);
+		typedef detail::ClosurePtr<GenericMemFn, StaticFunctionPtr, UnvoidStaticFunctionPtr> ClosureType;
+		ClosureType m_Closure;
+	public:
+		// Typedefs to aid generic programming
+		typedef FastDelegate8 type;
+
+		// Construction and comparison functions
+		FastDelegate8() { clear(); }
+		FastDelegate8(const FastDelegate8 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		void operator = (const FastDelegate8 &x) {
+			m_Closure.CopyFrom(this, x.m_Closure);
+		}
+		bool operator ==(const FastDelegate8 &x) const {
+			return m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator !=(const FastDelegate8 &x) const {
+			return !m_Closure.IsEqual(x.m_Closure);
+		}
+		bool operator <(const FastDelegate8 &x) const {
+			return m_Closure.IsLess(x.m_Closure);
+		}
+		bool operator >(const FastDelegate8 &x) const {
+			return x.m_Closure.IsLess(m_Closure);
+		}
+		// Binding to non-const member functions
+		template < class X, class Y >
+		FastDelegate8(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
+			m_Closure.bindmemfunc(detail::implicit_cast<X*>(pthis), function_to_bind);
+		}
+		// Binding to const member functions.
+		template < class X, class Y >
+		FastDelegate8(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X*>(pthis), function_to_bind);
+		}
+		template < class X, class Y >
+		inline void bind(const Y *pthis, DesiredRetType(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {
+			m_Closure.bindconstmemfunc(detail::implicit_cast<const X *>(pthis), function_to_bind);
+		}
+		// Static functions. We convert them into a member function call.
+		// This constructor also provides implicit conversion
+		FastDelegate8(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
+			bind(function_to_bind);
+		}
+		// for efficiency, prevent creation of a temporary
+		void operator = (DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
+			bind(function_to_bind);
+		}
+		inline void bind(DesiredRetType(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
+			m_Closure.bindstaticfunc(this, &FastDelegate8::InvokeStaticFunction,
+				function_to_bind);
+		}
+		// Invoke the delegate
+		RetType operator() (Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const {
+			return (m_Closure.GetClosureThis()->*(m_Closure.GetClosureMemPtr()))(p1, p2, p3, p4, p5, p6, p7, p8);
+		}
+		// Implicit conversion to "bool" using the safe_bool idiom
+	private:
+		typedef struct SafeBoolStruct {
+			int a_data_pointer_to_this_is_0_on_buggy_compilers;
+			StaticFunctionPtr m_nonzero;
+		} UselessTypedef;
+		typedef StaticFunctionPtr SafeBoolStruct::*unspecified_bool_type;
+	public:
+		operator unspecified_bool_type() const {
+			return empty() ? 0 : &SafeBoolStruct::m_nonzero;
+		}
+		// necessary to allow ==0 to work despite the safe_bool idiom
+		inline bool operator==(StaticFunctionPtr funcptr) {
+			return m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator!=(StaticFunctionPtr funcptr) {
+			return !m_Closure.IsEqualToStaticFuncPtr(funcptr);
+		}
+		inline bool operator ! () const {	// Is it bound to anything?
+			return !m_Closure;
+		}
+		inline bool empty() const {
+			return !m_Closure;
+		}
+		void clear() { m_Closure.clear(); }
+		// Conversion to and from the DelegateMemento storage class
+		const DelegateMemento & GetMemento() { return m_Closure; }
+		void SetMemento(const DelegateMemento &any) { m_Closure.CopyFrom(this, any); }
+
+	private:	// Invoker for static functions
+		RetType InvokeStaticFunction(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const {
+			return (*(m_Closure.GetStaticFunction()))(p1, p2, p3, p4, p5, p6, p7, p8);
+		}
+	};
+
+
+	////////////////////////////////////////////////////////////////////////////////
+	//						Fast Delegates, part 4:
+	//
+	//				FastDelegate<> class (Original author: Jody Hagins)
+	//	Allows boost::function style syntax like:
+	//			FastDelegate< double (int, long) >
+	// instead of:
+	//			FastDelegate2< int, long, double >
+	//
+	////////////////////////////////////////////////////////////////////////////////
+
+#ifdef FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
+
+	// Declare FastDelegate as a class template.  It will be specialized
+	// later for all number of arguments.
+	template <typename Signature>
+	class FastDelegate;
+
+	//N=0
+	// Specialization to allow use of
+	// FastDelegate< R (  ) >
+	// instead of
+	// FastDelegate0 < R >
+	template<typename R>
+	class FastDelegate< R() >
+		// Inherit from FastDelegate0 so that it can be treated just like a FastDelegate0
+		: public FastDelegate0 < R >
+	{
+	public:
+		// Make using the base type a bit easier via typedef.
+		typedef FastDelegate0 < R > BaseType;
+
+		// Allow users access to the specific type of this delegate.
+		typedef FastDelegate SelfType;
+
+		// Mimic the base class constructors.
+		FastDelegate() : BaseType() { }
+
+		template < class X, class Y >
+		FastDelegate(Y * pthis,
+			R(X::* function_to_bind)())
+			: BaseType(pthis, function_to_bind) { }
+
+		template < class X, class Y >
+		FastDelegate(const Y *pthis,
+			R(X::* function_to_bind)() const)
+			: BaseType(pthis, function_to_bind)
+		{  }
+
+		FastDelegate(R(*function_to_bind)())
+			: BaseType(function_to_bind) { }
+		void operator = (const BaseType &x) {
+			*static_cast<BaseType*>(this) = x;
+		}
+	};
+
+	//N=1
+	// Specialization to allow use of
+	// FastDelegate< R ( Param1 ) >
+	// instead of
+	// FastDelegate1 < Param1, R >
+	template<typename R, class Param1>
+	class FastDelegate< R(Param1) >
+		// Inherit from FastDelegate1 so that it can be treated just like a FastDelegate1
+		: public FastDelegate1 < Param1, R >
+	{
+	public:
+		// Make using the base type a bit easier via typedef.
+		typedef FastDelegate1 < Param1, R > BaseType;
+
+		// Allow users access to the specific type of this delegate.
+		typedef FastDelegate SelfType;
+
+		// Mimic the base class constructors.
+		FastDelegate() : BaseType() { }
+
+		template < class X, class Y >
+		FastDelegate(Y * pthis,
+			R(X::* function_to_bind)(Param1 p1))
+			: BaseType(pthis, function_to_bind) { }
+
+		template < class X, class Y >
+		FastDelegate(const Y *pthis,
+			R(X::* function_to_bind)(Param1 p1) const)
+			: BaseType(pthis, function_to_bind)
+		{  }
+
+		FastDelegate(R(*function_to_bind)(Param1 p1))
+			: BaseType(function_to_bind) { }
+		void operator = (const BaseType &x) {
+			*static_cast<BaseType*>(this) = x;
+		}
+	};
+
+	//N=2
+	// Specialization to allow use of
+	// FastDelegate< R ( Param1, Param2 ) >
+	// instead of
+	// FastDelegate2 < Param1, Param2, R >
+	template<typename R, class Param1, class Param2>
+	class FastDelegate< R(Param1, Param2) >
+		// Inherit from FastDelegate2 so that it can be treated just like a FastDelegate2
+		: public FastDelegate2 < Param1, Param2, R >
+	{
+	public:
+		// Make using the base type a bit easier via typedef.
+		typedef FastDelegate2 < Param1, Param2, R > BaseType;
+
+		// Allow users access to the specific type of this delegate.
+		typedef FastDelegate SelfType;
+
+		// Mimic the base class constructors.
+		FastDelegate() : BaseType() { }
+
+		template < class X, class Y >
+		FastDelegate(Y * pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2))
+			: BaseType(pthis, function_to_bind) { }
+
+		template < class X, class Y >
+		FastDelegate(const Y *pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2) const)
+			: BaseType(pthis, function_to_bind)
+		{  }
+
+		FastDelegate(R(*function_to_bind)(Param1 p1, Param2 p2))
+			: BaseType(function_to_bind) { }
+		void operator = (const BaseType &x) {
+			*static_cast<BaseType*>(this) = x;
+		}
+	};
+
+	//N=3
+	// Specialization to allow use of
+	// FastDelegate< R ( Param1, Param2, Param3 ) >
+	// instead of
+	// FastDelegate3 < Param1, Param2, Param3, R >
+	template<typename R, class Param1, class Param2, class Param3>
+	class FastDelegate< R(Param1, Param2, Param3) >
+		// Inherit from FastDelegate3 so that it can be treated just like a FastDelegate3
+		: public FastDelegate3 < Param1, Param2, Param3, R >
+	{
+	public:
+		// Make using the base type a bit easier via typedef.
+		typedef FastDelegate3 < Param1, Param2, Param3, R > BaseType;
+
+		// Allow users access to the specific type of this delegate.
+		typedef FastDelegate SelfType;
+
+		// Mimic the base class constructors.
+		FastDelegate() : BaseType() { }
+
+		template < class X, class Y >
+		FastDelegate(Y * pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3))
+			: BaseType(pthis, function_to_bind) { }
+
+		template < class X, class Y >
+		FastDelegate(const Y *pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3) const)
+			: BaseType(pthis, function_to_bind)
+		{  }
+
+		FastDelegate(R(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3))
+			: BaseType(function_to_bind) { }
+		void operator = (const BaseType &x) {
+			*static_cast<BaseType*>(this) = x;
+		}
+	};
+
+	//N=4
+	// Specialization to allow use of
+	// FastDelegate< R ( Param1, Param2, Param3, Param4 ) >
+	// instead of
+	// FastDelegate4 < Param1, Param2, Param3, Param4, R >
+	template<typename R, class Param1, class Param2, class Param3, class Param4>
+	class FastDelegate< R(Param1, Param2, Param3, Param4) >
+		// Inherit from FastDelegate4 so that it can be treated just like a FastDelegate4
+		: public FastDelegate4 < Param1, Param2, Param3, Param4, R >
+	{
+	public:
+		// Make using the base type a bit easier via typedef.
+		typedef FastDelegate4 < Param1, Param2, Param3, Param4, R > BaseType;
+
+		// Allow users access to the specific type of this delegate.
+		typedef FastDelegate SelfType;
+
+		// Mimic the base class constructors.
+		FastDelegate() : BaseType() { }
+
+		template < class X, class Y >
+		FastDelegate(Y * pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
+			: BaseType(pthis, function_to_bind) { }
+
+		template < class X, class Y >
+		FastDelegate(const Y *pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const)
+			: BaseType(pthis, function_to_bind)
+		{  }
+
+		FastDelegate(R(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4))
+			: BaseType(function_to_bind) { }
+		void operator = (const BaseType &x) {
+			*static_cast<BaseType*>(this) = x;
+		}
+	};
+
+	//N=5
+	// Specialization to allow use of
+	// FastDelegate< R ( Param1, Param2, Param3, Param4, Param5 ) >
+	// instead of
+	// FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R >
+	template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5>
+	class FastDelegate< R(Param1, Param2, Param3, Param4, Param5) >
+		// Inherit from FastDelegate5 so that it can be treated just like a FastDelegate5
+		: public FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R >
+	{
+	public:
+		// Make using the base type a bit easier via typedef.
+		typedef FastDelegate5 < Param1, Param2, Param3, Param4, Param5, R > BaseType;
+
+		// Allow users access to the specific type of this delegate.
+		typedef FastDelegate SelfType;
+
+		// Mimic the base class constructors.
+		FastDelegate() : BaseType() { }
+
+		template < class X, class Y >
+		FastDelegate(Y * pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
+			: BaseType(pthis, function_to_bind) { }
+
+		template < class X, class Y >
+		FastDelegate(const Y *pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const)
+			: BaseType(pthis, function_to_bind)
+		{  }
+
+		FastDelegate(R(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5))
+			: BaseType(function_to_bind) { }
+		void operator = (const BaseType &x) {
+			*static_cast<BaseType*>(this) = x;
+		}
+	};
+
+	//N=6
+	// Specialization to allow use of
+	// FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6 ) >
+	// instead of
+	// FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R >
+	template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6>
+	class FastDelegate< R(Param1, Param2, Param3, Param4, Param5, Param6) >
+		// Inherit from FastDelegate6 so that it can be treated just like a FastDelegate6
+		: public FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R >
+	{
+	public:
+		// Make using the base type a bit easier via typedef.
+		typedef FastDelegate6 < Param1, Param2, Param3, Param4, Param5, Param6, R > BaseType;
+
+		// Allow users access to the specific type of this delegate.
+		typedef FastDelegate SelfType;
+
+		// Mimic the base class constructors.
+		FastDelegate() : BaseType() { }
+
+		template < class X, class Y >
+		FastDelegate(Y * pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
+			: BaseType(pthis, function_to_bind) { }
+
+		template < class X, class Y >
+		FastDelegate(const Y *pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const)
+			: BaseType(pthis, function_to_bind)
+		{  }
+
+		FastDelegate(R(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6))
+			: BaseType(function_to_bind) { }
+		void operator = (const BaseType &x) {
+			*static_cast<BaseType*>(this) = x;
+		}
+	};
+
+	//N=7
+	// Specialization to allow use of
+	// FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7 ) >
+	// instead of
+	// FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R >
+	template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7>
+	class FastDelegate< R(Param1, Param2, Param3, Param4, Param5, Param6, Param7) >
+		// Inherit from FastDelegate7 so that it can be treated just like a FastDelegate7
+		: public FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R >
+	{
+	public:
+		// Make using the base type a bit easier via typedef.
+		typedef FastDelegate7 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, R > BaseType;
+
+		// Allow users access to the specific type of this delegate.
+		typedef FastDelegate SelfType;
+
+		// Mimic the base class constructors.
+		FastDelegate() : BaseType() { }
+
+		template < class X, class Y >
+		FastDelegate(Y * pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
+			: BaseType(pthis, function_to_bind) { }
+
+		template < class X, class Y >
+		FastDelegate(const Y *pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const)
+			: BaseType(pthis, function_to_bind)
+		{  }
+
+		FastDelegate(R(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7))
+			: BaseType(function_to_bind) { }
+		void operator = (const BaseType &x) {
+			*static_cast<BaseType*>(this) = x;
+		}
+	};
+
+	//N=8
+	// Specialization to allow use of
+	// FastDelegate< R ( Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8 ) >
+	// instead of
+	// FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R >
+	template<typename R, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8>
+	class FastDelegate< R(Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8) >
+		// Inherit from FastDelegate8 so that it can be treated just like a FastDelegate8
+		: public FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R >
+	{
+	public:
+		// Make using the base type a bit easier via typedef.
+		typedef FastDelegate8 < Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, R > BaseType;
+
+		// Allow users access to the specific type of this delegate.
+		typedef FastDelegate SelfType;
+
+		// Mimic the base class constructors.
+		FastDelegate() : BaseType() { }
+
+		template < class X, class Y >
+		FastDelegate(Y * pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
+			: BaseType(pthis, function_to_bind) { }
+
+		template < class X, class Y >
+		FastDelegate(const Y *pthis,
+			R(X::* function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const)
+			: BaseType(pthis, function_to_bind)
+		{  }
+
+		FastDelegate(R(*function_to_bind)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8))
+			: BaseType(function_to_bind) { }
+		void operator = (const BaseType &x) {
+			*static_cast<BaseType*>(this) = x;
+		}
+	};
+
+
+#endif //FASTDELEGATE_ALLOW_FUNCTION_TYPE_SYNTAX
+
+	////////////////////////////////////////////////////////////////////////////////
+	//						Fast Delegates, part 5:
+	//
+	//				MakeDelegate() helper function
+	//
+	//			MakeDelegate(&x, &X::func) returns a fastdelegate of the type
+	//			necessary for calling x.func() with the correct number of arguments.
+	//			This makes it possible to eliminate many typedefs from user code.
+	//
+	////////////////////////////////////////////////////////////////////////////////
+
+	// Also declare overloads of a MakeDelegate() global function to
+	// reduce the need for typedefs.
+	// We need seperate overloads for const and non-const member functions.
+	// Also, because of the weird rule about the class of derived member function pointers,
+	// implicit downcasts may need to be applied later to the 'this' pointer.
+	// That's why two classes (X and Y) appear in the definitions. Y must be implicitly
+	// castable to X.
+
+	// Workaround for VC6. VC6 needs void return types converted into DefaultVoid.
+	// GCC 3.2 and later won't compile this unless it's preceded by 'typename',
+	// but VC6 doesn't allow 'typename' in this context.
+	// So, I have to use a macro.
+
+#ifdef FASTDLGT_VC6
+#define FASTDLGT_RETTYPE detail::VoidToDefaultVoid<RetType>::type
+#else
+#define FASTDLGT_RETTYPE RetType
+#endif
+
+	//N=0
+	template <class X, class Y, class RetType>
+	FastDelegate0<FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)()) {
+		return FastDelegate0<FASTDLGT_RETTYPE>(x, func);
+	}
+
+	template <class X, class Y, class RetType>
+	FastDelegate0<FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)() const) {
+		return FastDelegate0<FASTDLGT_RETTYPE>(x, func);
+	}
+
+	//N=1
+	template <class X, class Y, class Param1, class RetType>
+	FastDelegate1<Param1, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1)) {
+		return FastDelegate1<Param1, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	template <class X, class Y, class Param1, class RetType>
+	FastDelegate1<Param1, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1) const) {
+		return FastDelegate1<Param1, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	//N=2
+	template <class X, class Y, class Param1, class Param2, class RetType>
+	FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2)) {
+		return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	template <class X, class Y, class Param1, class Param2, class RetType>
+	FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2) const) {
+		return FastDelegate2<Param1, Param2, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	//N=3
+	template <class X, class Y, class Param1, class Param2, class Param3, class RetType>
+	FastDelegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3)) {
+		return FastDelegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	template <class X, class Y, class Param1, class Param2, class Param3, class RetType>
+	FastDelegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3) const) {
+		return FastDelegate3<Param1, Param2, Param3, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	//N=4
+	template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType>
+	FastDelegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4)) {
+		return FastDelegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class RetType>
+	FastDelegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4) const) {
+		return FastDelegate4<Param1, Param2, Param3, Param4, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	//N=5
+	template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>
+	FastDelegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5)) {
+		return FastDelegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class RetType>
+	FastDelegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5) const) {
+		return FastDelegate5<Param1, Param2, Param3, Param4, Param5, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	//N=6
+	template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>
+	FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6)) {
+		return FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class RetType>
+	FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6) const) {
+		return FastDelegate6<Param1, Param2, Param3, Param4, Param5, Param6, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	//N=7
+	template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>
+	FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7)) {
+		return FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class RetType>
+	FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7) const) {
+		return FastDelegate7<Param1, Param2, Param3, Param4, Param5, Param6, Param7, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	//N=8
+	template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>
+	FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8)) {
+		return FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE>(x, func);
+	}
+
+	template <class X, class Y, class Param1, class Param2, class Param3, class Param4, class Param5, class Param6, class Param7, class Param8, class RetType>
+	FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE> MakeDelegate(Y* x, RetType(X::*func)(Param1 p1, Param2 p2, Param3 p3, Param4 p4, Param5 p5, Param6 p6, Param7 p7, Param8 p8) const) {
+		return FastDelegate8<Param1, Param2, Param3, Param4, Param5, Param6, Param7, Param8, FASTDLGT_RETTYPE>(x, func);
+	}
+
+
+	// clean up after ourselves...
+#undef FASTDLGT_RETTYPE
+
+} // namespace fastdelegate
+
+#endif // !defined(FASTDELEGATE_H)
\ No newline at end of file
diff -ruwN ./output.cpp ../../trebron106/SIGNALEsp-20170510/output.cpp
--- ./output.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/output.cpp	2017-05-01 08:54:58.000000000 +0200
@@ -0,0 +1,7 @@
+// 
+// 
+// 
+
+#include "output.h"
+
+
diff -ruwN ./output.h ../../trebron106/SIGNALEsp-20170510/output.h
--- ./output.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/output.h	2017-05-05 10:23:34.000000000 +0200
@@ -0,0 +1,45 @@
+// output.h
+
+#define ETHERNET_PRINT
+
+#define digitalLow(P) digitalWrite(P,LOW)
+#define digitalHigh(P) digitalWrite(P,HIGH)
+#define isHigh(P) (digitalRead(P) == HIGH)
+#define isLow(P) (digitalRead(P) == LOW)
+#define digitalState(P)((uint8_t)isHigh(P))
+
+#ifndef _OUTPUT_h
+ #define _OUTPUT_h
+
+#if defined(ARDUINO) && ARDUINO >= 100
+	#include "Arduino.h"
+#else
+	#include "WProgram.h"
+#endif
+
+#ifdef ETHERNET_PRINT
+ #include <WiFiClient.h>
+ extern WiFiClient serverClient;
+ #define MSG_PRINTER serverClient // Not Implemented at this time
+#else
+ #define MSG_PRINTER Serial
+#endif
+
+#ifdef ETHERNET_DEBUG
+ #define DBG_PRINTER Client // Not Implemented at this time
+#else
+ #define DBG_PRINTER Serial
+#endif
+
+#define MSG_PRINT(...) { MSG_PRINTER.print(__VA_ARGS__); }
+#define MSG_PRINTLN(...) { MSG_PRINTER.println(__VA_ARGS__); }
+
+#ifdef DEBUG
+  #define DBG_PRINT(...) { DBG_PRINTER.print(__VA_ARGS__); }
+  #define DBG_PRINTLN(...) { DBG_PRINTER.println(__VA_ARGS__); }
+#else
+  #define DBG_PRINT(...) 
+  #define DBG_PRINTLN(...) 
+#endif
+
+#endif
diff -ruwN ./signalDecoder.cpp ../../trebron106/SIGNALEsp-20170510/signalDecoder.cpp
--- ./signalDecoder.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/signalDecoder.cpp	2017-05-02 16:47:06.000000000 +0200
@@ -0,0 +1,1426 @@
+/*
+*   Pattern Decoder Library V3
+*   Library to decode radio signals based on patternd detection
+*   2014-2015  N.Butzek, S.Butzek
+*   2015  S.Butzek
+*	2016  S.Butzek
+
+*   This library contains classes to perform decoding of digital signals
+*   typical for home automation. The focus for the moment is on different sensors
+*   like weather sensors (temperature, humidity Logilink, TCM, Oregon Scientific, ...),
+*   remote controlled power switches (Intertechno, TCM, ARCtech, ...) which use
+*   encoder chips like PT2262 and EV1527-type and manchester encoder to send
+*   information in the 433MHz or 868 Mhz Band.
+*
+*   The classes in this library follow the approach to detect a recurring pattern in the
+*   recived signal. For Manchester there is a class which decodes the signal.
+*
+*   This program is free software: you can redistribute it and/or modify
+*   it under the terms of the GNU General Public License as published by
+*   the Free Software Foundation, either version 3 of the License, or
+*   (at your option) any later version.
+*
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU General Public License
+*   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+#include "signalDecoder.h"
+
+
+void SignalDetectorClass::bufferMove(const uint8_t start)
+{
+	DBG_PRINT(" ");
+	if (start > messageLen - 1 || start == 0) {
+		DBG_PRINT(__FUNCTION__); DBG_PRINT(" start oor "); 	DBG_PRINT(start);
+	}
+	else if (start<=maxMsgSize)
+	{
+		DBG_PRINT(__FUNCTION__); DBG_PRINT(" -> "); 	DBG_PRINT(start);
+
+		static uint8_t len_single_entry = sizeof(*message);
+		messageLen = messageLen - start; // Berechnung der neuen Nachrichtenlaenge nach dem Loeschen
+		memmove(message, message + start, len_single_entry*messageLen);
+	}
+	else {
+		DBG_PRINT(__FUNCTION__); DBG_PRINT(" unsup "); 	DBG_PRINT(start);
+		printOut();
+	}
+}
+
+
+inline void SignalDetectorClass::addData(const uint8_t value)
+{
+	if (messageLen >= 254)
+	{
+		DBG_PRINT(__FUNCTION__); DBG_PRINT(" msglen: "); DBG_PRINT(messageLen);
+	}
+	message[messageLen] = value;
+	messageLen++;
+}
+
+inline void SignalDetectorClass::addPattern()
+{
+	pattern[pattern_pos] = *first;						//Store pulse in pattern array
+	pattern_pos++;
+}
+
+inline void SignalDetectorClass::updPattern( const uint8_t ppos)
+{
+	pattern[ppos] = (long(pattern[ppos]) + *first) / 2; // Moving average
+}
+
+
+inline void SignalDetectorClass::doDetect()
+{
+		 
+		bool valid=true;
+		valid = (messageLen==0 || (*first ^ *last) < 0); // true if a and b have opposite signs
+		valid &=  (messageLen == maxMsgSize) ? false : true;
+		valid &= (*first > -maxPulse);
+
+//		if (messageLen == 0) pattern_pos = patternLen = 0;
+		//if (messageLen == 0) valid = true;
+
+
+		if (!valid)
+		{
+			// Try output
+			
+			m_overflow = (messageLen == maxMsgSize) ? true : false;
+			processMessage();
+			if (!success) reset();
+		}	else if (messageLen == minMessageLen) {
+			state = detecting;  // Set state to detecting, because we have more than minMessageLen data gathered, so this is no noise
+ 
+     #ifdef CMP_CC1101
+	    rssiValue= _rssiCallback();
+     #else
+      rssiValue=0;
+     #endif
+     
+		}
+
+		int8_t fidx = findpatt(*first);
+		if (fidx >= 0) {
+			// Upd pattern
+
+			updPattern(fidx);
+		}
+		else { 			
+
+			// Add pattern
+			if (patternLen == maxNumPattern)
+			{
+				calcHisto();
+				if (histo[patternLen] > 2) processMessage();
+				for (int16_t i = messageLen - 1; i > 0; --i)
+				{
+					if (message[i] == pattern_pos) // Finde den letzten Verweis im Array auf den Index der gleich ueberschrieben wird
+					{
+						i++; // i um eins erhoehen, damit zukuenftigen Berechnungen darauf aufbauen koennen
+						bufferMove(i);
+						break;
+					}
+				}
+			}
+			fidx = pattern_pos;
+			addPattern();
+
+			if (pattern_pos == maxNumPattern)
+			{
+				pattern_pos = 0;  // Wenn der Positions Index am Ende angelegt ist, gehts wieder bei 0 los und wir ueberschreiben alte pattern
+				patternLen = maxNumPattern;
+				mcDetected = false;  // When changing a pattern, we need to redetect a manchester signal and we are not in a buffer full mode scenario
+
+			}
+			if (pattern_pos > patternLen) patternLen = pattern_pos;
+
+		}
+		
+		// Add data to buffer
+		addData(fidx);
+
+
+#if DEBUGDETECT>3
+		DBG_PRINT("Pulse: "); DBG_PRINT(*first); DBG_PRINT(", "); DBG_PRINT(*last);
+		DBG_PRINT(", TOL: "); DBG_PRINT(tol); DBG_PRINT(", Found: "); DBG_PRINT(fidx);
+		DBG_PRINT(", Vld: "); DBG_PRINT(valid);
+		DBG_PRINT(", pattPos: "); DBG_PRINT(pattern_pos);
+		DBG_PRINT(", mLen: "); DBG_PRINTLN(messageLen);
+#endif
+
+
+}
+
+bool SignalDetectorClass::decode(const int * pulse)
+{
+	success = false;
+
+	//int temp;
+	//*first = *last;
+	//*last = *pulse;
+	if (messageLen > 0)
+		last = &pattern[message[messageLen - 1]];
+	*first = *pulse;
+	
+	doDetect();
+	return success;
+}
+
+
+void SignalDetectorClass::compress_pattern()
+{
+	calcHisto();
+	for (uint8_t idx = 0; idx<patternLen-1; idx++)
+	{
+		if (histo[idx] == 0)
+			continue;
+
+		for (uint8_t idx2 = idx + 1; idx2<patternLen; idx2++)
+		{
+			if (histo[idx2] == 0 || (pattern[idx] ^ pattern[idx2]) >> 15)
+				continue;
+			const int16_t tol = int((abs(pattern[idx2])*tolFact) + (abs(pattern[idx2])*tolFact) / 2);
+			if (inTol(pattern[idx2], pattern[idx], tol))  // Pattern are very equal, so we can combine them
+			{
+				// Change val -> ref_val in message array
+				for (uint8_t i = 0; i<messageLen; i++)
+				{
+					if (message[i] == idx2)
+					{
+						message[i] = idx;
+					}
+				}
+
+#if DEBUGDETECT>2
+				DBG_PRINT("compr: "); DBG_PRINT(idx2); DBG_PRINT("->"); DBG_PRINT(idx); DBG_PRINT(";");
+				DBG_PRINT(histo[idx2]); DBG_PRINT("*"); DBG_PRINT(pattern[idx2]);
+				DBG_PRINT("->");
+				DBG_PRINT(histo[idx]); DBG_PRINT("*"); DBG_PRINT(pattern[idx]);
+				
+#endif // DEBUGDETECT
+
+
+				int  sum = histo[idx] + histo[idx2];
+				pattern[idx] = ((long(pattern[idx]) * histo[idx]) + (pattern[idx2] * histo[idx2])) / sum;
+				histo[idx] += histo[idx2];
+				pattern[idx2] = histo[idx2]= 0;
+
+#if DEBUGDETECT>2
+				DBG_PRINT(" idx:"); DBG_PRINT(pattern[idx]);
+				DBG_PRINT(" idx2:"); DBG_PRINT(pattern[idx2]);
+				DBG_PRINTLN(";");
+#endif // DEBUGDETECT
+
+			}
+		}
+	}
+}
+
+void SignalDetectorClass::processMessage()
+{
+	yield();
+
+	if (mcDetected == true || messageLen >= minMessageLen) {
+		success = false;
+
+#if DEBUGDETECT >= 1
+		DBG_PRINTLN("Message received:");
+#endif
+		compress_pattern();
+		calcHisto();
+		getClock();
+		if (state == clockfound) getSync();
+
+#if DEBUGDETECT >= 1
+		printOut();
+#endif
+
+		if (MSenabled && state == syncfound && messageLen >= minMessageLen)// Messages mit clock / Sync Verhaeltnis pruefen
+		{
+#if DEBUGDECODE >0
+			MSG_PRINT(" MS check: ");
+
+			//printOut();
+#endif	
+
+			// Setup of some protocol identifiers, should be retrieved via fhem in future
+
+			mend = mstart + 2;   // GGf. kann man die Mindestlaenge von x Signalen vorspringen
+			bool m_endfound = false;
+
+			//uint8_t repeat;
+			while (mend < messageLen - 1)
+			{
+				if (message[mend + 1] == sync && message[mend] == clock) {
+					mend -= 1;					// Previus signal is last from message
+					m_endfound = true;
+					break;
+				}
+				mend += 2;
+			}
+			if (mend > messageLen) mend = messageLen;  // Reduce mend if we are behind messageLen
+													   //if (!m_endfound) mend=messageLen;  // Reduce mend if we are behind messageLen
+
+			calcHisto(mstart, mend);	// Recalc histogram due to shortened message
+
+
+#if DEBUGDECODE > 1
+			DBG_PRINT("Index: ");
+			DBG_PRINT(" MStart: "); DBG_PRINT(mstart);
+			DBG_PRINT(" SYNC: "); DBG_PRINT(sync);
+			DBG_PRINT(", CP: "); DBG_PRINT(clock);
+			DBG_PRINT(" - MEFound: "); DBG_PRINTLN(m_endfound);
+			DBG_PRINT(" - MEnd: "); DBG_PRINTLN(mend);
+#endif // DEBUGDECODE
+			if ((m_endfound && (mend - mstart) >= minMessageLen) || (!m_endfound && messageLen < (maxMsgSize)))//(!m_endfound && messageLen  >= minMessageLen))	// Check if message Length is long enough
+			{
+#ifdef DEBUGDECODE
+				MSG_PRINTLN("Filter Match: ");;
+#endif
+
+
+				preamble = "";
+				postamble = "";
+
+				/*				Output raw message Data				*/
+				preamble.concat(MSG_START);
+				//preamble.concat('\n');
+				preamble.concat("MS");   // Message Index
+										 //preamble.concat(int(pattern[sync][0]/(float)pattern[clock][0]));
+				preamble.concat(SERIAL_DELIMITER);  // Message Index
+				for (uint8_t idx = 0; idx < patternLen; idx++)
+				{
+					if (pattern[idx] == 0 || histo[idx] == 0) continue;
+					preamble.concat('P'); preamble.concat(idx); preamble.concat("="); preamble.concat(pattern[idx]); preamble.concat(SERIAL_DELIMITER);  // Patternidx=Value
+				}
+				preamble.concat("D=");
+
+				postamble.concat(SERIAL_DELIMITER);
+				postamble.concat("CP="); postamble.concat(clock); postamble.concat(SERIAL_DELIMITER);    // ClockPulse
+				postamble.concat("SP="); postamble.concat(sync); postamble.concat(SERIAL_DELIMITER);     // SyncPulse
+				postamble.concat("R="); postamble.concat(rssiValue); postamble.concat(SERIAL_DELIMITER);     // Signal Level (RSSI)
+
+				if (m_overflow) {
+					postamble.concat("O");
+					postamble.concat(SERIAL_DELIMITER);
+				}
+				postamble.concat(MSG_END);
+				postamble.concat('\n');
+
+				printMsgRaw(mstart, mend, &preamble, &postamble);
+				success = true;
+
+#ifdef mp_crc
+				const int8_t crco = printMsgRaw(mstart, mend, &preamble, &postamble);
+
+				if ((mend < messageLen - minMessageLen) && (message[mend + 1] == message[mend - mstart + mend + 1])) {
+					mstart = mend + 1;
+					byte crcs = 0x00;
+#ifndef ARDUSIM
+					for (uint8_t i = mstart + 1; i <= mend - mstart + mend; i++)
+					{
+						crcs = _crc_ibutton_update(crcs, message[i]);
+					}
+#endif
+					if (crcs == crco)
+					{
+						// repeat found
+					}
+					//processMessage(); // Todo: needs to be optimized
+				}
+#endif
+
+
+			}
+			else if (m_endfound == false && mstart > 0 && mend + 1 >= maxMsgSize) // Start found, but no end. We remove everything bevore start and hope to find the end later
+			{
+				//MSG_PRINT("copy");
+#ifdef DEBUGDECODE
+				DBG_PRINT(" move msg ");;
+#endif
+				bufferMove(mstart);
+				m_truncated = true;  // Flag that we truncated the message array and want to receiver some more data
+			} 
+			else if (m_endfound && mend < maxMsgSize) {  // Start and end found, but end is not at end of buffer, so we remove only what was checked
+#ifdef DEBUGDECODE
+				DBG_PRINT(" move msg ");;
+#endif
+				bufferMove(mend);
+				m_truncated = true;  // Flag that we truncated the message array and want to receiver some more data
+				success = true;	// don't process other message types
+			}
+			else {
+#ifdef DEBUGDECODE
+				MSG_PRINTLN(" Buffer overflow, flushing message array");
+#endif
+				//MSG_PRINT(MSG_START);
+				//MSG_PRINT("Buffer overflow while processing signal");
+				//MSG_PRINT(MSG_END);
+				reset(); // Our Messagebuffer is not big enough, no chance to get complete Message
+				
+				success = true;	// don't process other message types
+			}
+		}
+		if (success == false && (MUenabled || MCenabled)) {
+
+#if DEBUGDECODE >0
+			DBG_PRINT(" check:");
+
+			//printOut();
+#endif	
+// Message has a clock puls, but no sync. Try to decode this
+
+			preamble = "";
+			postamble = "";
+
+
+			//String preamble;
+
+			preamble.concat(MSG_START);
+			if (MCenabled)
+			{
+				//DBG_PRINT(" mc: ");
+
+				static ManchesterpatternDecoder mcdecoder(this);			// Init Manchester Decoder class
+
+				if (mcDetected == false)
+				{
+					mcdecoder.reset();
+					mcdecoder.setMinBitLen(17);							// Todo: allow modification via command
+				}
+#if DEBUGDETECT>3
+				MSG_PRINT("vcnt: "); MSG_PRINT(mcdecoder.ManchesterBits.valcount);
+#endif
+
+				if ((mcDetected || mcdecoder.isManchester()) && mcdecoder.doDecode())	// Check if valid manchester pattern and try to decode
+				{
+#if DEBUGDECODE > 1
+					MSG_PRINT(" MC found: ");
+#endif // DEBUGDECODE
+
+					String mcbitmsg;
+					//MSG_PRINTLN("MC");
+					mcbitmsg = "D=";
+					mcdecoder.getMessageHexStr(&mcbitmsg);
+					//MSG_PRINTLN("f");
+
+
+					preamble.concat("MC");
+					preamble.concat(SERIAL_DELIMITER);
+					mcdecoder.getMessagePulseStr(&preamble);
+
+					postamble.concat(SERIAL_DELIMITER);
+					mcdecoder.getMessageClockStr(&postamble);
+					mcdecoder.getMessageLenStr(&postamble);
+
+					postamble.concat("R="); postamble.concat(rssiValue); postamble.concat(SERIAL_DELIMITER);     // Signal Level (RSSI)
+					postamble.concat(MSG_END);
+					postamble.concat('\n');
+
+					//messageLen=messageLen-mend; // Berechnung der neuen Nachrichtenlaenge nach dem Loeschen
+					//memmove(message,message+mend,sizeof(*message)*(messageLen+1));
+					//m_truncated=true;  // Flag that we truncated the message array and want to receiver some more data
+
+					//preamble = String(MSG_START)+String("MC")+String(SERIAL_DELIMITER)+preamble;
+					//printMsgRaw(0,messageLen,&preamble,&postamble);
+
+					//preamble.concat("MC"); ; preamble.concat(SERIAL_DELIMITER);  // Message Index
+
+					// Output Manchester Bits
+#ifdef DEBUGDECODE
+					DBG_PRINTLN(" ");
+#endif
+
+					printMsgStr(&preamble, &mcbitmsg, &postamble);
+					mcDetected = false;
+					success = true;
+
+#if DEBUGDECODE == 1
+					preamble = "MC";
+					preamble.concat(SERIAL_DELIMITER);
+
+					for (uint8_t idx = 0; idx < patternLen; idx++)
+					{
+						if (histo[idx] == 0) continue;
+
+						preamble.concat("P"); preamble.concat(idx); preamble.concat("="); preamble.concat(pattern[idx]); preamble.concat(SERIAL_DELIMITER);  // Patternidx=Value
+					}
+					preamble.concat("D=");
+
+					//String postamble;
+					postamble = String(SERIAL_DELIMITER);
+					postamble.concat("CP="); postamble.concat(clock); postamble.concat(SERIAL_DELIMITER);    // ClockPulse, (not valid for manchester)
+					if (m_overflow) {
+						postamble.concat("O");
+						postamble.concat(SERIAL_DELIMITER);
+					}
+
+					postamble.concat(MSG_END);
+					postamble.concat('\n');
+
+					printMsgRaw(0, messageLen, &preamble, &postamble);
+#endif
+
+				}
+				else if (mcDetected == true && m_truncated == true) {
+
+					success = true;   // Prevents MU Processing
+				}
+
+			}
+			if (MUenabled && state == clockfound && success == false && messageLen >= minMessageLen) {
+
+#if DEBUGDECODE > 1
+				DBG_PRINT(" MU found: ");
+#endif // DEBUGDECODE
+
+				//preamble = String(MSG_START)+String("MU")+String(SERIAL_DELIMITER)+preamble;
+
+				preamble.concat("MU");
+				preamble.concat(SERIAL_DELIMITER);
+
+				for (uint8_t idx = 0; idx < patternLen; idx++)
+				{
+					if (pattern[idx] == 0 || histo[idx] == 0) continue;
+
+					preamble.concat("P"); preamble.concat(idx); preamble.concat("="); preamble.concat(pattern[idx]); preamble.concat(SERIAL_DELIMITER);  // Patternidx=Value
+				}
+				preamble.concat("D=");
+
+				//String postamble;
+				postamble.concat(SERIAL_DELIMITER);
+				postamble.concat("CP="); postamble.concat(clock); postamble.concat(SERIAL_DELIMITER);    // ClockPulse, (not valid for manchester)
+				postamble.concat("R="); postamble.concat(rssiValue); postamble.concat(SERIAL_DELIMITER);     // Signal Level (RSSI)
+
+				if (m_overflow) {
+					postamble.concat("O");
+					postamble.concat(SERIAL_DELIMITER);
+				}
+				postamble.concat(MSG_END);
+				postamble.concat('\n');
+
+				printMsgRaw(0, messageLen - 1, &preamble, &postamble);
+				m_truncated = false;
+				success = true;
+			}
+
+		}
+		
+		if (success == false) 
+		{
+#if DEBUGDETECT >= 1
+			DBG_PRINTLN("nothing to to");
+#endif
+		}
+	}
+	if (!m_truncated)
+	{
+		reset();
+	}
+
+	//MSG_PRINTLN("process finished");
+}
+
+
+
+
+
+
+void SignalDetectorClass::reset()
+{
+	messageLen = 0;
+	patternLen = 0;
+	pattern_pos = 0;
+	bitcnt = 0;
+	state = searching;
+	clock = sync = -1;
+	for (uint8_t i = 0; i<maxNumPattern; ++i)
+	  histo[i] = pattern[i] = 0;
+	success = false;
+	tol = 150; //
+	tolFact = 0.2;
+	mstart = 0;
+	m_truncated = false;
+	m_overflow = false;
+	mcDetected = false;
+	//MSG_PRINTLN("reset");
+	mend = 0;
+	//DBG_PRINT(":sdres:");
+}
+
+const status SignalDetectorClass::getState()
+{
+	return status();
+}
+
+
+const bool SignalDetectorClass::inTol(const int val, const int set, const int tolerance)
+{
+	
+	// tolerance = tolerance == 0 ? tol : tolerance;
+	//return (abs(val - set) <= tolerance == 0 ? tol: tolerance);
+	return (abs(val - set) <= tolerance);
+}
+
+void SignalDetectorClass::printOut()
+{
+	DBG_PRINTLN("");
+	if (sync > -1) {
+		DBG_PRINT("Sync: ");DBG_PRINT(pattern[sync]);
+		DBG_PRINT(" -> SyncFact: "); DBG_PRINT(pattern[sync] / (float)pattern[clock]);
+		DBG_PRINT(",");
+	}
+	DBG_PRINT(" Clock: "); DBG_PRINT(pattern[clock]);
+	DBG_PRINT(", Tol: "); DBG_PRINT(tol);
+	DBG_PRINT(", PattLen: "); DBG_PRINT(patternLen); DBG_PRINT(" ("); DBG_PRINT(pattern_pos); DBG_PRINT(")");
+	DBG_PRINT(", Pulse: "); DBG_PRINT(*first); DBG_PRINT(", "); DBG_PRINT(*last);
+	DBG_PRINT(", mStart: "); DBG_PRINT(mstart);
+	DBG_PRINT(", MCD: "); DBG_PRINT(mcDetected,DEC);
+	DBG_PRINT(", mtrunc: "); DBG_PRINT(m_truncated, DEC);
+
+
+	DBG_PRINTLN(); DBG_PRINT("Signal: ");
+	uint8_t idx;
+	for (idx = 0; idx<messageLen; ++idx) {
+		DBG_PRINT(*(message + idx));
+	}
+	DBG_PRINT(". "); DBG_PRINT(" ["); DBG_PRINT(messageLen); DBG_PRINTLN("]");
+	DBG_PRINT("Pattern: ");
+	for (uint8_t idx = 0; idx<patternLen; ++idx) {
+		DBG_PRINT(" P"); DBG_PRINT(idx);
+		DBG_PRINT(": "); DBG_PRINT(histo[idx]);  DBG_PRINT("*[");
+		if (pattern[idx] != 0)
+		{
+			DBG_PRINT(",");
+			DBG_PRINT(pattern[idx]);
+		}
+
+		DBG_PRINT("]");
+	}
+	DBG_PRINTLN();
+}
+
+int8_t SignalDetectorClass::findpatt(const int val)
+{
+	//seq[0] = Laenge  //seq[1] = 1. Eintrag //seq[2] = 2. Eintrag ...
+	// Iterate over patterns (1 dimension of array)
+	tol = abs(val)*0.2;
+	for (uint8_t idx = 0; idx<patternLen; ++idx)
+	{
+		if ((val ^ pattern[idx]) >> 15)
+			continue;
+		if (pattern[idx] != 0 && inTol(val, pattern[idx],tol))  // Skip this iteration, if seq[x] <> pattern[idx][x]
+									   //if (!inTol(seq[x],pattern[idx][x-1]))  // Skip this iteration, if seq[x] <> pattern[idx][x]
+		{
+			return idx;
+		}
+	}
+	// sequence was not found in pattern
+	return -1;
+}
+/*
+bool SignalDecoderClass::validSequence(const int * a, const int * b)
+{
+	return ((*a ^ *b) < 0); // true if a and b have opposite signs
+}
+*/
+
+void SignalDetectorClass::calcHisto(const uint8_t startpos, uint8_t endpos)
+{
+	for (uint8_t i = 0; i<maxNumPattern; ++i)
+	{
+		histo[i] = 0;
+	}
+
+	if (endpos == 0) endpos = messageLen;
+
+	for (uint8_t i = startpos; i<endpos; ++i)
+	{
+		histo[message[i]]++;
+	}
+}
+
+bool SignalDetectorClass::getClock()
+{
+	// Durchsuchen aller Musterpulse und prueft ob darin eine clock vorhanden ist
+#if DEBUGDETECT > 3
+	MSG_PRINTLN("  --  Searching Clock in signal -- ");
+#endif
+	int tstclock = -1;
+	state = searching;
+
+	clock = -1; // Workaround for sync detection bug.
+
+	for (uint8_t i = 0; i<patternLen; ++i) 		  // Schleife fuer Clock
+	{
+		//if (pattern[i][0]<=0 || pattern[i][0] > 3276)  continue;  // Annahme Werte <0 / >3276 sind keine Clockpulse
+		if (tstclock == -1 && (pattern[i] >= 0) && (histo[i] > messageLen*0.17))
+		{
+			tstclock = i;
+			continue;
+		}
+
+		if ((pattern[i] >= 0) && (pattern[i] < pattern[tstclock]) && (histo[i] > messageLen*0.17)) {
+			tstclock = i;
+		}
+	}
+
+
+	// Check Anzahl der Clockpulse von der Nachrichtenlaenge
+	//if ((tstclock == 3276) || (maxcnt < (messageLen /7*2))) return false;
+	if (tstclock == -1) return false;
+
+	clock = tstclock;
+
+	// Todo: GGf. andere Pulse gegen die ermittelte Clock verifizieren
+
+	state = clockfound;
+	return true;
+}
+
+bool SignalDetectorClass::getSync()
+{
+	// Durchsuchen aller Musterpulse und prueft ob darin ein Sync Faktor enthalten ist. Anschließend wird verifiziert ob dieser Syncpuls auch im Signal nacheinander uebertragen wurde
+	//
+#if DEBUGDETECT > 3
+	DBG_PRINTLN("  --  Searching Sync  -- ");
+#endif
+
+	if (state == clockfound)		// we need a clock to find this type of sync
+	{
+		// clock wurde bereits durch getclock bestimmt.
+		for (int8_t p = patternLen - 1; p >= 0; --p)  // Schleife fuer langen Syncpuls
+		{
+			//if (pattern[p] > 0 || (abs(pattern[p]) > syncMaxMicros && abs(pattern[p])/pattern[clock] > syncMaxFact))  continue;  // Werte >0 oder laenger maxfact sind keine Sync Pulse
+			//if (pattern[p] == -1*maxPulse)  continue;  // Werte >0 sind keine Sync Pulse
+			//if (!validSequence(&pattern[clock],&pattern[p])) continue;
+			/*
+			if ( (pattern[p] > 0) ||
+			((abs(pattern[p]) > syncMaxMicros && abs(pattern[p])/pattern[clock] > syncMaxFact)) ||
+			(pattern[p] == -maxPulse) ||
+			(!validSequence(&pattern[clock],&pattern[p])) ||
+			(histo[p] > 6)
+			) continue;
+			*/
+			uint16_t syncabs = abs(pattern[p]);
+			if ((pattern[p] < 0) &&
+				//((abs(pattern[p]) <= syncMaxMicros && abs(pattern[p])/pattern[clock] <= syncMaxFact)) &&
+				(syncabs < syncMaxMicros && syncabs / pattern[clock] <= syncMaxFact) &&
+				(syncabs > syncMinFact*pattern[clock]) &&
+				// (syncabs < maxPulse) &&
+				//	 (validSequence(&pattern[clock],&pattern[p])) &&
+				(histo[p] < messageLen*0.08) && (histo[p] > 1)
+				//(histo[p] < 8) && (histo[p] > 1)
+
+				//(syncMinFact*pattern[clock] <= syncabs)
+				)
+			{
+				//if ((syncMinFact* (pattern[clock]) <= -1*pattern[p])) {//n>9 => langer Syncpulse (als 10*int16 darstellbar
+				// Pruefe ob Sync und Clock valide sein koennen
+				//	if (histo[p] > 6) continue;    // Maximal 6 Sync Pulse  Todo: 6 Durch Formel relativ zu messageLen ersetzen
+
+				// Pruefen ob der gefundene Sync auch als message [clock, p] vorkommt
+				uint8_t c = 0;
+
+				//while (c < messageLen-1 && message[c+1] != p && message[c] != clock)		// Todo: Abstand zum Ende berechnen, da wir eine mindest Nachrichtenlaenge nach dem sync erwarten, brauchen wir nicht bis zum Ende suchen.
+
+				while (c < messageLen - 1)		// Todo: Abstand zum Ende berechnen, da wir eine mindest Nachrichtenlaenge nach dem sync erwarten, brauchen wir nicht bis zum Ende suchen.
+				{
+					if (message[c + 1] == p && message[c] == clock) break;
+					c++;
+				}
+
+				//if (c==messageLen) continue;	// nichts gefunden, also Sync weitersuchen
+				if (c<messageLen - minMessageLen)
+				{
+					sync = p;
+					state = syncfound;
+					mstart = c;
+
+#ifdef DEBUGDECODE
+					//debug
+					DBG_PRINTLN();
+					DBG_PRINT("PD sync: ");
+					DBG_PRINT(pattern[clock]); DBG_PRINT(", "); DBG_PRINT(pattern[p]);
+					DBG_PRINT(", TOL: "); DBG_PRINT(tol);
+					DBG_PRINT(", sFACT: "); DBG_PRINTLN(pattern[sync] / (float)pattern[clock]);
+#endif
+					return true;
+				}
+			}
+		}
+	}
+	sync = -1; // Workaround for sync detection bug.
+	return false;
+}
+
+void SignalDetectorClass::printMsgStr(const String * first, const String * second, const String * third)
+{
+	MSG_PRINT(*first);
+	MSG_PRINT(*second);
+	MSG_PRINT(*third);
+
+}
+
+int8_t SignalDetectorClass::printMsgRaw(uint8_t m_start, const uint8_t m_end, const String * preamble, const String * postamble)
+{
+	MSG_PRINT(*preamble);
+	//String msg;
+	//msg.reserve(m_end-mstart);
+	byte crcv = 0x00;
+	for (; m_start <= m_end; m_start++)
+	{
+		//msg + =message[m_start];
+		//MSG_PRINT((100*message[m_start])+(10*message[m_start])+message[m_start]);
+		MSG_PRINT(message[m_start]);
+#ifndef ARDUSIM
+		//crcv = _crc_ibutton_update(crcv, message[m_start]);
+#endif
+	}
+	//MSG_PRINT(msg);
+	MSG_PRINT(*postamble);
+	return crcv;
+	//printMsgStr(preamble,&msg,postamble);}
+}
+
+
+
+
+
+
+/*
+********************************************************
+************* Manchester DECODER class ***************
+********************************************************
+*/
+/** @brief (Constructor for Manchester decoder. ref= object of type patternDetecor which is calling the manchester decoder)
+*
+* Initialisation of class MancheserpatternDecoder
+*/
+/*
+ManchesterpatternDecoder::ManchesterpatternDecoder(signalDecoder *ref_dec)
+{
+pdec = ref_dec;
+//ManchesterBits->new BitStore(1); // use 1 Bit for every value stored, reserve 30 Bytes = 240 Bits
+reset();
+}*/
+/** @brief (one liner)
+*
+* (documentation goes here)
+*/
+ManchesterpatternDecoder::~ManchesterpatternDecoder()
+{
+	//delete ManchesterBits->
+
+}
+
+
+
+/** @brief (Resets internal vars to defaults)
+*
+* Reset internal vars to defaults. Called after error or when finished
+*/
+void ManchesterpatternDecoder::reset()
+{
+#ifdef DEBUGDECODE
+	DBG_PRINT("mcrst:");
+#endif
+	longlow =   -1;
+	longhigh =  -1;
+	shortlow =  -1;
+	shorthigh = -1;
+	
+	mc_start_found = false;
+	mc_sync = false;
+
+	clock = 0;
+	minbitlen = 20; // Set defaults
+	ManchesterBits.reset();
+
+
+}
+/** @brief (Sets internal minbitlen to new value)
+*
+* (documentation goes here)
+*/
+void ManchesterpatternDecoder::setMinBitLen(const uint8_t len)
+{
+	minbitlen = len;
+}
+
+
+/** @brief (Returns true if given pattern index matches a long puls index)
+*
+* (documentation goes here)
+*/
+const bool ManchesterpatternDecoder::isLong(const uint8_t pulse_idx)
+{
+	return (pulse_idx == longlow || pulse_idx == longhigh);
+}
+
+/** @brief (Returns true if given pattern index matches a short puls index)
+*
+* (documentation goes here)
+*/
+
+const bool ManchesterpatternDecoder::isShort(const uint8_t pulse_idx)
+{
+	return (pulse_idx == shortlow || pulse_idx == shorthigh);
+}
+
+/** @brief (Converts decoded manchester bits in a provided string as hex)
+*
+* ()
+*/
+void ManchesterpatternDecoder::getMessageHexStr(String *message)
+{
+	char hexStr[] = "00" ; // Not really needed
+
+	message->reserve((ManchesterBits.valcount /4)+2);
+	if (!message)
+		return;
+	uint8_t idx;
+	// Bytes are stored from left to right in our buffer. We reverse them for better readability
+	for ( idx = 0; idx <= ManchesterBits.bytecount-1; ++idx) {
+		//MSG_PRINT(getMCByte(idx),HEX);
+		//sprintf(hexStr, "%02X",reverseByte(ManchesterBits->>getByte(idx)));
+		//MSG_PRINT(".");
+		sprintf(hexStr, "%02X", getMCByte(idx));
+		message->concat(hexStr);
+		//MSG_PRINT(hexStr);
+	}
+	
+	sprintf(hexStr, "%01X", getMCByte(idx) >> 4 & 0xf);
+	message->concat(hexStr);
+	if (ManchesterBits.valcount % 8 > 4 || ManchesterBits.valcount % 8 == 0)
+	{
+		sprintf(hexStr, "%01X", getMCByte(idx) & 0xF);
+		message->concat(hexStr);
+	}
+
+	//MSG_PRINTLN();
+
+}
+
+/** @brief (one liner)
+*
+* (documentation goes here)
+*/
+void ManchesterpatternDecoder::getMessagePulseStr(String* str)
+{
+	str->reserve(32);
+	if (!str)
+		return;
+
+	str->concat("LL="); str->concat(pdec->pattern[longlow]); str->concat(SERIAL_DELIMITER);
+	str->concat("LH="); str->concat(pdec->pattern[longhigh]); str->concat(SERIAL_DELIMITER);
+	str->concat("SL="); str->concat(pdec->pattern[shortlow]); str->concat(SERIAL_DELIMITER);
+	str->concat("SH="); str->concat(pdec->pattern[shorthigh]); str->concat(SERIAL_DELIMITER);
+}
+
+/** @brief (one liner)
+*
+* (documentation goes here)
+*/
+void ManchesterpatternDecoder::getMessageClockStr(String* str)
+{
+	str->reserve(7);
+	if (!str)
+		return;
+
+	str->concat("C="); str->concat(clock); str->concat(SERIAL_DELIMITER);
+}
+
+void ManchesterpatternDecoder::getMessageLenStr(String* str)
+{
+
+	str->concat("L="); str->concat(ManchesterBits.valcount); str->concat(SERIAL_DELIMITER);
+}
+
+
+/** @brief (retieves one Byte out of the Bitstore for manchester decoded bits)
+*
+* (Returns a comlete byte from the pattern store)
+*/
+
+unsigned char ManchesterpatternDecoder::getMCByte(const uint8_t idx) {
+
+	return ManchesterBits.getByte(idx);
+}
+
+
+
+
+/** @brief (Decodes the manchester pattern to bits. Returns true on success and false on error )
+*
+* (Call only after ismanchester returned true)
+*/
+
+const bool ManchesterpatternDecoder::doDecode() {
+	//MSG_PRINT("bitcnt:");MSG_PRINTLN(bitcnt);
+
+	uint8_t i = 0;
+	pdec->m_truncated = false;
+//	bool mc_start_found = false;
+//	bool mc_sync = false;
+	pdec->mstart = 0; // Todo: pruefen ob start aus isManchester uebernommen werden kann
+#ifdef DEBUGDECODE
+	DBG_PRINT("mlen:");
+	DBG_PRINT(pdec->messageLen);
+	DBG_PRINT(":mstart: ");
+	DBG_PRINT(pdec->mstart);
+	DBG_PRINTLN("");
+
+#endif
+//	char  lastbit;
+	bool ht = false;
+	bool hasbit = false;
+
+	while (i < pdec->messageLen)
+	{
+		// Start vom MC Signal suchen
+		if (mc_start_found == false && (isLong(pdec->message[i]) || isShort(pdec->message[i])))
+		{
+			pdec->mstart = i;
+			mc_start_found = true;
+			mc_sync = true;
+
+			// lookup for first long
+			int pulseCnt = 0; 
+			bool preamble = false;
+			for (uint8_t l=i; l<pdec->messageLen; l++) {
+				bool pulseIsLong = isLong(pdec->message[l]);
+				
+				// no manchester
+				if (!(pulseIsLong || isShort(pdec->message[l]))) {
+					break;
+				}
+				
+				pulseCnt += (pulseIsLong ? 2 : 1);
+				// probe signal to match manchester
+				if (pulseIsLong) {
+					// probe clock based preamble
+					if (l == i && i > 0) {
+						int pClock = abs(pdec->pattern[pdec->message[l - 1]]);
+
+						if (pClock < maxPulse && (pdec->pattern[pdec->message[l - 1]] ^ pdec->pattern[pdec->message[l]] )>>15)
+						{
+							int pClocks = round(pClock / (float)clock);
+							
+							if (pClocks > 1 && abs(1 - (pClock / (pClocks * (float)clock))) <= 0.07) {
+#ifdef DEBUGDECODE
+								DBG_PRINT(F("preamble:")); DBG_PRINT(pClocks); DBG_PRINT(F("C"));
+#endif
+								pdec->mstart--;
+								preamble = true;
+								break;
+							}
+						}
+					}
+					
+					ht=((pulseCnt & 0x1) == 0);
+#ifdef DEBUGDECODE
+					if (ht) {
+						DBG_PRINT(F("pulseShift:")); DBG_PRINT(l); DBG_PRINT(";");
+					}
+#endif
+					break;
+				}
+			}
+			
+			// interpret first long as short if preamble was found 
+			if (preamble) {
+				ht = true;
+				i++;
+				continue;
+			}
+			
+		}
+		// Sync to a long or short pulse 
+		/*
+		if (mc_start_found && !mc_sync)
+		{
+			while ( (!isShort(pdec->message[i]  || !isLong(pdec->message[i])) && i < pdec->messageLen) {
+				i++;
+			}
+			if (i < pdec->messageLen) {
+				lastbit = (char)((unsigned int)pdec->pattern[pdec->message[i]] >> 15); // 1, wenn Pegel Low war, 0 bei einem High Pegel.
+				//lastbit = ~lastbit;  //TODO: Pruefen ob negiert korrekt ist.
+
+				uint8_t z = i - pdec->mstart;
+				if ((z < 1) or ((z % 2) == 0))
+					i = pdec->mstart;
+				else
+					i = pdec->mstart + 1;
+				//ManchesterBits->addValue((lastbit));
+				mc_sync = true;
+				//i++;
+				//MSG_PRINT("lb:"); MSG_PRINT(lastbit,DEC);
+			}
+		}
+		*/
+		// Decoding occures here
+		if (mc_sync && mc_start_found)
+		{
+			#ifdef DEBUGDECODE
+			char value;
+			#endif
+			if (isShort(pdec->message[i])) //Todo: Check for second short
+			{
+				hasbit = ht;
+				ht = !ht;
+				#ifdef DEBUGDECODE
+				value = 'S';
+				#endif
+				
+			}
+			else if (isLong(pdec->message[i])) {
+				hasbit = true;
+				ht = true;
+				#ifdef DEBUGDECODE
+				value = 'L';
+				#endif
+			}
+			else { // Found something that fits not to our manchester signal
+#ifdef DEBUGDECODE
+				DBG_PRINT("H(");
+				DBG_PRINT("vcnt:");
+				DBG_PRINT(ManchesterBits.valcount);
+#endif
+
+				   //if (i < pdec->messageLen-minbitlen)
+				if (ManchesterBits.valcount < minbitlen)
+				{
+//					if (isShort(pdec->message[i]) && i < pdec->messageLen - 1 && !isShort(pdec->message[i + 1])) {
+//						// unequal number of short pulses. Restart, but one pulse ahead i is incremented at end of while loop
+//						i = pdec->mstart;
+//					}
+					//pdec->mstart=i;
+					mc_start_found = false; // Reset to find new starting position
+					mc_sync = false;
+					ht = false; // reset short count too
+#ifdef DEBUGDECODE
+					MSG_PRINT(":RES:");
+#endif
+					ManchesterBits.reset();
+
+				} else {
+					pdec->mend = i - (ht ? 0 : 1); // keep short in buffer
+//					if (isShort(pdec->message[i]) && i == maxMsgSize - 1)) {
+//						pdec->mend--;
+//					}
+#ifdef DEBUGDECODE
+					DBG_PRINT(":mpos=");
+					DBG_PRINT(i);
+					DBG_PRINT(":mstart=");
+					DBG_PRINT(pdec->mstart);
+					DBG_PRINT(":mend:");
+					DBG_PRINT(pdec->mend);
+					DBG_PRINT(":found:");
+					DBG_PRINT(":pidx=");
+					DBG_PRINT(pdec->pattern[pdec->message[i]]);
+
+#endif
+					pdec->bufferMove(i);
+					pdec->m_truncated = true;  // Flag that we truncated the message array and want to receiver some more data
+					mc_start_found = false;  // This will break serval unit tests. Normaly setting this to false shoud be done by reset, needs to be checked if reset shoud be called after hex string is printed out
+			
+					//if (i+minbitlen > pdec->messageLen)
+					/*
+					if ( isShort(pdec->message[pdec->messageLen]) )
+					{
+
+						pdec->mcDetected = true;
+						return false;
+					}
+					*/
+					return (ManchesterBits.valcount >= minbitlen);  // Min 20 Bits needed
+				}
+#ifdef DEBUGDECODE
+				MSG_PRINT(")");
+#endif
+			}
+
+
+			if (mc_start_found) { // don't write if manchester processing was canceled
+#ifdef DEBUGDECODE
+				if (pdec->pattern[pdec->message[i]] < 0)
+					value = (value + 0x20); //lowwecase
+				DBG_PRINT(value);
+#endif
+	
+				if (hasbit) {
+					ManchesterBits.addValue((pdec->pattern[pdec->message[i]] > 0 ? 1 : 0));
+#ifdef DEBUGDECODE
+					DBG_PRINT(ManchesterBits.getValue(ManchesterBits.valcount-1));
+#endif
+					hasbit = false;
+				} else {
+#ifdef DEBUGDECODE
+					DBG_PRINT("_");
+#endif
+				}
+			}
+
+
+		}
+		//MSG_PRINT(" S MC ");
+		i++;
+	}
+	pdec->mend = i - (ht ? 0 : 1); // keep short in buffer;
+
+#ifdef DEBUGDECODE
+	DBG_PRINT(":mpos=");
+	DBG_PRINT(i);
+	DBG_PRINT(":mstart=");
+	DBG_PRINT(pdec->mstart);
+	DBG_PRINT(":mend=");
+	DBG_PRINT(pdec->mend);
+	DBG_PRINT(":vcnt=");
+	DBG_PRINT(ManchesterBits.valcount-1);
+	DBG_PRINT(":bfin:");
+#endif
+
+
+	// Check if last entry in our message array belongs to our manchester signal
+	if (i == maxMsgSize && i == pdec->messageLen  && pdec->mstart > 0 && ManchesterBits.valcount > minbitlen / 2)
+	{
+#ifdef DEBUGDECODE
+		DBG_PRINT(":bmove:");
+#endif
+
+		pdec->bufferMove(pdec->mstart);
+		pdec->m_truncated = true;  // Flag that we truncated the message array and want to receiver some more data
+		
+		pdec->mcDetected = true;
+		return false;
+	}
+	// Buffer is full with mc signal, so we clear the buffer and caputre additional signaldata
+	else if (i == maxMsgSize && i == pdec->messageLen && pdec->mstart == 0)
+	{
+		pdec->mcDetected = true;
+		pdec->messageLen = 0;
+		pdec->m_truncated = true;  // Flag that we truncated the message array and want to receiver some more data
+#ifdef DEBUGDECODE
+		DBG_PRINT(":bflush:");
+
+#endif
+		return false;
+	}
+
+	return (ManchesterBits.valcount >= minbitlen);  // Min 20 Bits needed, then return true, otherwise false
+
+													//MSG_PRINT(" ES MC ");
+}
+
+/** @brief (Verifies if found signal data is a valid manchester signal, returns true or false)
+*
+* (Check signal based on patternLen, histogram and pattern store for valid manchester style.Provides key indexes for the 4 signal states for later decoding)
+*/
+
+const bool ManchesterpatternDecoder::isManchester()
+{
+	// Durchsuchen aller Musterpulse und prueft ob darin eine clock vorhanden ist
+#if DEBUGDETECT >= 1
+	DBG_PRINTLN("");
+	DBG_PRINTLN("  --  chk MC -- ");
+	DBG_PRINT("mstart:");
+	DBG_PRINTLN(pdec->mstart);
+#endif
+	if (pdec->patternLen < 4)	return false;
+
+	int tstclock = -1;
+
+	uint8_t pos_cnt = 0;
+	uint8_t neg_cnt = 0;
+	int equal_cnt = 0;
+	const uint8_t minHistocnt = round(pdec->messageLen*0.04);
+				                          //     3     1    0     2
+	uint8_t sortedPattern[maxNumPattern]; // 1300,-1300,-734,..800
+	uint8_t p=0;
+
+	for (uint8_t i = 0; i < pdec->patternLen; i++)
+	{
+		if (pdec->histo[i] < minHistocnt) continue;		// Skip this pattern, due to less occurence in our message
+		#if DEBUGDETECT >= 1
+				MSG_PRINT(p);
+		#endif		
+
+		uint8_t ptmp = p;
+
+		while ( p!= 0 && pdec->pattern[i] < pdec->pattern[sortedPattern[p-1]])
+		{
+			sortedPattern[p] = sortedPattern[p-1];
+			p--;
+		}
+#if DEBUGDETECT >= 1
+		DBG_PRINT("="); DBG_PRINT(i); DBG_PRINT(",");
+#endif
+		sortedPattern[p] = i;
+		p = ptmp+1;
+	}
+#if DEBUGDETECT >= 3
+	DBG_PRINT("Sorted:");
+	for (uint8_t i = 0; i < p; i++)
+	{
+		DBG_PRINT(sortedPattern[i]); DBG_PRINT(",");
+	}
+	DBG_PRINT(";");
+#endif
+
+
+	for (uint8_t i = 0; i<p ; i++)
+	{
+		if (pdec->pattern[sortedPattern[i]] <=0) continue;
+#if DEBUGDETECT >= 2
+		DBG_PRINT("CLK="); DBG_PRINT(sortedPattern[i]); DBG_PRINT(":");
+#endif
+		longlow = -1;
+		longhigh = -1;
+		shortlow = -1;
+		shorthigh = -1;
+		pos_cnt=0;
+		neg_cnt = 0;
+		tstclock = -1;
+		equal_cnt = 0;
+
+		const int clockpulse = pdec->pattern[sortedPattern[i]];
+		for (uint8_t x = 0; x < p; x++)
+		{
+#if DEBUGDETECT >= 1
+			DBG_PRINT(sortedPattern[x]); 
+#endif
+
+			const int aktpulse = pdec->pattern[sortedPattern[x]];
+			bool pshort = false;
+			bool plong = false;
+
+			if (pdec->inTol(clockpulse, abs(aktpulse), clockpulse*0.5))
+				pshort = true;
+			else if (pdec->inTol(clockpulse*2, abs(aktpulse), clockpulse*0.80))
+				plong = true;
+
+			#if DEBUGDETECT >= 3
+			DBG_PRINT("^=(PS="); DBG_PRINT(pshort); DBG_PRINT(";");
+			DBG_PRINT("PL="); DBG_PRINT(plong); DBG_PRINT(";)");
+			#endif
+			#if DEBUGDETECT >= 1
+			DBG_PRINT(",");
+			#endif
+
+			if (aktpulse > 0)
+			{
+				if (pshort) shorthigh = sortedPattern[x];
+				else if (plong) longhigh = sortedPattern[x];
+				else continue;
+				//equal_cnt += pdec->histo[sortedPattern[x]]; 
+
+				pos_cnt++;
+				tstclock += aktpulse;
+			}
+			else {
+				if (pshort) shortlow = sortedPattern[x];
+				else if (plong) longlow = sortedPattern[x];
+				else continue;
+
+				//equal_cnt -= pdec->histo[sortedPattern[x]];
+				neg_cnt++;
+				tstclock -= aktpulse;
+
+			}
+		
+			//TODO: equal_cnt sollte nur ueber die validen Pulse errechnet werden Signale nur aus 3 Pulsen sind auch valide (FFFF)...
+
+			if ((longlow != -1) && (shortlow != -1) && (longhigh != -1) && (shorthigh != -1))
+			{
+#if DEBUGDETECT >= 1
+				DBG_PRINT("vfy ");
+#endif
+
+				int z = 0;
+				while (z < pdec->messageLen)
+				{
+
+					if ( (isLong(pdec->message[z] == false) && (isShort(pdec->message[z]) == false)) || (z == (pdec->messageLen-1)))
+					{  
+#if DEBUGDETECT >= 1
+						DBG_PRINT(z); DBG_PRINT("=")DBG_PRINT(pdec->message[i]); DBG_PRINT(";")
+
+						DBG_PRINT("Long"); DBG_PRINT(isLong(pdec->message[i])); DBG_PRINT(";");
+						DBG_PRINT("Short"); DBG_PRINT(isShort(pdec->message[i])); DBG_PRINTLN(";");
+
+#endif
+						if ((z - pdec->mstart) > minbitlen)  // Todo: Hier wird auf minbitlen geprueft. Die Differenz zwischen mstart und mend sind aber Pulse und keine bits
+						{
+							pdec->mend = z;
+
+							pdec->calcHisto(pdec->mstart, pdec->mend);
+							equal_cnt = pdec->histo[shorthigh] + pdec->histo[longhigh] - pdec->histo[shortlow] - pdec->histo[longlow];
+
+#if DEBUGDETECT >= 1
+							DBG_PRINT("equalcnt: pos "); DBG_PRINT(pdec->mstart); DBG_PRINT(" to ") DBG_PRINT(pdec->mend); DBG_PRINT("count=");  DBG_PRINT(equal_cnt); DBG_PRINT(" ");
+#endif
+							mc_start_found = false;
+							if (abs(equal_cnt) > round(pdec->messageLen*0.04))  break; //Next loop
+#if DEBUGDETECT >= 1
+							DBG_PRINT(" MC equalcnt matched");
+#endif
+							if (neg_cnt != pos_cnt) break;  // Both must be 2   //TODO: For FFFF we have only 3 valid pulses!
+#if DEBUGDETECT >= 1
+							DBG_PRINT("  MC neg and pos pattern cnt is equal");
+#endif
+
+							if ((longlow == longhigh) || (shortlow == shorthigh) || (longlow == shortlow) || (longhigh == shorthigh) || (longlow == shorthigh) || (longhigh == shortlow)) break; //Check if the indexes are valid
+
+							tstclock = tstclock / 6;
+#if DEBUGDETECT >= 1
+							MSG_PRINT("  tstclock: "); DBG_PRINT(tstclock);
+#endif
+							clock = tstclock;
+
+#if DEBUGDETECT >= 1
+							DBG_PRINT(" MC LL:"); DBG_PRINT(longlow);
+							DBG_PRINT(", MC LH:"); DBG_PRINT(longhigh);
+
+							DBG_PRINT(", MC SL:"); DBG_PRINT(shortlow);
+							DBG_PRINT(", MC SH:"); DBG_PRINT(shorthigh);
+							DBG_PRINTLN("");
+#endif
+							// TOdo: Bei FFFF passt diese Pruefung nicht.
+
+#if DEBUGDETECT >= 1
+							DBG_PRINTLN("  -- MC found -- ");
+#endif
+
+							return true;;
+
+						}
+						else {
+							mc_start_found = false;
+							mc_sync = false;
+						}
+					} else {
+						if (mc_start_found == false)
+						{
+							pdec->mstart = z;
+							mc_start_found = true;
+						}
+					}
+					z++;
+				}
+			}
+		}
+
+	}
+	return false;
+
+
+
+}
+
diff -ruwN ./signalDecoder.h ../../trebron106/SIGNALEsp-20170510/signalDecoder.h
--- ./signalDecoder.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/signalDecoder.h	2017-05-01 08:54:58.000000000 +0200
@@ -0,0 +1,171 @@
+/*
+*   Pattern Decoder Library V3
+*   Library to decode radio signals based on patternd detection
+*   2014-2015  N.Butzek, S.Butzek
+*   2015  S.Butzek
+*	2016  S.Butzek
+
+*   This library contains different classes to perform detecting of digital signals
+*   typical for home automation. The focus for the moment is on different sensors
+*   like weather sensors (temperature, humidity Logilink, TCM, Oregon Scientific, ...),
+*   remote controlled power switches (Intertechno, TCM, ARCtech, ...) which use
+*   encoder chips like PT2262 and EV1527-type and manchester encoder to send
+*   information in the 433MHz or 868 Mhz Band.
+*
+*   The classes in this library follow the approach to detect a recurring pattern in the
+*   recived signal. For Manchester there is a class which decodes the signal.
+*
+*   This program is free software: you can redistribute it and/or modify
+*   it under the terms of the GNU General Public License as published by
+*   the Free Software Foundation, either version 3 of the License, or
+*   (at your option) any later version.
+*
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU General Public License
+*   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+#ifndef _SIGNALDECODER_h
+#define _SIGNALDECODER_h
+
+#if defined(ARDUINO) && ARDUINO >= 100
+	#include "Arduino.h"
+#else
+	#include "WProgram.h"
+#endif
+//#define DEBUG 1
+
+#include "output.h"
+#include "bitstore.h"
+#include "FastDelegate.h"
+
+#define maxNumPattern 8
+#define maxMsgSize 254
+#define minMessageLen 40
+#define syncMinFact 6
+#define syncMaxFact 39
+#define syncMaxMicros 17000
+#define maxPulse 32001  // Magic Pulse Length
+
+
+#define SERIAL_DELIMITER ';'
+#define MSG_START char(0x2)			// this is a non printable Char
+#define MSG_END char(0x3)			// this is a non printable Char
+//#define DEBUGDETECT 1
+//#define DEBUGDETECT 255  // Very verbose output
+//#define DEBUGDECODE 1
+
+enum status { searching, clockfound, syncfound, detecting };
+
+
+
+class SignalDetectorClass
+{
+	friend class ManchesterpatternDecoder;
+
+public:
+	SignalDetectorClass() : first(buffer), last(first + 1) { buffer[0] = buffer[1] = 0; reset(); };
+
+	void reset();
+	bool decode(const int* pulse);
+	const status getState();
+	typedef fastdelegate::FastDelegate0<uint8_t> FuncRetuint8t;
+	void setRSSICallback(FuncRetuint8t callbackfunction) { _rssiCallback = callbackfunction; }
+
+
+	//private:
+	int8_t clock;                           // index to clock in pattern
+	bool MUenabled;
+	bool MCenabled;
+	bool MSenabled;
+	uint8_t histo[maxNumPattern];
+	uint8_t message[maxMsgSize];
+	uint8_t messageLen;
+	uint8_t mstart; // Holds starting point for message
+	uint8_t mend;   // Holds end point for message if detected
+	bool success;                           // True if a valid coding was found
+
+	bool m_truncated;     // Identify if message has been truncated
+	bool m_overflow;
+	void bufferMove(const uint8_t start);
+
+	uint16_t tol;                           // calculated tolerance for signal
+	uint8_t bitcnt;
+	status state;                           // holds the status of the detector
+	int buffer[2];                          // Internal buffer to store two pules length
+	int* first;                             // Pointer to first buffer entry
+	int* last;                              // Pointer to last buffer entry
+	float tolFact;                          //
+	int pattern[maxNumPattern];				// 1d array to store the pattern
+	uint8_t patternLen;                     // counter for length of pattern
+	uint8_t pattern_pos;
+	int8_t sync;                        // index to sync in pattern if it exists
+	String preamble;
+	String postamble;
+	bool mcDetected;						// MC Signal alread detected flag
+	uint8_t rssiValue;						// Holds the RSSI value retrieved via a rssi callback
+	FuncRetuint8t _rssiCallback;			// Holds the pointer to a callback Function
+
+	void addData(const uint8_t value);
+	void addPattern();
+	inline void updPattern(const uint8_t ppos);
+
+	void doDetect();
+	void processMessage();
+	void compress_pattern();
+	void calcHisto(const uint8_t startpos = 0, uint8_t endpos = 0);
+	bool getClock(); // Searches a clock in a given signal
+	bool getSync();	 // Searches clock and sync in given Signal
+	int8_t printMsgRaw(uint8_t m_start, const uint8_t m_end, const String *preamble = NULL, const String *postamble = NULL);
+	void printMsgStr(const String *first, const String *second, const String *third);
+	const bool inTol(const int val, const int set, const int tolerance); // checks if a value is in tolerance range
+
+	void printOut();
+
+	int8_t findpatt(const int val);              // Finds a pattern in our pattern store. returns -1 if te pattern is not found
+	//bool validSequence(const int *a, const int *b);     // checks if two pulses are basically valid in terms of on-off signals
+	
+
+};
+
+class ManchesterpatternDecoder
+{
+public:
+	ManchesterpatternDecoder(SignalDetectorClass *ref_dec) : ManchesterBits(1), longlow(-1), longhigh(-1), shorthigh(-1), shortlow(-1) { pdec = ref_dec; 	reset(); };
+	~ManchesterpatternDecoder();
+	const bool doDecode();
+	void setMinBitLen(const uint8_t len);
+	void getMessageHexStr(String *message);
+	void getMessagePulseStr(String *str);
+	void getMessageClockStr(String* str);
+	void getMessageLenStr(String* str);
+
+	const bool isManchester();
+	void reset();
+#ifndef UNITTEST
+//private:
+#endif
+	BitStore<50> ManchesterBits;       // A store using 1 bit for every value stored. It's used for storing the Manchester bit data in a efficent way
+	SignalDetectorClass *pdec;
+	int8_t longlow;
+	int8_t longhigh;
+	int8_t shortlow;
+	int8_t shorthigh;
+	int clock; // Manchester calculated clock		
+	int8_t minbitlen;
+	
+	bool mc_start_found = false;
+	bool mc_sync = false;
+
+	const bool isLong(const uint8_t pulse_idx);
+	const bool isShort(const uint8_t pulse_idx);
+	unsigned char getMCByte(const uint8_t idx); // Returns one Manchester byte in correct order. This is a helper function to retrieve information out of the buffer
+};
+
+
+#endif
+
diff -ruwN ./SIGNALESP.ino ../../trebron106/SIGNALEsp-20170510/SIGNALESP.ino
--- ./SIGNALESP.ino	2017-08-17 12:43:36.538057925 +0200
+++ ../../trebron106/SIGNALEsp-20170510/SIGNALESP.ino	2017-05-09 16:29:28.000000000 +0200
@@ -1,68 +1,119 @@
+/*
+*   RF_RECEIVER v3.3 for Arduino
+*   Sketch to use an arduino as a receiver/sending device for digital signals
+*
+*   The Sketch can also encode and send data via a transmitter,
+*   while only PT2262 type-signals for Intertechno devices are implemented in the sketch,
+*   there is an option to send almost any data over a send raw interface
+*   2014-2015  N.Butzek, S.Butzek
+*   2016 S.Butzek
+
+*   This software focuses on remote sensors like weather sensors (temperature,
+*   humidity Logilink, TCM, Oregon Scientific, ...), remote controlled power switches
+*   (Intertechno, TCM, ARCtech, ...) which use encoder chips like PT2262 and
+*   EV1527-type and manchester encoder to send information in the 433MHz Band.
+*   But the sketch will also work for infrared or other medias. Even other frequencys
+*   can be used
+*
+*   This program is free software: you can redistribute it and/or modify
+*   it under the terms of the GNU General Public License as published by
+*   the Free Software Foundation, either version 3 of the License, or
+*   (at your option) any later version.
+*
+*   This program is distributed in the hope that it will be useful,
+*   but WITHOUT ANY WARRANTY; without even the implied warranty of
+*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+*   GNU General Public License for more details.
+*
+*   You should have received a copy of the GNU General Public License
+*   along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+*/
+//#define CMP_MEMDBG 1
 
+#define CMP_cc1101
 
-#define PROGNAME               "RF_RECEIVER"
+#define PROGNAME               "SIGNALEsp"
 #define PROGVERS               "3.3.1-dev"
+#define VERSION_1               0x33
+#define VERSION_2               0x1d
 
+/*
+ *   ESP8266            cc1101
+ *   
+ *   VDD           -------- VDD    3.3V
+ *   GPIO4  / D2   -------- GDO0
+ *   GPIO5  / D1   -------- GDO2
+ *   GPIO12 / D6   -------- MISO  --|  SPI Bus
+ *   GPIO13 / D7   -------- MOSI  --|
+ *   GPIO14 / D5   -------- SCLK  --|
+ *   GPIO15 / D8   -------- CSn   --|
+ *   GND           -------- GND
+ *   
+ *   
+ *   Led GPIO16 / D0
+ * 
+ */
 
-#define PIN_RECEIVE            2
+#ifdef CMP_cc1101
 #define PIN_LED                16
+		#define PIN_SEND              4   // gdo0Pin TX out ESP GPIO5 D1 
+	  #define PIN_RECEIVE           5   // gdo2Pin RX in  ESP GPIO4 D2
+#else
+  #define PIN_LED               16    // Message-LED
 #define PIN_SEND               0
+  #define PIN_RECEIVE           2
+#endif
+
 #define BAUDRATE               115200
-#define FIFO_LENGTH			   100
+#define FIFO_LENGTH			   50
 #define DEBUG				   1
 
-
-#define ETHERNET_PRINT
 #include <ESP8266WiFi.h>
-#include <output.h>
-#include <bitstore.h>  // Die wird aus irgend einem Grund zum Compilieren benoetigt.
-#include <SimpleFIFO.h>
+#include <DNSServer.h>
+#include <ESP8266WebServer.h>
+#include <WiFiManager.h>
 
-SimpleFIFO<int, FIFO_LENGTH> FiFo; //store FIFO_LENGTH # ints
-#include <signalDecoder.h>
-SignalDetectorClass musterDec;
+#include "cc1101.h"
+#include <EEPROM.h>
 
+#include "FastDelegate.h"
+#include "output.h"
+#include "bitstore.h"
+#include "signalDecoder.h"
+// #include "TimerOne.h"  // Timer for LED Blinking
 
-#include <EEPROM.h>
+#include "SimpleFIFO.h"
+SimpleFIFO<int,FIFO_LENGTH> FiFo; //store FIFO_LENGTH # ints
+SignalDetectorClass musterDec;
 
+// cc1101 cc1101;
 
 #define pulseMin  90
 volatile bool blinkLED = false;
 String cmdstring = "";
 volatile unsigned long lastTime = micros();
-
-
-
-#define digitalLow(P) digitalWrite(P,LOW)
-#define digitalHigh(P) digitalWrite(P,HIGH)
-#define isHigh(P) (digitalRead(P) == HIGH)
-#define isLow(P) (digitalRead(P) == LOW)
-#define digitalState(P)((uint8_t)isHigh(P))
+bool hascc1101 = false;
 
 extern "C" {
 #include "user_interface.h"
 }
 
-
 os_timer_t cronTimer;
 
+// EEProm Address
+#define EE_MAGIC_OFFSET      0
+#define addr_features        0xff
 
 
-
-// EEProm Addresscommands
-#define addr_init 0
-#define addr_features 1
-#define MAX_SRV_CLIENTS 2
-
-
-
-//void handleInterrupt();
+void ICACHE_RAM_ATTR handleInterrupt();
 void enableReceive();
 void disableReceive();
 void serialEvent();
 void cronjob(void *pArg);
 int freeRam();
 void changeReciver();
+void changeFilter();
 void HandleCommand();
 bool command_available = false;
 unsigned long getUptime();
@@ -72,165 +123,115 @@
 void configCMD();
 void storeFunctions(const int8_t ms = 1, int8_t mu = 1, int8_t mc = 1);
 void getFunctions(bool *ms, bool *mu, bool *mc);
-
-
-#include <DNSServer.h>            //Local DNS Server used for redirecting all requests to the configuration portal
-#include <ESP8266WebServer.h>     //Local WebServer used to serve the configuration portal
-#include <WiFiManager.h>          //https://github.com/tzapu/WiFiManager
-
-bool startWPS() {
-	// from https://gist.github.com/copa2/fcc718c6549721c210d614a325271389
-	// wpstest.ino
-	Serial.println("WPS config start");
-	bool wpsSuccess = WiFi.beginWPSConfig();
-	if (wpsSuccess) {
-		// Well this means not always success :-/ in case of a timeout we have an empty ssid
-		String newSSID = WiFi.SSID();
-		if (newSSID.length() > 0) {
-			// WPSConfig has already connected in STA mode successfully to the new station. 
-			Serial.printf("WPS finished. Connected successfull to SSID '%s'\n", newSSID.c_str());
-		}
-		else {
-			wpsSuccess = false;
-		}
-	}
-	return wpsSuccess;
-}
-
+void initEEPROM(void);
+void changeReceiver();
+uint8_t cmdstringPos2int(uint8_t pos);
+void printHex2(const byte hex);
+uint8_t rssiCallback() { return 0; };	// Dummy return if no rssi value can be retrieved from receiver
 
 WiFiServer Server(23);  //  port 23 = telnet
 WiFiClient serverClient;
 
 void setup() {
-	//ESP.wdtEnable(2000);
-  Serial.begin(115200);
   
-  #ifdef DEBUG
-  Serial.printf("\nTry connecting to WiFi with SSID '%s'\n", WiFi.SSID().c_str());
-  #endif
-  WiFi.mode(WIFI_STA);
-  WiFi.begin(WiFi.SSID().c_str(), WiFi.psk().c_str()); // reading data from EPROM, 
-  while (WiFi.status() == WL_DISCONNECTED) {          // last saved credentials
-	  delay(500);
-	  Serial.print(".");
-  }
-  wl_status_t status = WiFi.status();
-  if (status == WL_CONNECTED) {
-  #ifdef DEBUG 
-	   Serial.printf("\nConnected successful to SSID '%s'\n", WiFi.SSID().c_str());
-  #endif
-  }
-  else {
-	Serial.printf("\nCould not connect to WiFi. state='%d'\n", status);
-	Serial.println("Please press WPS button on your router");
-	delay(5000);
-	if (!startWPS()) {
-		Serial.println("Failed to connect with WPS :-(");
-	}
-	else 
+	Serial.begin(BAUDRATE);
+	while (!Serial)
 	{
-		WiFi.begin(WiFi.SSID().c_str(), WiFi.psk().c_str()); // reading data from EPROM, 
-		while (WiFi.status() == WL_DISCONNECTED) {          // last saved credentials
-			delay(500);
-			Serial.print("."); // show wait for connect to AP
+    delay(200);
+		; // wait for serial port to connect. Needed for native USB
 	}
 
+  WiFiManager wifiManager;
+//  wifiManager.resetSettings();
+  wifiManager.autoConnect("AutoConnectAP");
 
-  }
+// if you get here you have connected to the WiFi
+  DBG_PRINTLN("connected....");
+  DBG_PRINTLN("Using sFIFO");
 
-  #ifdef DEBUG
-		Serial.print("\nReady! Use 'telnet ");
-	  Serial.print(WiFi.localIP());
-	  Serial.println(" port 23' to connect");
-  #endif
-  }
+	pinMode(PIN_RECEIVE, INPUT);
+	pinMode(PIN_LED, OUTPUT);
 
+  initEEPROM();
 
+	#ifdef CMP_cc1101
+  	DBG_PRINTLN(F("CCInit "));
 
-  WiFiManager wifiManager;
-  wifiManager.setBreakAfterConfig(true);
-  //reset settings - for testing
-  //wifiManager.resetSettings();
+	cc1101::CCinit();					 // cc1101 init
+	hascc1101 = cc1101::checkCC1101();	 // Check for cc1101
 
-  //tries to connect to last known settings
-  //if it does not connect it starts an access point with the specified name
-  //here  "NodeDuino" with no password
-  //and goes into a blocking loop awaiting configuration
-  if (!wifiManager.autoConnect("NodeDuino")) {
-    Serial.println("failed to connect, we should reset as see if it connects");
-    delay(3000);
-    ESP.reset();
-    delay(5000);
+	if (hascc1101)
+	{
+		DBG_PRINTLN("cc1101 found");
+		musterDec.setRSSICallback(&cc1101::getRSSI);                    // Provide the RSSI Callback
+	} else {
+		musterDec.setRSSICallback(&rssiCallback);	// Provide the RSSI Callback		
   }
+	#endif 
 
-  //if you get here you have connected to the WiFi
-  Serial.println("connected...)");
+	pinMode(PIN_SEND, OUTPUT);
+	DBG_PRINTLN("Starting timerjob");
+	delay(50);
+
+  os_timer_setfn(&cronTimer, cronjob, NULL);
+  os_timer_arm(&cronTimer, 31, true);
 
+//  Timer1.initialize(31*1000); //Interrupt wird jede n Millisekunden ausgeloest
+//	Timer1.attachInterrupt(cronjob);
 
-  Serial.println("local ip");
-  Serial.println(WiFi.localIP());
+//   musterDec.MSenabled = musterDec.MUenabled = musterDec.MCenabled = true;
 
+  Server.begin();  // telnet server
+  Server.setNoDelay(true);
 
-#ifdef DEBUG
-	Serial.println("Using sFIFO");
-#endif
-	//pinMode(PIN_RECEIVE, INPUT);
-	//pinMode(PIN_SEND, OUTPUT);
-	//pinMode(PIN_LED, OUTPUT);
-	os_timer_setfn(&cronTimer, cronjob, NULL);
-	os_timer_arm(&cronTimer, 31, true);
+ 	cmdstring.reserve(40);
 	
-	musterDec.MSenabled = musterDec.MUenabled = musterDec.MCenabled = true;
-	/*
-	if (EEPROM.read(addr_init) == 0xB)
-	{
-	#ifdef DEBUG
-	Serial.println("Reading values fom eeprom");
-	#endif
-	getFunctions(&musterDec.MSenabled, &musterDec.MUenabled, &musterDec.MCenabled);
+#ifdef CMP_cc1101
+ if (!hascc1101 || cc1101::regCheck()) {
+		enableReceive();
+		DBG_PRINTLN(F("receiver enabled"));
 	}
 	else {
-	EEPROM.write(addr_init, 0xB);
-	storeFunctions(1, 1, 1);    // Init EEPROM with all flags enabled
-	#ifdef DEBUG
-	Serial.println("Init eeprom to defaults after flash");
+		DBG_PRINTLN(F("cc1101 is not correctly set. Please do a factory reset via command e"));
+	}
+#else
+  enableReceive();
+  DBG_PRINTLN("enableReceive");
 	#endif
-	}*/
-	Server.begin();  // telnet server
-	Server.setNoDelay(true);
 
-	enableReceive();
-	cmdstring.reserve(20);
+ MSG_PRINTLN("Setup End");
 }
 
 void cronjob(void *pArg) {
+	 const unsigned long  duration = micros() - lastTime;
+	 if (duration > maxPulse) { //Auf Maximalwert pr�fen.
+		 int sDuration = maxPulse;
+		 if (isLow(PIN_RECEIVE)) { // Wenn jetzt low ist, ist auch weiterhin low
+			 sDuration = -sDuration;
+		 }
+		 FiFo.enqueue(sDuration);
 
+		 lastTime = micros();
+	 }
 	digitalWrite(PIN_LED, blinkLED);
 	blinkLED = false;
-
 }
 
-
-uint8_t fifousage = 0;
-
 void loop() {
 	static int aktVal = 0;
 	bool state;
+
 	serialEvent();
 	ethernetEvent();
-
-
-
 	if (command_available) {
 		command_available = false;
 		HandleCommand();
 		if (!command_available) { cmdstring = ""; }
 		blinkLED = true;
 	}
-	yield();
-	if (fifousage < FiFo.count()) fifousage = FiFo.count();
+//  yield();
+//	wdt_reset();
 	while (FiFo.count()>0) { //Puffer auslesen und an Dekoder uebergeben
-
 		aktVal = FiFo.dequeue();
 		state = musterDec.decode(&aktVal);
 		if (state) blinkLED = true; //LED blinken, wenn Meldung dekodiert
@@ -238,10 +239,8 @@
 	}
 }
 
-
-
 //========================= Pulseauswertung ================================================
-void handleInterrupt() {
+void ICACHE_RAM_ATTR handleInterrupt() {
 	const unsigned long Time = micros();
 	//const bool state = digitalRead(PIN_RECEIVE);
 	const unsigned long  duration = Time - lastTime;
@@ -250,30 +249,36 @@
 		int sDuration;
 		if (duration < maxPulse) {//groesste zulaessige Pulslaenge, max = 32000
 			sDuration = int(duration); //das wirft bereits hier unnoetige Nullen raus und vergroessert den Wertebereich
-		}
-		else {
+    }else {
 			sDuration = maxPulse; // Maximalwert set to maxPulse defined in lib.
 		}
 		if (isHigh(PIN_RECEIVE)) { // Wenn jetzt high ist, dann muss vorher low gewesen sein, und dafuer gilt die gemessene Dauer.
 			sDuration = -sDuration;
 		}
+	//MSG_PRINTLN(sDuration);
+ 
 		FiFo.enqueue(sDuration);
+
+    //++fifocnt;
 	} // else => trash
 
 }
 
 void enableReceive() {
-	attachInterrupt(PIN_RECEIVE, handleInterrupt, CHANGE);
-}
+   attachInterrupt(digitalPinToInterrupt(PIN_RECEIVE), handleInterrupt, CHANGE);
 
-void disableReceive() {
-	detachInterrupt(PIN_RECEIVE);
+   #ifdef CMP_cc1101
+    if (hascc1101) cc1101::setReceiveMode();
+   #endif
 }
 
+void disableReceive() {
+  detachInterrupt(digitalPinToInterrupt(PIN_RECEIVE));
 
-
-
-//============================== IT_Send =========================================
+  #ifdef CMP_cc1101
+   if (hascc1101) cc1101::setIdleMode();
+  #endif
+}
 
 //================================= RAW Send ======================================
 void send_raw(const uint8_t startpos, const uint16_t endpos, const int16_t *buckets, String *source = &cmdstring)
@@ -291,29 +296,22 @@
 		dur = abs(buckets[index]); 		//isLow ? dur = abs(buckets[index]) : dur = abs(buckets[index]);
 
 		while (stoptime > micros()) {
-			yield();
-			
+			;
 		}
 		isLow ? digitalLow(PIN_SEND) : digitalHigh(PIN_SEND);
 		stoptime += dur;
 	}
 	while (stoptime > micros()) {
-		yield();
+		;
 	}
 	//MSG_PRINTLN("");
 
 }
-//SM;R=2;C=400;D=AFAFAF;
-
-
-
 
 void send_mc(const uint8_t startpos, const uint8_t endpos, const int16_t clock)
 {
 	int8_t b;
 	char c;
-	//digitalHigh(PIN_SEND);
-	//delay(1);
 	uint8_t bit;
 
 	unsigned long stoptime = micros();
@@ -332,15 +330,10 @@
 				while (stoptime > micros())
 					yield();
 			}
-
 		}
-
 	}
-	// MSG_PRINTLN("");
 }
 
-
-
 bool split_cmdpart(int16_t *startpos, String *msg_part)
 {
 	int16_t endpos = 0;
@@ -352,11 +345,6 @@
 	*startpos = endpos + 1;    // Set startpos to endpos to extract next part
 	return true;
 }
-// SC;R=4;SM;C=400;D=AFFFFFFFFE;SR;P0=-2500;P1=400;D=010;SM;D=AB6180;SR;D=101;
-// SC;R=4;SM;C=400;D=FFFFFFFF;SR;P0=-400;P1=400;D=101;SM;D=AB6180;SR;D=101;
-// SR;R=3;P0=1230;P1=-3120;P2=-400;P3=-900;D=030301010101010202020202020101010102020202010101010202010120202;
-// SM;C=400;D=AAAAFFFF;
-// SR;R=10;P0=-2000;P1=-1000;P2=500;P3=-6000;D=2020202021212020202121212021202021202121212023;
 
 struct s_sendcmd {
 	int16_t sendclock;
@@ -384,14 +372,16 @@
 
 	s_sendcmd command[5];
 
+	uint8_t ccParamAnz = 0;   // Anzahl der per F= uebergebenen cc1101 Register
+	uint8_t ccReg[4];
+	uint8_t val;
+
 	disableReceive();
 
 	uint8_t cmdNo = 255;
 
-
 	while (split_cmdpart(&start_pos, &msg_part))
 	{
-		//MSG_PRINTLN(msg_part);
 		if (msg_part.charAt(0) == 'S')
 		{
 			if (msg_part.charAt(1) == 'C')  // send combined informatio flag
@@ -405,14 +395,12 @@
 				//type=manchester;
 				cmdNo++;
 				command[cmdNo].type = manchester;
-				//MSG_PRINTLN("Adding manchester");
 			}
 			else if (msg_part.charAt(1) == 'R') // send raw
 			{
 				//type=raw;
 				cmdNo++;
 				command[cmdNo].type = raw;
-				//MSG_PRINTLN("Adding raw");
 				extraDelay = false;
 
 			}
@@ -420,36 +408,43 @@
 		else if (msg_part.charAt(0) == 'P' && msg_part.charAt(2) == '=') // Do some basic detection if data matches what we expect
 		{
 			counter = msg_part.substring(1, 2).toInt(); // extract the pattern number
-														//buckets[counter]=  msg_part.substring(3).toInt();
 			command[cmdNo].buckets[counter] = msg_part.substring(3).toInt();
-			//MSG_PRINTLN("Adding bucket");
 
-		}
-		else if (msg_part.charAt(0) == 'R' && msg_part.charAt(1) == '=') {
+		} else if(msg_part.charAt(0) == 'R' && msg_part.charAt(1) == '=') {
 			repeats = msg_part.substring(2).toInt();
-			//MSG_PRINTLN("Adding repeats");
 
-		}
-		else if (msg_part.charAt(0) == 'D') {
+		} else if (msg_part.charAt(0) == 'D') {
 			command[cmdNo].datastart = start_pos - msg_part.length() + 1;
 			command[cmdNo].dataend = start_pos - 2;
-			//MSG_PRINT("locating data start:");
-			// MSG_PRINT(command[cmdNo].datastart);
-			//MSG_PRINT(" end:");
-			//MSG_PRINTLN(command[cmdNo].dataend);
-			//if (type==raw) send_raw(&msg_part,buckets);
-			//if (type==manchester) send_mc(&msg_part,sendclock);
-			//digitalWrite(PIN_SEND, LOW); // turn off transmitter
-			//digitalLow(PIN_SEND);
-		}
-		else if (msg_part.charAt(0) == 'C' && msg_part.charAt(1) == '=')
+		} else if(msg_part.charAt(0) == 'C' && msg_part.charAt(1) == '=')
 		{
-			//sendclock = msg_part.substring(2).toInt();
 			command[cmdNo].sendclock = msg_part.substring(2).toInt();
-			//MSG_PRINTLN("adding sendclock");
+		} else if(msg_part.charAt(0) == 'F' && msg_part.charAt(1) == '=')
+		{
+			ccParamAnz = msg_part.length() / 2 - 1;
+			
+			if (ccParamAnz > 0 && ccParamAnz <= 5 && hascc1101) {
+				uint8_t hex;
+				MSG_PRINT("write new ccreg  ");
+				for (uint8_t i=0;i<ccParamAnz;i++)
+				{
+					ccReg[i] = cc1101::readReg(0x0d + i, 0x80);    // alte Registerwerte merken
+					hex = (uint8_t)msg_part.charAt(2 + i*2);
+					val = cc1101::hex2int(hex) * 16;
+					hex = (uint8_t)msg_part.charAt(3 + i*2);
+					val = cc1101::hex2int(hex) + val;
+					cc1101::writeReg(0x0d + i, val);            // neue Registerwerte schreiben
+					printHex2(val);
+				}
+				MSG_PRINTLN("");
+			}
 		}
 	}
 
+	#ifdef CMP_cc1101
+	  if (hascc1101) cc1101::setTransmitMode();	
+	#endif
+
 	for (uint8_t i = 0; i<repeats; i++)
 	{
 		for (uint8_t c = 0; c <= cmdNo; c++)
@@ -461,23 +456,31 @@
 		if (extraDelay) delay(1);
 	}
 
+	if (ccParamAnz > 0) {
+		MSG_PRINT("ccreg write back ");
+		for (uint8_t i=0;i<ccParamAnz;i++)
+		{
+			val = ccReg[i];
+			printHex2(val);
+			cc1101::writeReg(0x0d + i, val);    // gemerkte Registerwerte zurueckschreiben
+		}
+		MSG_PRINTLN("");
+	}
+
 	enableReceive();	// enable the receiver
 	MSG_PRINTLN(cmdstring); // echo
-
 }
 
-
-
-
-
 //================================= Kommandos ======================================
+void IT_CMDs();
 
 void HandleCommand()
 {
+  uint8_t reg;
+  uint8_t val;
 
 #define  cmd_Version 'V'
 #define  cmd_freeRam 'R'
-#define  cmd_intertechno 'i'
 #define  cmd_uptime 't'
 #define  cmd_changeReceiver 'X'
 #define  cmd_space ' '
@@ -485,10 +488,14 @@
 #define  cmd_changeFilter 'F'
 #define  cmd_send 'S'
 #define  cmd_ping 'P'
-#define  cmd_config 'C'
-#define  cmd_getConfig 'G' //decrepated
-#define  cmd_buffer 'B'
+  #define  cmd_config 'C'     // CG get config, set config, C<reg> get cc1101 register
+  #define  cmd_write 'W'      // write EEPROM und write cc1101 register
+  #define  cmd_read  'r'      // read EEPROM
+  #define  cmd_patable 'x' 
+  #define  cmd_ccFactoryReset 'e'  // EEPROM / factory reset
 
+  DBG_PRINT("CMD: ");
+  DBG_PRINTLN(cmdstring);
 
 	if (cmdstring.charAt(0) == cmd_ping) {
 		getPing();
@@ -496,7 +503,6 @@
 	else if (cmdstring.charAt(0) == cmd_help) {
 		MSG_PRINT(cmd_help);	MSG_PRINT(F(" Use one of "));
 		MSG_PRINT(cmd_Version); MSG_PRINT(cmd_space);
-		MSG_PRINT(cmd_intertechno); MSG_PRINT(cmd_space);
 		MSG_PRINT(cmd_freeRam); MSG_PRINT(cmd_space);
 		MSG_PRINT(cmd_uptime); MSG_PRINT(cmd_space);
 		MSG_PRINT(cmd_changeReceiver); MSG_PRINT(cmd_space);
@@ -504,33 +510,32 @@
 		MSG_PRINT(cmd_send); MSG_PRINT(cmd_space);
 		MSG_PRINT(cmd_ping); MSG_PRINT(cmd_space);
 		MSG_PRINT(cmd_config); MSG_PRINT(cmd_space);
-		MSG_PRINT(cmd_getConfig); MSG_PRINT(cmd_space);  //decrepated
-		MSG_PRINT(cmd_buffer); MSG_PRINT(cmd_space);  //decrepated
-
+	MSG_PRINT(cmd_read);MSG_PRINT(cmd_space);
+	MSG_PRINT(cmd_write);MSG_PRINT(cmd_space);
+	if (hascc1101) {
+		MSG_PRINT(cmd_patable);MSG_PRINT(cmd_space);
+		MSG_PRINT(cmd_ccFactoryReset);MSG_PRINT(cmd_space);
+	}
 		MSG_PRINTLN("");
 	}
 	// V: Version
 	else if (cmdstring.charAt(0) == cmd_Version) {
-		MSG_PRINTLN("V " PROGVERS " SIGNALESP - compiled at " __DATE__ " " __TIME__);
+	  MSG_PRINT("V " PROGVERS " SIGNALduino ");
+	  if (hascc1101) {
+		MSG_PRINT(F("cc1101 "));
+      }
+	MSG_PRINTLN("- compiled at " __DATE__ " " __TIME__)
+
 	}
 	// R: FreeMemory
 	else if (cmdstring.charAt(0) == cmd_freeRam) {
-
 		MSG_PRINTLN(freeRam());
 	}
-	// i: Intertechno
-	else if (cmdstring.charAt(0) == cmd_intertechno) {
-		if (musterDec.getState() != searching)
-		{
-			command_available = true;
-		}
-	}
 	else if (cmdstring.charAt(0) == cmd_send) {
 		if (musterDec.getState() != searching)
 		{
 			command_available = true;
-		}
-		else {
+	} else {
 			send_cmd(); // Part of Send
 		}
 	}
@@ -540,24 +545,89 @@
 	}
 	// XQ disable receiver
 	else if (cmdstring.charAt(0) == cmd_changeReceiver) {
-		changeReciver();
+    changeReceiver();
 	}
 	else if (cmdstring.charAt(0) == cmd_changeFilter) {
 	}
 	else if (cmdstring.charAt(0) == cmd_config) {
+    if (cmdstring.charAt(1) == 'G') {
+      getConfig();
+    }
+    else if (cmdstring.charAt(1) == 'E' || cmdstring.charAt(1) == 'D') {  //Todo:  E und D sind auch hexadezimal, werden hier aber abgefangen
 		configCMD();
 	}
-	// get config
-	else if (cmdstring.charAt(0) == cmd_getConfig) {
-		getConfig();
+    else if (isHexadecimalDigit(cmdstring.charAt(1)) && isHexadecimalDigit(cmdstring.charAt(2)) && hascc1101) {
+      reg = cmdstringPos2int(1);
+      cc1101::readCCreg(reg);
+    }
+    else {
+      MSG_PRINTLN(F("Unsupported command"));
+    }
+  }
+  else if (cmdstring.charAt(0) == cmd_write) {            // write EEPROM und CC11001 register
+    if (cmdstring.charAt(1) == 'S' && cmdstring.charAt(2) == '3' && hascc1101)  {       // WS<reg>  Command Strobes
+        cc1101::commandStrobes();
+    } else if (isHexadecimalDigit(cmdstring.charAt(1)) && isHexadecimalDigit(cmdstring.charAt(2)) && isHexadecimalDigit(cmdstring.charAt(3)) && isHexadecimalDigit(cmdstring.charAt(4))) {
+         reg = cmdstringPos2int(1);
+         val = cmdstringPos2int(3);
+         EEPROM.begin(512); //Max bytes of eeprom to use
+         yield();
+         EEPROM.write(reg, val);  
+         EEPROM.commit();
+         EEPROM.end();
+         if (hascc1101) {
+           cc1101::writeCCreg(reg, val);
+         }
+    } else {
+         MSG_PRINTLN(F("Unsupported command"));
+    }
+  }
+  // R<adr>  read EEPROM
+  else if (cmdstring.charAt(0) == cmd_read && isHexadecimalDigit(cmdstring.charAt(1)) && isHexadecimalDigit(cmdstring.charAt(2))) {             // R<adr>  read EEPROM
+     reg = cmdstringPos2int(1);
+     MSG_PRINT(F("EEPROM "));
+     printHex2(reg);
+     EEPROM.begin(512); //Max bytes of eeprom to use
+     yield();
+     if (cmdstring.charAt(3) == 'n') {
+         MSG_PRINT(F(" :"));
+         for (uint8_t i = 0; i < 16; i++) {
+             MSG_PRINT(" ");
+             printHex2(EEPROM.read(reg + i));
 	}
-	else if (cmdstring.charAt(0) == cmd_buffer) {
-		MSG_PRINTLN(fifousage);
 	} else {
+        MSG_PRINT(F(" = "));
+        printHex2(EEPROM.read(reg));
+     }
+     MSG_PRINTLN("");
+     EEPROM.end();
+  }
+  else if (cmdstring.charAt(0) == cmd_patable && isHexadecimalDigit(cmdstring.charAt(1)) && isHexadecimalDigit(cmdstring.charAt(2)) && hascc1101) {
+     val = cmdstringPos2int(1);
+     cc1101::writeCCpatable(val);
+     MSG_PRINT(F("Write "));
+     printHex2(val);
+     MSG_PRINTLN(F(" to PATABLE done"));
+  }
+  else if (cmdstring.charAt(0) == cmd_ccFactoryReset && hascc1101) { 
+     cc1101::ccFactoryReset();
+     cc1101::CCinit();
+  }
+  else {
 		MSG_PRINTLN(F("Unsupported command"));
 	}
 }
 
+uint8_t cmdstringPos2int(uint8_t pos) {
+  uint8_t val;
+  uint8_t hex;
+  
+       hex = (uint8_t)cmdstring.charAt(pos);
+       val = cc1101::hex2int(hex) * 16;
+       hex = (uint8_t)cmdstring.charAt(pos+1);
+       val = cc1101::hex2int(hex) + val;
+       return val;
+}
 
 void getConfig()
 {
@@ -586,11 +656,6 @@
 
 void configCMD()
 {
-	if (cmdstring.charAt(1) == 'G') {  // Get, no change to configuration
-		getConfig();
-		return;
-	}
-
 	bool *bptr;
 
 	if (cmdstring.charAt(2) == 'S') {  	  //MS
@@ -608,14 +673,12 @@
 	}
 	else if (cmdstring.charAt(1) == 'D') {  // Disable
 		*bptr = false;
-	}
-	else {
+  } else {
 		return;
 	}
 	storeFunctions(musterDec.MSenabled, musterDec.MUenabled, musterDec.MCenabled);
 }
 
-
 inline void ethernetEvent()
 {
 	//check if there are any new clients
@@ -626,11 +689,7 @@
 			DBG_PRINTLN("New client: ");
 			return;
 		}
-		//no free/disconnected spot so reject
-//		WiFiClient newClient = Server.available();
-//		newClient.stop();
 	}
-
 }
 
 void serialEvent()
@@ -653,12 +712,8 @@
 	}
 }
 
-
 int freeRam() {
-
 	return system_get_free_heap_size();
-	
-
 }
 
 unsigned long getUptime()
@@ -682,7 +737,7 @@
 	yield();
 }
 
-void changeReciver() {
+void changeReceiver() {
 	if (cmdstring.charAt(1) == 'Q')
 	{
 		disableReceive();
@@ -693,31 +748,60 @@
 	}
 }
 
-
-
-
-
+  void printHex2(const byte hex) {   // Todo: printf oder scanf nutzen
+    if (hex < 16) {
+      MSG_PRINT("0");
+    }
+    MSG_PRINT(hex, HEX);
+  }
 
 //================================= EEProm commands ======================================
 
-
-
 void storeFunctions(const int8_t ms, int8_t mu, int8_t mc)
 {
 	mu = mu << 1;
 	mc = mc << 2;
+  EEPROM.begin(512); //Max bytes of eeprom to use
+  yield();
+
 	int8_t dat = ms | mu | mc;
 	EEPROM.write(addr_features, dat);
+    EEPROM.commit();
+    EEPROM.end(); 
 }
 
 void getFunctions(bool *ms, bool *mu, bool *mc)
 {
+    EEPROM.begin(512); //Max bytes of eeprom to use
+    yield();
+    
 	int8_t dat = EEPROM.read(addr_features);
 
 	*ms = bool(dat &(1 << 0));
 	*mu = bool(dat &(1 << 1));
 	*mc = bool(dat &(1 << 2));
+    EEPROM.end();     
+}
 
-
+void initEEPROM(void) {
+  EEPROM.begin(512); //Max bytes of eeprom to use
+  yield();
+  if (EEPROM.read(EE_MAGIC_OFFSET) == VERSION_1 && EEPROM.read(EE_MAGIC_OFFSET+1) == VERSION_2) {
+    DBG_PRINTLN("Reading values fom eeprom");
+  } else {
+     storeFunctions(1, 1, 1);    // Init EEPROM with all flags enabled
+    //hier fehlt evtl ein getFunctions()
+    DBG_PRINTLN("Init eeprom to defaults after flash");
+     EEPROM.write(EE_MAGIC_OFFSET, VERSION_1);
+     EEPROM.write(EE_MAGIC_OFFSET+1, VERSION_2);
+    // if (hascc1101) {                // der ccFactoryReset muss auch durchgefuehrt werden, wenn der cc1101 nicht erkannt wurde
+    cc1101::ccFactoryReset();
+    //}
+  }
+  EEPROM.commit();
+  EEPROM.end(); 
+  getFunctions(&musterDec.MSenabled, &musterDec.MUenabled, &musterDec.MCenabled);
 }
 
+
+
diff -ruwN ./SIGNALESP.vcxproj ../../trebron106/SIGNALEsp-20170510/SIGNALESP.vcxproj
--- ./SIGNALESP.vcxproj	2017-08-17 12:43:36.538057925 +0200
+++ ../../trebron106/SIGNALEsp-20170510/SIGNALESP.vcxproj	1970-01-01 01:00:00.000000000 +0100
@@ -1,104 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup Label="ProjectConfigurations">
-    <ProjectConfiguration Include="Debug|Win32">
-      <Configuration>Debug</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-    <ProjectConfiguration Include="Release|Win32">
-      <Configuration>Release</Configuration>
-      <Platform>Win32</Platform>
-    </ProjectConfiguration>
-  </ItemGroup>
-  <PropertyGroup Label="Globals">
-    <ProjectGuid>{C5F80730-F44F-4478-BDAE-6634EFC2CA88}</ProjectGuid>
-    <RootNamespace>SIGNALESP</RootNamespace>
-    <ProjectName>SIGNALESP</ProjectName>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>true</UseDebugLibraries>
-    <PlatformToolset>v140</PlatformToolset>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'" Label="Configuration">
-    <ConfigurationType>Application</ConfigurationType>
-    <UseDebugLibraries>false</UseDebugLibraries>
-    <PlatformToolset>v140</PlatformToolset>
-    <WholeProgramOptimization>true</WholeProgramOptimization>
-    <CharacterSet>MultiByte</CharacterSet>
-  </PropertyGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
-  <ImportGroup Label="ExtensionSettings">
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
-  </ImportGroup>
-  <PropertyGroup Label="UserMacros" />
-  <PropertyGroup />
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|Win32'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src\utility;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries\EEPROM;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries\EEPROM\utility;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src\utility;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src\utility;z:\Programme\Arduino\libraries;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries;Z:\Programme\visual studio 2015\Common7\IDE\Extensions\ov4gogvo.2y3\Micro Platforms\default\debuggers;Z:\Benutzer\Sven\Documents\Arduino\libraries;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0/tools/sdk/include;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries\EEPROM;z:\Programme\Arduino\libraries;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries;Z:\Programme\visual studio 2015\Common7\IDE\Extensions\ov4gogvo.2y3\Micro Platforms\default\debuggers;Z:\Benutzer\Sven\Documents\Arduino\libraries;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\xtensa-lx106-elf\include\c++\4.8.2;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\xtensa-lx106-elf\include\c++\4.8.2\xtensa-lx106-elf;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\xtensa-lx106-elf\include;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\lib\gcc\xtensa-lx106-elf\4.8.2\include;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\tools\sdk\include;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <ForcedIncludeFiles>Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP\__vm\.SIGNALESP.vsarduino.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
-      <IgnoreStandardIncludePath>false</IgnoreStandardIncludePath>
-      <PreprocessorDefinitions>__ESP8266_ESp8266__;__ESP8266_ESP8266__;__ets__;ICACHE_FLASH;F_CPU=80000000L;ARDUINO=10607;ARDUINO_ESP8266_ESP12;ARDUINO_ARCH_ESP8266;ESP8266;__cplusplus=201103L;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|Win32'">
-    <ClCompile>
-      <WarningLevel>Level3</WarningLevel>
-      <Optimization>Disabled</Optimization>
-      <FunctionLevelLinking>true</FunctionLevelLinking>
-      <IntrinsicFunctions>true</IntrinsicFunctions>
-      <SDLCheck>true</SDLCheck>
-      <AdditionalIncludeDirectories>Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\DNSServer\src;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\EEPROM;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\ESP8266WebServer\src;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\ESP8266WiFi\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALDuino\src\_micro-api\libraries\output\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\WIFIManager;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src\utility;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\DNSServer\src\utility;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\EEPROM\utility;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\ESP8266WebServer\src\utility;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\ESP8266WiFi\src\utility;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALDuino\src\_micro-api\libraries\output\src\utility;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src\utility;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src\utility;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\WIFIManager\utility;z:\Programme\Arduino\libraries;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries;Z:\Benutzer\Sven\Documents\Arduino\libraries;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266\libb64;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266\spiffs;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266\umm_malloc;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\variants\nodemcu;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0/tools/sdk/include;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0/tools/sdk/lwip/include;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2/core;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\DNSServer\src;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\EEPROM;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\ESP8266WebServer\src;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries\ESP8266WiFi\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALDuino\src\_micro-api\libraries\output\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\WIFIManager;z:\Programme\Arduino\libraries;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\libraries;Z:\Programme\visual studio 2015\Common7\IDE\Extensions\1leckq1b.pja\Micro Platforms\default\debuggers;Z:\Benutzer\Sven\Documents\Arduino\libraries;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\variants\nodemcu;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\xtensa-lx106-elf\include\c++\4.8.2;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\xtensa-lx106-elf\include\c++\4.8.2\xtensa-lx106-elf;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\xtensa-lx106-elf\include;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\lib\gcc\xtensa-lx106-elf\4.8.2\include;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\tools\sdk\include;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALDuino\src\_micro-api\libraries\output\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\WIFIManager;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
-      <ForcedIncludeFiles>Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP\__vm\.SIGNALESP.vsarduino.h;%(ForcedIncludeFiles)</ForcedIncludeFiles>
-      <WholeProgramOptimization>false</WholeProgramOptimization>
-      <PreprocessorDefinitions>__ESP8266_ESp8266__;__ESP8266_ESP8266__;__ets__;ICACHE_FLASH;F_CPU=80000000L;ARDUINO=10607;ARDUINO_ESP8266_ESP12;ARDUINO_ARCH_ESP8266;ESP8266;__cplusplus=201103L;%(PreprocessorDefinitions)</PreprocessorDefinitions>
-    </ClCompile>
-    <Link>
-      <GenerateDebugInformation>true</GenerateDebugInformation>
-      <EnableCOMDATFolding>true</EnableCOMDATFolding>
-      <OptimizeReferences>true</OptimizeReferences>
-    </Link>
-  </ItemDefinitionGroup>
-  <ItemGroup>
-    <None Include="SIGNALESP.ino">
-      <FileType>CppCode</FileType>
-    </None>
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="..\..\SIGNALDuino\src\_micro-api\libraries\output\src\output.h" />
-    <ClInclude Include="..\src\_micro-api\libraries\bitstore\src\bitstore.h" />
-    <ClInclude Include="..\src\_micro-api\libraries\signalDecoder\src\signalDecoder.h" />
-    <ClInclude Include="..\src\_micro-api\libraries\SimpleFIFO\src\SimpleFIFO.h" />
-    <ClInclude Include="..\src\_micro-api\libraries\WIFIManager\WiFiManager.h" />
-    <ClInclude Include="configwifi.h" />
-    <ClInclude Include="__vm\.SIGNALESP.vsarduino.h" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\..\SIGNALDuino\src\_micro-api\libraries\output\src\output.cpp" />
-    <ClCompile Include="..\src\_micro-api\libraries\bitstore\src\bitstore.cpp" />
-    <ClCompile Include="..\src\_micro-api\libraries\signalDecoder\src\signalDecoder.cpp" />
-    <ClCompile Include="..\src\_micro-api\libraries\SimpleFIFO\src\SimpleFIFO.cpp" />
-    <ClCompile Include="..\src\_micro-api\libraries\WIFIManager\WiFiManager.cpp" />
-  </ItemGroup>
-  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
-  <ImportGroup Label="ExtensionTargets">
-  </ImportGroup>
-  <ProjectExtensions>
-    <VisualStudio>
-      <UserProperties arduino.upload.maximum_size="1044464" arduino.upload.speed="115200" visualmicro.package.name="esp8266" arduino.board.property_bag="name=NodeMCU 1.0 (ESP-12E Module)&#xD;&#xA;upload.tool=esptool&#xD;&#xA;upload.speed=115200&#xD;&#xA;upload.resetmethod=nodemcu&#xD;&#xA;upload.maximum_size=1044464&#xD;&#xA;upload.maximum_data_size=81920&#xD;&#xA;upload.wait_for_upload_port=true&#xD;&#xA;serial.disableDTR=true&#xD;&#xA;serial.disableRTS=true&#xD;&#xA;build.mcu=esp8266&#xD;&#xA;build.f_cpu=80000000L&#xD;&#xA;build.board=ESP8266_ESP12&#xD;&#xA;build.core=esp8266&#xD;&#xA;build.variant=nodemcu&#xD;&#xA;build.flash_mode=dio&#xD;&#xA;build.flash_size=4M&#xD;&#xA;build.flash_freq=40&#xD;&#xA;build.debug_port=&#xD;&#xA;build.debug_level=&#xD;&#xA;menu.CpuFrequency.80=80 MHz&#xD;&#xA;menu.CpuFrequency.80.build.f_cpu=80000000L&#xD;&#xA;menu.CpuFrequency.160=160 MHz&#xD;&#xA;menu.CpuFrequency.160.build.f_cpu=160000000L&#xD;&#xA;menu.UploadTool.esptool=Serial&#xD;&#xA;menu.UploadTool.esptool.upload.tool=esptool&#xD;&#xA;menu.UploadTool.esptool.upload.verbose=-vv&#xD;&#xA;menu.UploadTool.espota=OTA&#xD;&#xA;menu.UploadTool.espota.upload.tool=espota&#xD;&#xA;menu.UploadSpeed.115200=115200&#xD;&#xA;menu.UploadSpeed.115200.upload.speed=115200&#xD;&#xA;menu.UploadSpeed.9600=9600&#xD;&#xA;menu.UploadSpeed.9600.upload.speed=9600&#xD;&#xA;menu.UploadSpeed.57600=57600&#xD;&#xA;menu.UploadSpeed.57600.upload.speed=57600&#xD;&#xA;menu.UploadSpeed.256000.windows=256000&#xD;&#xA;menu.UploadSpeed.256000.upload.speed=256000&#xD;&#xA;menu.UploadSpeed.230400.linux=230400&#xD;&#xA;menu.UploadSpeed.230400.macosx=230400&#xD;&#xA;menu.UploadSpeed.230400.upload.speed=230400&#xD;&#xA;menu.UploadSpeed.460800.linux=460800&#xD;&#xA;menu.UploadSpeed.460800.macosx=460800&#xD;&#xA;menu.UploadSpeed.460800.upload.speed=460800&#xD;&#xA;menu.UploadSpeed.512000.windows=512000&#xD;&#xA;menu.UploadSpeed.512000.upload.speed=512000&#xD;&#xA;menu.UploadSpeed.921600=921600&#xD;&#xA;menu.UploadSpeed.921600.upload.speed=921600&#xD;&#xA;menu.FlashSize.4M3M=4M (3M SPIFFS)&#xD;&#xA;menu.FlashSize.4M3M.build.flash_size=4M&#xD;&#xA;menu.FlashSize.4M3M.build.flash_ld=eagle.flash.4m.ld&#xD;&#xA;menu.FlashSize.4M3M.build.spiffs_start=0x100000&#xD;&#xA;menu.FlashSize.4M3M.build.spiffs_end=0x3FB000&#xD;&#xA;menu.FlashSize.4M3M.build.spiffs_blocksize=8192&#xD;&#xA;menu.FlashSize.4M3M.build.spiffs_pagesize=256&#xD;&#xA;menu.FlashSize.4M1M=4M (1M SPIFFS)&#xD;&#xA;menu.FlashSize.4M1M.build.flash_size=4M&#xD;&#xA;menu.FlashSize.4M1M.build.flash_ld=eagle.flash.4m1m.ld&#xD;&#xA;menu.FlashSize.4M1M.build.spiffs_start=0x300000&#xD;&#xA;menu.FlashSize.4M1M.build.spiffs_end=0x3FB000&#xD;&#xA;menu.FlashSize.4M1M.build.spiffs_blocksize=8192&#xD;&#xA;menu.FlashSize.4M1M.build.spiffs_pagesize=256&#xD;&#xA;menu.UploadSpeed.256000=256000&#xD;&#xA;menu.UploadSpeed.512000=512000&#xD;&#xA;runtime.ide.path=z:\Programme\Arduino&#xD;&#xA;build.system.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\system&#xD;&#xA;runtime.ide.version=10607&#xD;&#xA;target_package=esp8266&#xD;&#xA;target_platform=esp8266&#xD;&#xA;runtime.hardware.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266&#xD;&#xA;originalid=nodemcuv2&#xD;&#xA;intellisense.tools.path={compiler.toolchain.path}&#xD;&#xA;intellisense.include.paths={runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include\c++\4.8.2;{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include\c++\4.8.2\xtensa-lx106-elf;{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include;{runtime.tools.xtensa-lx106-elf-gcc.path}\lib\gcc\xtensa-lx106-elf\4.8.2\include;{runtime.platform.path}\tools\sdk\include&#xD;&#xA;version=2.1.0&#xD;&#xA;compiler.warning_flags=-w&#xD;&#xA;compiler.warning_flags.none=-w&#xD;&#xA;compiler.warning_flags.default=&#xD;&#xA;compiler.warning_flags.more=-Wall&#xD;&#xA;compiler.warning_flags.all=-Wall -Wextra&#xD;&#xA;compiler.path={runtime.tools.xtensa-lx106-elf-gcc.path}/bin/&#xD;&#xA;compiler.sdk.path={runtime.platform.path}/tools/sdk&#xD;&#xA;compiler.cpreprocessor.flags=-D__ets__ -DICACHE_FLASH -U__STRICT_ANSI__ &quot;-I{compiler.sdk.path}/include&quot;&#xD;&#xA;compiler.c.cmd=xtensa-lx106-elf-gcc&#xD;&#xA;compiler.c.flags=-c {compiler.warning_flags} -Os -g -Wpointer-arith -Wno-implicit-function-declaration -Wl,-EL -fno-inline-functions -nostdlib -mlongcalls -mtext-section-literals -falign-functions=4 -MMD -std=gnu99 -ffunction-sections -fdata-sections&#xD;&#xA;compiler.S.cmd=xtensa-lx106-elf-gcc&#xD;&#xA;compiler.S.flags=-c -g -x assembler-with-cpp -MMD -mlongcalls&#xD;&#xA;compiler.c.elf.flags=-g {compiler.warning_flags} -Os -nostdlib -Wl,--no-check-sections -u call_user_start -Wl,-static &quot;-L{compiler.sdk.path}/lib&quot; &quot;-L{compiler.sdk.path}/ld&quot; &quot;-T{build.flash_ld}&quot; -Wl,--gc-sections -Wl,-wrap,system_restart_local -Wl,-wrap,register_chipv6_phy&#xD;&#xA;compiler.c.elf.cmd=xtensa-lx106-elf-gcc&#xD;&#xA;compiler.c.elf.libs=-lm -lgcc -lhal -lphy -lpp -lnet80211 -llwip -lwpa -lcrypto -lmain -lwps -laxtls -lsmartconfig -lmesh -lwpa2&#xD;&#xA;compiler.cpp.cmd=xtensa-lx106-elf-g++&#xD;&#xA;compiler.cpp.flags=-c {compiler.warning_flags} -Os -g -mlongcalls -mtext-section-literals -fno-exceptions -fno-rtti -falign-functions=4 -std=c++11 -MMD -ffunction-sections -fdata-sections&#xD;&#xA;compiler.as.cmd=xtensa-lx106-elf-as&#xD;&#xA;compiler.ar.cmd=xtensa-lx106-elf-ar&#xD;&#xA;compiler.ar.flags=cru&#xD;&#xA;compiler.elf2hex.cmd=esptool&#xD;&#xA;compiler.elf2hex.flags=&#xD;&#xA;compiler.size.cmd=xtensa-lx106-elf-size&#xD;&#xA;compiler.esptool.cmd=esptool.exe&#xD;&#xA;compiler.esptool.cmd.windows=esptool.exe&#xD;&#xA;build.extra_flags=-DESP8266&#xD;&#xA;compiler.c.extra_flags=&#xD;&#xA;compiler.c.elf.extra_flags=&#xD;&#xA;compiler.S.extra_flags=&#xD;&#xA;compiler.cpp.extra_flags=&#xD;&#xA;compiler.ar.extra_flags=&#xD;&#xA;compiler.objcopy.eep.extra_flags=&#xD;&#xA;compiler.elf2hex.extra_flags=&#xD;&#xA;recipe.c.o.pattern=&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.c.flags} -DF_CPU={build.f_cpu} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;&#xD;&#xA;recipe.cpp.o.pattern=&quot;{compiler.path}{compiler.cpp.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.cpp.flags} -DF_CPU={build.f_cpu} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.cpp.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;&#xD;&#xA;recipe.S.o.pattern=&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.S.flags} -DF_CPU={build.f_cpu} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;&#xD;&#xA;recipe.ar.pattern=&quot;{compiler.path}{compiler.ar.cmd}&quot; {compiler.ar.flags} {compiler.ar.extra_flags} &quot;{archive_file_path}&quot; &quot;{object_file}&quot;&#xD;&#xA;recipe.c.combine.pattern=&quot;{compiler.path}{compiler.c.elf.cmd}&quot; {compiler.c.elf.flags} {compiler.c.elf.extra_flags} -o &quot;{build.path}/{build.project_name}.elf&quot; -Wl,--start-group {object_files} &quot;{build.path}/{archive_file}&quot; {compiler.c.elf.libs} -Wl,--end-group  &quot;-L{build.path}&quot;&#xD;&#xA;recipe.objcopy.eep.pattern=&#xD;&#xA;recipe.objcopy.hex.pattern=&quot;{runtime.tools.esptool.path}/{compiler.esptool.cmd}&quot; -eo &quot;{runtime.platform.path}/bootloaders/eboot/eboot.elf&quot; -bo &quot;{build.path}/{build.project_name}.bin&quot; -bm {build.flash_mode} -bf {build.flash_freq} -bz {build.flash_size} -bs .text -bp 4096 -ec -eo &quot;{build.path}/{build.project_name}.elf&quot; -bs .irom0.text -bs .text -bs .data -bs .rodata -bc -ec&#xD;&#xA;recipe.output.tmp_file={build.project_name}.bin&#xD;&#xA;recipe.output.save_file={build.project_name}.{build.variant}.bin&#xD;&#xA;recipe.size.pattern=&quot;{compiler.path}{compiler.size.cmd}&quot; -A &quot;{build.path}/{build.project_name}.elf&quot;&#xD;&#xA;recipe.size.regex=^(?:\.irom0\.text|\.text|\.data|\.rodata|)\s+([0-9]+).*&#xD;&#xA;recipe.size.regex.data=^(?:\.data|\.rodata|\.bss)\s+([0-9]+).*&#xD;&#xA;tools.esptool.cmd=esptool.exe&#xD;&#xA;tools.esptool.cmd.windows=esptool.exe&#xD;&#xA;tools.esptool.path={runtime.tools.esptool.path}&#xD;&#xA;tools.esptool.network_cmd=python.exe&#xD;&#xA;tools.esptool.network_cmd.windows=python.exe&#xD;&#xA;tools.esptool.upload.protocol=esp&#xD;&#xA;tools.esptool.upload.params.verbose=-vv&#xD;&#xA;tools.esptool.upload.params.quiet=&#xD;&#xA;tools.esptool.upload.pattern=&quot;{path}/{cmd}&quot; {upload.verbose} -cd {upload.resetmethod} -cb {upload.speed} -cp &quot;{serial.port}&quot; -ca 0x00000 -cf &quot;{build.path}/{build.project_name}.bin&quot;&#xD;&#xA;tools.esptool.upload.network_pattern=&quot;{network_cmd}&quot; &quot;{runtime.platform.path}/tools/espota.py&quot; -i &quot;{serial.port}&quot; -p &quot;{network.port}&quot; &quot;--auth={network.password}&quot; -f &quot;{build.path}/{build.project_name}.bin&quot;&#xD;&#xA;tools.mkspiffs.cmd=mkspiffs.exe&#xD;&#xA;tools.mkspiffs.cmd.windows=mkspiffs.exe&#xD;&#xA;tools.mkspiffs.path={runtime.tools.mkspiffs.path}&#xD;&#xA;tools.espota.cmd=python.exe&#xD;&#xA;tools.espota.cmd.windows=python.exe&#xD;&#xA;tools.espota.path={runtime.platform.path}/tools&#xD;&#xA;tools.espota.upload.protocol=espota&#xD;&#xA;tools.espota.upload.params.verbose=&#xD;&#xA;tools.espota.upload.params.quiet=&#xD;&#xA;tools.espota.upload.pattern=&quot;{cmd}&quot; &quot;{path}/espota.py&quot; -i &quot;{serial.port}&quot; -p 8266 -f &quot;{build.path}/{build.project_name}.bin&quot;&#xD;&#xA;vm.platform.root.path=Z:\Programme\visual studio 2015\Common7\IDE\Extensions\ov4gogvo.2y3\Micro Platforms\arduino16x&#xD;&#xA;runtime.tools.avrdude.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\arduino\tools\avrdude\6.0.1-arduino5&#xD;&#xA;runtime.tools.avrdude-6.0.1-arduino5.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\arduino\tools\avrdude\6.0.1-arduino5&#xD;&#xA;runtime.tools.avr-gcc.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\arduino\tools\avr-gcc\4.8.1-arduino5&#xD;&#xA;runtime.tools.avr-gcc-4.8.1-arduino5.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\arduino\tools\avr-gcc\4.8.1-arduino5&#xD;&#xA;runtime.tools.esptool.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\esptool\0.4.8&#xD;&#xA;runtime.tools.esptool-0.4.8.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\esptool\0.4.8&#xD;&#xA;runtime.tools.mkspiffs.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\mkspiffs\0.1.2&#xD;&#xA;runtime.tools.mkspiffs-0.1.2.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\mkspiffs\0.1.2&#xD;&#xA;runtime.tools.xtensa-lx106-elf-gcc.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2&#xD;&#xA;runtime.tools.xtensa-lx106-elf-gcc-1.20.0-26-gb404fb9-2.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2&#xD;&#xA;ide.hint=For use with Arduino.cc 1.6.2+ ide&#xD;&#xA;ide.location.key=Arduino16x&#xD;&#xA;ide.location.ide.winreg=Arduino 1.6.x Application&#xD;&#xA;ide.location.sketchbook.winreg=Arduino 1.6.x Sketchbook&#xD;&#xA;ide.location.sketchbook.preferences=sketchbook.path&#xD;&#xA;ide.default.revision_name=1.6.7&#xD;&#xA;ide.default.version=10607&#xD;&#xA;ide.default.package=arduino&#xD;&#xA;ide.default.platform=avr&#xD;&#xA;ide.multiplatform=true&#xD;&#xA;ide.includes=arduino.h&#xD;&#xA;ide.exe_name=arduino&#xD;&#xA;ide.platformswithoutpackage=false&#xD;&#xA;ide.includes.fallback=wprogram.h&#xD;&#xA;ide.extension=ino&#xD;&#xA;ide.extension.fallback=pde&#xD;&#xA;ide.versionGTEQ=160&#xD;&#xA;ide.exe=arduino.exe&#xD;&#xA;ide.hosts=atmel&#xD;&#xA;ide.url=http://arduino.cc/en/Main/Software&#xD;&#xA;ide.help.reference.path=reference\arduino.cc\en\Reference&#xD;&#xA;ide.help.reference.path2=reference\www.arduino.cc\en\Reference&#xD;&#xA;ide.help.reference.serial=reference\www.arduino.cc\en\Serial&#xD;&#xA;vm.debug=true&#xD;&#xA;software=ARDUINO&#xD;&#xA;ssh.user.name=root&#xD;&#xA;ssh.user.default.password=arduino&#xD;&#xA;ssh.host.wwwfiles.path=/www/sd&#xD;&#xA;build.working_directory={runtime.ide.path}&#xD;&#xA;ide.location.preferences.portable={runtime.ide.path}\portable&#xD;&#xA;ide.location.preferences=%VM_APPDATA_LOCAL%\arduino15\preferences.txt&#xD;&#xA;ide.location.preferences_fallback=%VM_APPDATA_ROAMING%\arduino15\preferences.txt&#xD;&#xA;ide.location.contributions=%VM_APPDATA_LOCAL%\arduino15&#xD;&#xA;ide.location.contributions_fallback=%VM_APPDATA_ROAMING%\arduino15&#xD;&#xA;ide.contributions.boards.allow=true&#xD;&#xA;ide.contributions.boards.ignore_unless_rewrite_found=true&#xD;&#xA;ide.contributions.libraries.allow=true&#xD;&#xA;ide.contributions.boards.support.urls.wiki=https://github.com/arduino/Arduino/wiki/Unofficial-list-of-3rd-party-boards-support-urls&#xD;&#xA;ide.create_platforms_from_boardsTXT.teensy=build.core&#xD;&#xA;ide.appid=arduino16x&#xD;&#xA;location.sketchbook=Z:\Benutzer\Sven\Documents\Arduino&#xD;&#xA;vm.core.include=arduino.h&#xD;&#xA;vm.boardsource.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0&#xD;&#xA;runtime.platform.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0&#xD;&#xA;vm.platformname.name=esp8266&#xD;&#xA;build.arch=ESP8266&#xD;&#xA;build.flash_ld=eagle.flash.4m.ld&#xD;&#xA;build.spiffs_start=0x100000&#xD;&#xA;build.spiffs_end=0x3FB000&#xD;&#xA;build.spiffs_blocksize=8192&#xD;&#xA;build.spiffs_pagesize=256&#xD;&#xA;upload.verbose=-vv&#xD;&#xA;build.architecture=1.20.0-26-gb404fb9-2&#xD;&#xA;vmresolved.compiler.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\bin\&#xD;&#xA;vmresolved.tools.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2&#xD;&#xA;vm.runtime.compiler.showwarnings=false&#xD;&#xA;vm.runtime.compiler.auto_discover_includes=true&#xD;&#xA;vm.last.buildpath=C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2&#xD;&#xA;vm.build.verbose_build_properties=true&#xD;&#xA;build.source.path=Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP\SIGNALESP.ino&#xD;&#xA;build.path=C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2&#xD;&#xA;PreProcessor.HeaderCount=1&#xD;&#xA;PreProcessor.PrototypeCount=9&#xD;&#xA;vm.last.preproc.file.0.file=SIGNALESP.ino&#xD;&#xA;vm.last.preproc.file.0.offset=1&#xD;&#xA;vm.last.preproc.file.0.length=15540&#xD;&#xA;vm.last.preproc.file.0.linecount=628&#xD;&#xA;vm.last.preproc.file.0.linestart=0&#xD;&#xA;vm.last.preproc.file.0.lineend=628&#xD;&#xA;vm.last.preproc.file.0.prefix_lines=0&#xD;&#xA;vm.last.preproc.file.1.file=SimpleFIFO.cpp&#xD;&#xA;vm.last.preproc.file.1.offset=0&#xD;&#xA;vm.last.preproc.file.1.length=46&#xD;&#xA;vm.last.preproc.file.1.linecount=8&#xD;&#xA;vm.last.preproc.file.1.linestart=628&#xD;&#xA;vm.last.preproc.file.1.lineend=636&#xD;&#xA;vm.last.preproc.file.1.prefix_lines=0&#xD;&#xA;vm.last.preproc.file.2.file=SimpleFIFO.h&#xD;&#xA;vm.last.preproc.file.2.offset=0&#xD;&#xA;vm.last.preproc.file.2.length=2938&#xD;&#xA;vm.last.preproc.file.2.linecount=98&#xD;&#xA;vm.last.preproc.file.2.linestart=636&#xD;&#xA;vm.last.preproc.file.2.lineend=734&#xD;&#xA;vm.last.preproc.file.2.prefix_lines=0&#xD;&#xA;vm.last.preproc.file.3.file=bitstore.cpp&#xD;&#xA;vm.last.preproc.file.3.offset=0&#xD;&#xA;vm.last.preproc.file.3.length=25&#xD;&#xA;vm.last.preproc.file.3.linecount=3&#xD;&#xA;vm.last.preproc.file.3.linestart=734&#xD;&#xA;vm.last.preproc.file.3.lineend=737&#xD;&#xA;vm.last.preproc.file.3.prefix_lines=0&#xD;&#xA;vm.last.preproc.file.4.file=bitstore.h&#xD;&#xA;vm.last.preproc.file.4.offset=0&#xD;&#xA;vm.last.preproc.file.4.length=5163&#xD;&#xA;vm.last.preproc.file.4.linecount=169&#xD;&#xA;vm.last.preproc.file.4.linestart=737&#xD;&#xA;vm.last.preproc.file.4.lineend=906&#xD;&#xA;vm.last.preproc.file.4.prefix_lines=0&#xD;&#xA;serial.port.file=COM4&#xD;&#xA;serial.port=COM4&#xD;&#xA;serial.port.num=4&#xD;&#xA;sketch_path=Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP&#xD;&#xA;build.project_name=SIGNALESP.ino&#xD;&#xA;runtime.vm.ide.platforms.path=Z:\Programme\visual studio 2015\Common7\IDE\Extensions\ov4gogvo.2y3\Micro Platforms&#xD;&#xA;build.variant.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu&#xD;&#xA;build.core.path=C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266&#xD;&#xA;archive_file=core.a&#xD;&#xA;archive_file_path=C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\core.a&#xD;&#xA;extra.time.local=78560610&#xD;&#xA;tools.ctags.path={runtime.tools.ctags.path}&#xD;&#xA;tools.ctags.cmd.path={path}/ctags&#xD;&#xA;tools.ctags.pattern=&quot;{cmd.path}&quot; -u --language-force=c++ -f - --c++-kinds=svpf --fields=KSTtzns --line-directives &quot;{source_file}&quot;&#xD;&#xA;tools.avrdude.path={runtime.tools.avrdude.path}&#xD;&#xA;preproc.includes.flags=-w -x c++ -M -MG -MP&#xD;&#xA;preproc.includes.compatibility_flags={build.mbed_api_include} {build.nRF51822_api_include} {build.ble_api_include} {compiler.libsam.c.flags} {compiler.arm.cmsis.path} {build.variant_system_include}&#xD;&#xA;recipe.preproc.includes=&quot;{compiler.path}{compiler.cpp.cmd}&quot; {preproc.includes.flags} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.cpp.extra_flags} {build.extra_flags} {preproc.includes.compatibility_flags} {includes} &quot;{source_file}&quot;&#xD;&#xA;preproc.macros.flags=-w -x c++ -E -CC&#xD;&#xA;preproc.macros.compatibility_flags={build.mbed_api_include} {build.nRF51822_api_include} {build.ble_api_include} {compiler.libsam.c.flags} {compiler.arm.cmsis.path} {build.variant_system_include}&#xD;&#xA;recipe.preproc.macros=&quot;{compiler.path}{compiler.cpp.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.cpp.flags} {preproc.macros.flags} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.cpp.extra_flags} {build.extra_flags} {preproc.macros.compatibility_flags} {includes} &quot;{source_file}&quot; -o &quot;{preprocessed_file_path}&quot;&#xD;&#xA;vm_all_includes= -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries\EEPROM&quot;  -I&quot;z:\Programme\Arduino\libraries&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries&quot;  -I&quot;Z:\Programme\visual studio 2015\Common7\IDE\Extensions\ov4gogvo.2y3\Micro Platforms\default\debuggers&quot;  -I&quot;Z:\Benutzer\Sven\Documents\Arduino\libraries&quot; &#xD;&#xA;vm_core_includes= -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu&quot; &#xD;&#xA;includes= -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries\EEPROM&quot;  -I&quot;z:\Programme\Arduino\libraries&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries&quot;  -I&quot;Z:\Programme\visual studio 2015\Common7\IDE\Extensions\ov4gogvo.2y3\Micro Platforms\default\debuggers&quot;  -I&quot;Z:\Benutzer\Sven\Documents\Arduino\libraries&quot; &#xD;&#xA;build.path_sketch=C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2&#xD;&#xA;build.path_core=C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\core&#xD;&#xA;build.path_libraries=C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2&#xD;&#xA;object_file=C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\SIGNALESP.cpp.o&#xD;&#xA;source_file=C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\SIGNALESP.cpp&#xD;&#xA;vm.last.preproc.file.5.file=signalDecoder.cpp&#xD;&#xA;vm.last.preproc.file.5.offset=0&#xD;&#xA;vm.last.preproc.file.5.length=37530&#xD;&#xA;vm.last.preproc.file.5.linecount=1277&#xD;&#xA;vm.last.preproc.file.5.linestart=906&#xD;&#xA;vm.last.preproc.file.5.lineend=2183&#xD;&#xA;vm.last.preproc.file.5.prefix_lines=0&#xD;&#xA;vm.last.preproc.file.6.file=signalDecoder.h&#xD;&#xA;vm.last.preproc.file.6.offset=0&#xD;&#xA;vm.last.preproc.file.6.length=5961&#xD;&#xA;vm.last.preproc.file.6.linecount=166&#xD;&#xA;vm.last.preproc.file.6.linestart=2183&#xD;&#xA;vm.last.preproc.file.6.lineend=2349&#xD;&#xA;vm.last.preproc.file.6.prefix_lines=0&#xD;&#xA;object_files= &quot;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\SIGNALESP.cpp.o&quot;  &quot;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\SimpleFIFO\SimpleFIFO.cpp.o&quot;  &quot;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\signalDecoder\signalDecoder.cpp.o&quot;  &quot;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\bitstore\bitstore.cpp.o&quot;  &quot;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\EEPROM\EEPROM.cpp.o&quot; &#xD;&#xA;" visualmicro.application.name="arduino16x" arduino.build.mcu="esp8266" arduino.build.auto_discover_includes="0" arduino.upload.protocol="" arduino.build.f_cpu="80000000L" arduino.board.desc="NodeMCU 1.0 (ESP-12E Module)" arduino.board.name="esp8266_nodemcuv2" arduino.upload.port="COM3" visualmicro.platform.name="esp8266" arduino.build.core="esp8266" />
-    </VisualStudio>
-  </ProjectExtensions>
-</Project>
\ No newline at end of file
diff -ruwN ./SIGNALESP.vcxproj.filters ../../trebron106/SIGNALEsp-20170510/SIGNALESP.vcxproj.filters
--- ./SIGNALESP.vcxproj.filters	2017-08-17 12:42:53.362692489 +0200
+++ ../../trebron106/SIGNALEsp-20170510/SIGNALESP.vcxproj.filters	1970-01-01 01:00:00.000000000 +0100
@@ -1,60 +0,0 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
-  <ItemGroup>
-    <Filter Include="Source Files">
-      <UniqueIdentifier>{4FC737F1-C7A5-4376-A066-2A32D752A2FF}</UniqueIdentifier>
-      <Extensions>cpp;c;cc;cxx;def;odl;idl;hpj;bat;asm;asmx</Extensions>
-    </Filter>
-    <Filter Include="Header Files">
-      <UniqueIdentifier>{93995380-89BD-4b04-88EB-625FBE52EBFB}</UniqueIdentifier>
-      <Extensions>h;hh;hpp;hxx;hm;inl;inc;xsd</Extensions>
-    </Filter>
-    <Filter Include="Resource Files">
-      <UniqueIdentifier>{67DA6AB6-F800-4c08-8B7A-83BB121AAD01}</UniqueIdentifier>
-      <Extensions>rc;ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe;resx;tiff;tif;png;wav;mfcribbon-ms</Extensions>
-    </Filter>
-  </ItemGroup>
-  <ItemGroup>
-    <None Include="SIGNALESP.ino" />
-  </ItemGroup>
-  <ItemGroup>
-    <ClInclude Include="__vm\.SIGNALESP.vsarduino.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\src\_micro-api\libraries\signalDecoder\src\signalDecoder.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\src\_micro-api\libraries\SimpleFIFO\src\SimpleFIFO.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\src\_micro-api\libraries\bitstore\src\bitstore.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\..\SIGNALDuino\src\_micro-api\libraries\output\src\output.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="configwifi.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-    <ClInclude Include="..\src\_micro-api\libraries\WIFIManager\WiFiManager.h">
-      <Filter>Header Files</Filter>
-    </ClInclude>
-  </ItemGroup>
-  <ItemGroup>
-    <ClCompile Include="..\src\_micro-api\libraries\SimpleFIFO\src\SimpleFIFO.cpp">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\src\_micro-api\libraries\signalDecoder\src\signalDecoder.cpp">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\src\_micro-api\libraries\bitstore\src\bitstore.cpp">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\..\SIGNALDuino\src\_micro-api\libraries\output\src\output.cpp">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-    <ClCompile Include="..\src\_micro-api\libraries\WIFIManager\WiFiManager.cpp">
-      <Filter>Source Files</Filter>
-    </ClCompile>
-  </ItemGroup>
-</Project>
\ No newline at end of file
diff -ruwN ./SimpleFIFO.cpp ../../trebron106/SIGNALEsp-20170510/SimpleFIFO.cpp
--- ./SimpleFIFO.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/SimpleFIFO.cpp	2017-05-01 08:54:58.000000000 +0200
@@ -0,0 +1,7 @@
+// 
+// 
+// 
+
+#include "SimpleFIFO.h"
+
+
diff -ruwN ./SimpleFIFO.h ../../trebron106/SIGNALEsp-20170510/SimpleFIFO.h
--- ./SimpleFIFO.h	1970-01-01 01:00:00.000000000 +0100
+++ ../../trebron106/SIGNALEsp-20170510/SimpleFIFO.h	2017-05-01 08:54:58.000000000 +0200
@@ -0,0 +1,97 @@
+#ifndef SimpleFIFO_h
+#define SimpleFIFO_h
+#include <Arduino.h>
+#ifndef SIMPLEFIFO_SIZE_TYPE
+#ifndef SIMPLEFIFO_LARGE
+#define SIMPLEFIFO_SIZE_TYPE uint8_t
+#else
+#define SIMPLEFIFO_SIZE_TYPE uint16_t
+#endif
+#endif
+/*
+||
+|| @file 		SimpleFIFO.h
+|| @version 	1.2
+|| @author 	Alexander Brevig
+|| @contact 	alexanderbrevig@gmail.com
+||
+|| @description
+|| | A simple FIFO class, mostly for primitive types but can be used with classes if assignment to int is allowed
+|| | This FIFO is not dynamic, so be sure to choose an appropriate size for it
+|| #
+||
+|| @license
+|| | Copyright (c) 2010 Alexander Brevig
+|| | This library is free software; you can redistribute it and/or
+|| | modify it under the terms of the GNU Lesser General Public
+|| | License as published by the Free Software Foundation; version
+|| | 2.1 of the License.
+|| |
+|| | This library is distributed in the hope that it will be useful,
+|| | but WITHOUT ANY WARRANTY; without even the implied warranty of
+|| | MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+|| | Lesser General Public License for more details.
+|| |
+|| | You should have received a copy of the GNU Lesser General Public
+|| | License along with this library; if not, write to the Free Software
+|| | Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA
+|| #
+||
+*/
+template<typename T, int rawSize>
+class SimpleFIFO {
+public:
+	const SIMPLEFIFO_SIZE_TYPE size;				//speculative feature, in case it's needed
+
+	SimpleFIFO();
+
+	T dequeue();				//get next element
+	bool enqueue( T element );	//add an element
+	T peek() const;				//get the next element without releasing it from the FIFO
+	void flush();				//[1.1] reset to default state 
+
+	//how many elements are currently in the FIFO?
+	SIMPLEFIFO_SIZE_TYPE count() { return numberOfElements; }
+
+private:
+#ifndef SimpleFIFO_NONVOLATILE
+	volatile SIMPLEFIFO_SIZE_TYPE numberOfElements;
+	volatile SIMPLEFIFO_SIZE_TYPE nextIn;
+	volatile SIMPLEFIFO_SIZE_TYPE nextOut;
+	volatile T raw[rawSize];
+#else
+	SIMPLEFIFO_SIZE_TYPE numberOfElements;
+	SIMPLEFIFO_SIZE_TYPE nextIn;
+	SIMPLEFIFO_SIZE_TYPE nextOut;
+	T raw[rawSize];
+#endif
+};
+
+template<typename T, int rawSize>
+SimpleFIFO<T,rawSize>::SimpleFIFO() : size(rawSize) {
+	flush();
+}
+template<typename T, int rawSize>
+bool SimpleFIFO<T,rawSize>::enqueue( T element ) {
+	if ( count() >= rawSize ) { return false; }
+	numberOfElements++;
+	nextIn %= size;
+	raw[nextIn] = element;
+	nextIn++; //advance to next index
+	return true;
+}
+template<typename T, int rawSize>
+T SimpleFIFO<T,rawSize>::dequeue() {
+	numberOfElements--;
+	nextOut %= size;
+	return raw[ nextOut++];
+}
+template<typename T, int rawSize>
+T SimpleFIFO<T,rawSize>::peek() const {
+	return raw[ nextOut % size];
+}
+template<typename T, int rawSize>
+void SimpleFIFO<T,rawSize>::flush() {
+	nextIn = nextOut = numberOfElements = 0;
+}
+#endif
diff -ruwN ./__vm/Compile.vmps.xml ../../trebron106/SIGNALEsp-20170510/__vm/Compile.vmps.xml
--- ./__vm/Compile.vmps.xml	2017-08-17 12:43:36.538057925 +0200
+++ ../../trebron106/SIGNALEsp-20170510/__vm/Compile.vmps.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-<VisualMicro>
-  <Program Name="SIGNALESP" Ext=".ino" Location="Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP">
-    <Compile IsDebugStart="1" CompilerErrors="0" ConfigurationName="Release" StopOnError="False" OptimiseLibs="True" OptimiseCore="True" IsGdb="0" BuildPath="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" ReCompileIfSourceIsNewer="1" IncludeDebug="0" IncludesDebug="0" SketchName="SIGNALESP" IsCompiled="1" />
-    <Platform Name="arduino16x" Package="esp8266" Platform="esp8266" Architecture="1.20.0-26-gb404fb9-2">
-      <Board Name="esp8266_nodemcuv2" Description="NodeMCU 1.0 (ESP-12E Module)" CoreFolder="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266" VariantFullPath="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\variants\nodemcu" McuIdePath="z:\Programme\Arduino" McuSketchBookPath="Z:\Benutzer\Sven\Documents\Arduino" name="NodeMCU 1.0 (ESP-12E Module)" upload.tool="esptool" upload.speed="115200" upload.resetmethod="nodemcu" upload.maximum_size="1044464" upload.maximum_data_size="81920" upload.wait_for_upload_port="true" serial.disableDTR="true" serial.disableRTS="true" build.mcu="esp8266" build.f_cpu="80000000L" build.board="ESP8266_NODEMCU" build.core="esp8266" build.variant="nodemcu" build.flash_mode="dio" build.flash_size="4M" build.flash_freq="40" build.debug_port="" build.debug_level="" menu.CpuFrequency.80="80 MHz" menu.CpuFrequency.80.build.f_cpu="80000000L" menu.CpuFrequency.160="160 MHz" menu.CpuFrequency.160.build.f_cpu="160000000L" menu.UploadSpeed.115200="115200" menu.UploadSpeed.115200.upload.speed="115200" menu.UploadSpeed.9600="9600" menu.UploadSpeed.9600.upload.speed="9600" menu.UploadSpeed.57600="57600" menu.UploadSpeed.57600.upload.speed="57600" menu.UploadSpeed.256000.windows="256000" menu.UploadSpeed.256000.upload.speed="256000" menu.UploadSpeed.230400.linux="230400" menu.UploadSpeed.230400.macosx="230400" menu.UploadSpeed.230400.upload.speed="230400" menu.UploadSpeed.460800.linux="460800" menu.UploadSpeed.460800.macosx="460800" menu.UploadSpeed.460800.upload.speed="460800" menu.UploadSpeed.512000.windows="512000" menu.UploadSpeed.512000.upload.speed="512000" menu.UploadSpeed.921600="921600" menu.UploadSpeed.921600.upload.speed="921600" menu.FlashSize.4M3M="4M (3M SPIFFS)" menu.FlashSize.4M3M.build.flash_size="4M" menu.FlashSize.4M3M.build.flash_ld="eagle.flash.4m.ld" menu.FlashSize.4M3M.build.spiffs_start="0x100000" menu.FlashSize.4M3M.build.spiffs_end="0x3FB000" menu.FlashSize.4M3M.build.spiffs_blocksize="8192" menu.FlashSize.4M3M.build.spiffs_pagesize="256" menu.FlashSize.4M1M="4M (1M SPIFFS)" menu.FlashSize.4M1M.build.flash_size="4M" menu.FlashSize.4M1M.build.flash_ld="eagle.flash.4m1m.ld" menu.FlashSize.4M1M.build.spiffs_start="0x300000" menu.FlashSize.4M1M.build.spiffs_end="0x3FB000" menu.FlashSize.4M1M.build.spiffs_blocksize="8192" menu.FlashSize.4M1M.build.spiffs_pagesize="256" menu.UploadSpeed.256000="256000" menu.UploadSpeed.512000="512000" runtime.ide.path="z:\Programme\Arduino" runtime.os="windows" build.system.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\system" runtime.ide.version="106011" target_package="esp8266" target_platform="esp8266" runtime.hardware.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266" originalid="nodemcuv2" intellisense.tools.path="{compiler.toolchain.path}" intellisense.include.paths="{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include\c++\4.8.2;{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include\c++\4.8.2\xtensa-lx106-elf;{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include;{runtime.tools.xtensa-lx106-elf-gcc.path}\lib\gcc\xtensa-lx106-elf\4.8.2\include;{runtime.platform.path}\tools\sdk\include" tools.wwwfiles.name="ESP8266 Sketch Data Upload" tools.wwwfiles.ssh="false" tools.wwwfiles.cmd.windows="ESP8266FSUpload.exe" recipe.wwwfiles.upload.pattern="&quot;{vm.path}/{tools.wwwfiles.cmd}&quot; -serial.port={serial.port} -build.path=&quot;{build.path}&quot; -target_platform=&quot;{target_platform}&quot; -runtime.tools.mkspiffs.path=&quot;{runtime.tools.mkspiffs.path}&quot; -board.name=&quot;{name}&quot; -upload.verbose={upload.verbose} -upload.resetmethod={upload.resetmethod} -upload.speed={upload.speed}  -platform.path=&quot;{platform.path}&quot; -project.name=&quot;{project.name}&quot; -project.path=&quot;{project.path}&quot; -tools.esptool.cmd=&quot;{tools.esptool.cmd}&quot; -runtime.tools.esptool.path=&quot;{runtime.tools.esptool.path}&quot; -compiler.path=&quot;{compiler.path}&quot; -build.spiffs_start=&quot;{build.spiffs_start}&quot; -build.spiffs_end=&quot;{build.spiffs_end}&quot; -build.spiffs_pagesize=&quot;{build.spiffs_pagesize}&quot; -build.spiffs_blocksize=&quot;{build.spiffs_blocksize}&quot; -network.password={network.password} -network.auth_upload={network.auth_upload} -network.port={network.port}" tools.wwwfiles.cmd="ESP8266FSUpload.exe" version="2.2.0" compiler.warning_flags="-w" compiler.warning_flags.none="-w" compiler.warning_flags.default="" compiler.warning_flags.more="-Wall" compiler.warning_flags.all="-Wall -Wextra" build.lwip_lib="-llwip_gcc" build.lwip_flags="-DLWIP_OPEN_SRC" compiler.path="{runtime.tools.xtensa-lx106-elf-gcc.path}/bin/" compiler.sdk.path="{runtime.platform.path}/tools/sdk" compiler.cpreprocessor.flags="-D__ets__ -DICACHE_FLASH -U__STRICT_ANSI__ &quot;-I{compiler.sdk.path}/include&quot; &quot;-I{compiler.sdk.path}/lwip/include&quot; &quot;-I{build.path}/core&quot;" compiler.c.cmd="xtensa-lx106-elf-gcc" compiler.c.flags="-c {compiler.warning_flags} -Os -g -Wpointer-arith -Wno-implicit-function-declaration -Wl,-EL -fno-inline-functions -nostdlib -mlongcalls -mtext-section-literals -falign-functions=4 -MMD -std=gnu99 -ffunction-sections -fdata-sections" compiler.S.cmd="xtensa-lx106-elf-gcc" compiler.S.flags="-c -g -x assembler-with-cpp -MMD -mlongcalls" compiler.c.elf.flags="-g {compiler.warning_flags} -Os -nostdlib -Wl,--no-check-sections -u call_user_start -Wl,-static &quot;-L{compiler.sdk.path}/lib&quot; &quot;-L{compiler.sdk.path}/ld&quot; &quot;-T{build.flash_ld}&quot; -Wl,--gc-sections -Wl,-wrap,system_restart_local -Wl,-wrap,register_chipv6_phy" compiler.c.elf.cmd="xtensa-lx106-elf-gcc" compiler.c.elf.libs="-lm -lgcc -lhal -lphy -lpp -lnet80211 -lwpa -lcrypto -lmain -lwps -laxtls -lsmartconfig -lmesh -lwpa2 {build.lwip_lib} -lstdc++" compiler.cpp.cmd="xtensa-lx106-elf-g++" compiler.cpp.flags="-c {compiler.warning_flags} -Os -g -mlongcalls -mtext-section-literals -fno-exceptions -fno-rtti -falign-functions=4 -std=c++11 -MMD -ffunction-sections -fdata-sections" compiler.as.cmd="xtensa-lx106-elf-as" compiler.ar.cmd="xtensa-lx106-elf-ar" compiler.ar.flags="cru" compiler.elf2hex.cmd="esptool" compiler.elf2hex.flags="" compiler.size.cmd="xtensa-lx106-elf-size" compiler.esptool.cmd="esptool.exe" compiler.esptool.cmd.windows="esptool.exe" build.extra_flags="-DESP8266" compiler.c.extra_flags="" compiler.c.elf.extra_flags="" compiler.S.extra_flags="" compiler.cpp.extra_flags="" compiler.ar.extra_flags="" compiler.objcopy.eep.extra_flags="" compiler.elf2hex.extra_flags="" recipe.c.o.pattern="&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.c.flags} -DF_CPU={build.f_cpu} {build.lwip_flags} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=&quot;{build.board}&quot; {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.cpp.o.pattern="&quot;{compiler.path}{compiler.cpp.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.cpp.flags} -DF_CPU={build.f_cpu} {build.lwip_flags} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=&quot;{build.board}&quot; {compiler.cpp.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.S.o.pattern="&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.S.flags} -DF_CPU={build.f_cpu} {build.lwip_flags} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=&quot;{build.board}&quot; {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.ar.pattern="&quot;{compiler.path}{compiler.ar.cmd}&quot; {compiler.ar.flags} {compiler.ar.extra_flags} &quot;{archive_file_path}&quot; &quot;{object_file}&quot;" recipe.c.combine.pattern="&quot;{compiler.path}{compiler.c.elf.cmd}&quot; {compiler.c.elf.flags} {compiler.c.elf.extra_flags} -o &quot;{build.path}/{build.project_name}.elf&quot; -Wl,--start-group {object_files} &quot;{build.path}/{archive_file}&quot; {compiler.c.elf.libs} -Wl,--end-group  &quot;-L{build.path}&quot;" recipe.objcopy.eep.pattern="" recipe.objcopy.hex.pattern="&quot;{runtime.tools.esptool.path}/{compiler.esptool.cmd}&quot; -eo &quot;{runtime.platform.path}/bootloaders/eboot/eboot.elf&quot; -bo &quot;{build.path}/{build.project_name}.bin&quot; -bm {build.flash_mode} -bf {build.flash_freq} -bz {build.flash_size} -bs .text -bp 4096 -ec -eo &quot;{build.path}/{build.project_name}.elf&quot; -bs .irom0.text -bs .text -bs .data -bs .rodata -bc -ec" recipe.output.tmp_file="{build.project_name}.bin" recipe.output.save_file="{build.project_name}.{build.variant}.bin" recipe.size.pattern="&quot;{compiler.path}{compiler.size.cmd}&quot; -A &quot;{build.path}/{build.project_name}.elf&quot;" recipe.size.regex="^(?:\.irom0\.text|\.text|\.data|\.rodata|)\s+([0-9]+).*" recipe.size.regex.data="^(?:\.data|\.rodata|\.bss)\s+([0-9]+).*" tools.esptool.cmd="esptool.exe" tools.esptool.cmd.windows="esptool.exe" tools.esptool.path="{runtime.tools.esptool.path}" tools.esptool.network_cmd="python.exe" tools.esptool.network_cmd.windows="python.exe" tools.esptool.upload.protocol="esp" tools.esptool.upload.params.verbose="-vv" tools.esptool.upload.params.quiet="" tools.esptool.upload.pattern="&quot;{path}/{cmd}&quot; {upload.verbose} -cd {upload.resetmethod} -cb {upload.speed} -cp &quot;{serial.port}&quot; -ca 0x00000 -cf &quot;{build.path}/{build.project_name}.bin&quot;" tools.esptool.upload.network_pattern="&quot;{network_cmd}&quot; &quot;{runtime.platform.path}/tools/espota.py&quot; -i &quot;{serial.port}&quot; -p &quot;{network.port}&quot; &quot;--auth={network.password}&quot; -f &quot;{build.path}/{build.project_name}.bin&quot;" tools.mkspiffs.cmd="mkspiffs.exe" tools.mkspiffs.cmd.windows="mkspiffs.exe" tools.mkspiffs.path="{runtime.tools.mkspiffs.path}" vm.platform.root.path="Z:\Programme\visual studio 2015\Common7\IDE\Extensions\1leckq1b.pja\Micro Platforms\arduino16x" runtime.tools.esptool.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\esptool\0.4.9" runtime.tools.esptool-0.4.9.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\esptool\0.4.9" runtime.tools.xtensa-lx106-elf-gcc.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" runtime.tools.xtensa-lx106-elf-gcc-1.20.0-26-gb404fb9-2.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" runtime.tools.mkspiffs.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\mkspiffs\0.1.2" runtime.tools.mkspiffs-0.1.2.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\mkspiffs\0.1.2" runtime.tools.avrdude.path="z:\Programme\Arduino\hardware\tools\avr" runtime.tools.avrdude-6.0.1-arduino2.path="z:\Programme\Arduino\hardware\tools\avr" runtime.tools.avr-gcc.path="z:\Programme\Arduino\hardware\tools\avr" runtime.tools.avr-gcc-4.9.2-atmel3.5.3-arduino.path="z:\Programme\Arduino\hardware\tools\avr" runtime.vm.boardinfo.id="esp8266_nodemcuv2" runtime.vm.boardinfo.name="esp8266_nodemcuv2" runtime.vm.boardinfo.desc="NodeMCU 1.0 (ESP-12E Module)" runtime.vm.boardinfo.src_location="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" ide.hint="For all platforms that use Board Manager" ide.location.key="Arduino16x" ide.location.ide.winreg="Arduino 1.6.x Application" ide.location.sketchbook.winreg="Arduino 1.6.x Sketchbook" ide.location.sketchbook.preferences="sketchbook.path" ide.default.revision_name="1.6.9" ide.default.version="10609" ide.default.package="arduino" ide.default.platform="avr" ide.multiplatform="true" ide.includes="arduino.h" ide.exe_name="arduino" ide.platformswithoutpackage="false" ide.includes.fallback="wprogram.h" ide.extension="ino" ide.extension.fallback="pde" ide.versionGTEQ="160" ide.exe="arduino.exe" ide.hosts="atmel" ide.url="http://arduino.cc/en/Main/Software" ide.help.reference.path="reference" ide.help.reference.path2="reference\www.arduino.cc\en\Reference" ide.help.reference.serial="reference\www.arduino.cc\en\Serial" vm.debug="true" software="ARDUINO" ssh.user.name="root" ssh.user.default.password="arduino" ssh.host.wwwfiles.path="/www/sd" build.working_directory="{runtime.ide.path}" ide.location.preferences.portable="{runtime.ide.path}\portable" ide.location.preferences="%VM_APPDATA_LOCAL%\arduino15\preferences.txt" ide.location.preferences_fallback="%VM_APPDATA_ROAMING%\arduino15\preferences.txt" ide.location.contributions="%VM_APPDATA_LOCAL%\arduino15" ide.location.contributions_fallback="%VM_APPDATA_ROAMING%\arduino15" ide.contributions.boards.allow="true" ide.contributions.boards.ignore_unless_rewrite_found="true" ide.contributions.libraries.allow="true" ide.contributions.boards.support.urls.wiki="https://github.com/arduino/Arduino/wiki/Unofficial-list-of-3rd-party-boards-support-urls" ide.create_platforms_from_boardsTXT.teensy="build.core" ide.appid="arduino16x" location.sketchbook="Z:\Benutzer\Sven\Documents\Arduino" build.core.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266" build.core.parentfolder.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores" build.core.coresparentfolder.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" build.core.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266" vm.core.include="arduino.h" vm.boardsource.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" runtime.platform.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" vm.platformname.name="esp8266" build.arch="ESP8266" build.flash_ld="eagle.flash.4m.ld" build.spiffs_start="0x100000" build.spiffs_end="0x3FB000" build.spiffs_blocksize="8192" build.spiffs_pagesize="256" builder.noino="false" build.variant.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\variants\nodemcu" build.architecture="1.20.0-26-gb404fb9-2" vmresolved.compiler.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\bin\" vmresolved.tools.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" vm.runtime.compiler.showwarnings="false" vm.runtime.upload.verbose="false" vm.runtime.upload.verify="true" serial.port.file="COM3" serial.port="COM3" serial.port.num="3" vm.runtime.compiler.auto_discover_includes="false" build.vm.build.vmdebug="0" build.vm.build.isgdb="0" build.vm.build.optimised="1" vm.last.buildpath="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" />
-    </Platform>
-    <Debug DebugEnabled="0" EnableBreak="1" />
-    <VCCodeModel>
-      <VCCodeMacros />
-    </VCCodeModel>
-  </Program>
-</VisualMicro>
\ No newline at end of file
diff -ruwN ./__vm/Configuration.Debug.vmps.xml ../../trebron106/SIGNALEsp-20170510/__vm/Configuration.Debug.vmps.xml
--- ./__vm/Configuration.Debug.vmps.xml	2017-08-17 12:42:53.362692489 +0200
+++ ../../trebron106/SIGNALEsp-20170510/__vm/Configuration.Debug.vmps.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-<VisualMicro>
-  <Program Name="SIGNALESP" Ext=".ino" Location="Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP">
-    <Compile IsDebugStart="1" IsCompiled="0" CompilerErrors="0" ConfigurationName="Debug" StopOnError="False" OptimiseLibs="True" OptimiseCore="True" BuildPath="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" ReCompileIfSourceIsNewer="1" />
-    <Platform Name="arduino16x" Package="esp8266" Platform="esp8266" Architecture="1.20.0-26-gb404fb9-2">
-      <Board Name="esp8266_nodemcuv2" Description="NodeMCU 1.0 (ESP-12E Module)" CoreFolder="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266" VariantFullPath="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu" McuIdePath="z:\Programme\Arduino" McuSketchBookPath="Z:\Benutzer\Sven\Documents\Arduino" name="NodeMCU 1.0 (ESP-12E Module)" upload.tool="esptool" upload.speed="115200" upload.resetmethod="nodemcu" upload.maximum_size="1044464" upload.maximum_data_size="81920" upload.wait_for_upload_port="true" serial.disableDTR="true" serial.disableRTS="true" build.mcu="esp8266" build.f_cpu="80000000L" build.board="ESP8266_ESP12" build.core="esp8266" build.variant="nodemcu" build.flash_mode="dio" build.flash_size="4M" build.flash_freq="40" build.debug_port="" build.debug_level="" menu.CpuFrequency.80="80 MHz" menu.CpuFrequency.80.build.f_cpu="80000000L" menu.CpuFrequency.160="160 MHz" menu.CpuFrequency.160.build.f_cpu="160000000L" menu.UploadTool.esptool="Serial" menu.UploadTool.esptool.upload.tool="esptool" menu.UploadTool.esptool.upload.verbose="-vv" menu.UploadTool.espota="OTA" menu.UploadTool.espota.upload.tool="espota" menu.UploadSpeed.115200="115200" menu.UploadSpeed.115200.upload.speed="115200" menu.UploadSpeed.9600="9600" menu.UploadSpeed.9600.upload.speed="9600" menu.UploadSpeed.57600="57600" menu.UploadSpeed.57600.upload.speed="57600" menu.UploadSpeed.256000.windows="256000" menu.UploadSpeed.256000.upload.speed="256000" menu.UploadSpeed.230400.linux="230400" menu.UploadSpeed.230400.macosx="230400" menu.UploadSpeed.230400.upload.speed="230400" menu.UploadSpeed.460800.linux="460800" menu.UploadSpeed.460800.macosx="460800" menu.UploadSpeed.460800.upload.speed="460800" menu.UploadSpeed.512000.windows="512000" menu.UploadSpeed.512000.upload.speed="512000" menu.UploadSpeed.921600="921600" menu.UploadSpeed.921600.upload.speed="921600" menu.FlashSize.4M3M="4M (3M SPIFFS)" menu.FlashSize.4M3M.build.flash_size="4M" menu.FlashSize.4M3M.build.flash_ld="eagle.flash.4m.ld" menu.FlashSize.4M3M.build.spiffs_start="0x100000" menu.FlashSize.4M3M.build.spiffs_end="0x3FB000" menu.FlashSize.4M3M.build.spiffs_blocksize="8192" menu.FlashSize.4M3M.build.spiffs_pagesize="256" menu.FlashSize.4M1M="4M (1M SPIFFS)" menu.FlashSize.4M1M.build.flash_size="4M" menu.FlashSize.4M1M.build.flash_ld="eagle.flash.4m1m.ld" menu.FlashSize.4M1M.build.spiffs_start="0x300000" menu.FlashSize.4M1M.build.spiffs_end="0x3FB000" menu.FlashSize.4M1M.build.spiffs_blocksize="8192" menu.FlashSize.4M1M.build.spiffs_pagesize="256" menu.UploadSpeed.256000="256000" menu.UploadSpeed.512000="512000" runtime.ide.path="z:\Programme\Arduino" build.system.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\system" runtime.ide.version="10607" target_package="esp8266" target_platform="esp8266" runtime.hardware.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266" originalid="nodemcuv2" intellisense.tools.path="{compiler.toolchain.path}" intellisense.include.paths="{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include\c++\4.8.2;{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include\c++\4.8.2\xtensa-lx106-elf;{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include;{runtime.tools.xtensa-lx106-elf-gcc.path}\lib\gcc\xtensa-lx106-elf\4.8.2\include;{runtime.platform.path}\tools\sdk\include" version="2.1.0" compiler.warning_flags="-w" compiler.warning_flags.none="-w" compiler.warning_flags.default="" compiler.warning_flags.more="-Wall" compiler.warning_flags.all="-Wall -Wextra" compiler.path="{runtime.tools.xtensa-lx106-elf-gcc.path}/bin/" compiler.sdk.path="{runtime.platform.path}/tools/sdk" compiler.cpreprocessor.flags="-D__ets__ -DICACHE_FLASH -U__STRICT_ANSI__ &quot;-I{compiler.sdk.path}/include&quot;" compiler.c.cmd="xtensa-lx106-elf-gcc" compiler.c.flags="-c {compiler.warning_flags} -Os -g -Wpointer-arith -Wno-implicit-function-declaration -Wl,-EL -fno-inline-functions -nostdlib -mlongcalls -mtext-section-literals -falign-functions=4 -MMD -std=gnu99 -ffunction-sections -fdata-sections" compiler.S.cmd="xtensa-lx106-elf-gcc" compiler.S.flags="-c -g -x assembler-with-cpp -MMD -mlongcalls" compiler.c.elf.flags="-g {compiler.warning_flags} -Os -nostdlib -Wl,--no-check-sections -u call_user_start -Wl,-static &quot;-L{compiler.sdk.path}/lib&quot; &quot;-L{compiler.sdk.path}/ld&quot; &quot;-T{build.flash_ld}&quot; -Wl,--gc-sections -Wl,-wrap,system_restart_local -Wl,-wrap,register_chipv6_phy" compiler.c.elf.cmd="xtensa-lx106-elf-gcc" compiler.c.elf.libs="-lm -lgcc -lhal -lphy -lpp -lnet80211 -llwip -lwpa -lcrypto -lmain -lwps -laxtls -lsmartconfig -lmesh -lwpa2" compiler.cpp.cmd="xtensa-lx106-elf-g++" compiler.cpp.flags="-c {compiler.warning_flags} -Os -g -mlongcalls -mtext-section-literals -fno-exceptions -fno-rtti -falign-functions=4 -std=c++11 -MMD -ffunction-sections -fdata-sections" compiler.as.cmd="xtensa-lx106-elf-as" compiler.ar.cmd="xtensa-lx106-elf-ar" compiler.ar.flags="cru" compiler.elf2hex.cmd="esptool" compiler.elf2hex.flags="" compiler.size.cmd="xtensa-lx106-elf-size" compiler.esptool.cmd="esptool.exe" compiler.esptool.cmd.windows="esptool.exe" build.extra_flags="-DESP8266" compiler.c.extra_flags="" compiler.c.elf.extra_flags="" compiler.S.extra_flags="" compiler.cpp.extra_flags="" compiler.ar.extra_flags="" compiler.objcopy.eep.extra_flags="" compiler.elf2hex.extra_flags="" recipe.c.o.pattern="&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.c.flags} -DF_CPU={build.f_cpu} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.cpp.o.pattern="&quot;{compiler.path}{compiler.cpp.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.cpp.flags} -DF_CPU={build.f_cpu} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.cpp.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.S.o.pattern="&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.S.flags} -DF_CPU={build.f_cpu} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.ar.pattern="&quot;{compiler.path}{compiler.ar.cmd}&quot; {compiler.ar.flags} {compiler.ar.extra_flags} &quot;{archive_file_path}&quot; &quot;{object_file}&quot;" recipe.c.combine.pattern="&quot;{compiler.path}{compiler.c.elf.cmd}&quot; {compiler.c.elf.flags} {compiler.c.elf.extra_flags} -o &quot;{build.path}/{build.project_name}.elf&quot; -Wl,--start-group {object_files} &quot;{build.path}/{archive_file}&quot; {compiler.c.elf.libs} -Wl,--end-group  &quot;-L{build.path}&quot;" recipe.objcopy.eep.pattern="" recipe.objcopy.hex.pattern="&quot;{runtime.tools.esptool.path}/{compiler.esptool.cmd}&quot; -eo &quot;{runtime.platform.path}/bootloaders/eboot/eboot.elf&quot; -bo &quot;{build.path}/{build.project_name}.bin&quot; -bm {build.flash_mode} -bf {build.flash_freq} -bz {build.flash_size} -bs .text -bp 4096 -ec -eo &quot;{build.path}/{build.project_name}.elf&quot; -bs .irom0.text -bs .text -bs .data -bs .rodata -bc -ec" recipe.output.tmp_file="{build.project_name}.bin" recipe.output.save_file="{build.project_name}.{build.variant}.bin" recipe.size.pattern="&quot;{compiler.path}{compiler.size.cmd}&quot; -A &quot;{build.path}/{build.project_name}.elf&quot;" recipe.size.regex="^(?:\.irom0\.text|\.text|\.data|\.rodata|)\s+([0-9]+).*" recipe.size.regex.data="^(?:\.data|\.rodata|\.bss)\s+([0-9]+).*" tools.esptool.cmd="esptool.exe" tools.esptool.cmd.windows="esptool.exe" tools.esptool.path="{runtime.tools.esptool.path}" tools.esptool.network_cmd="python.exe" tools.esptool.network_cmd.windows="python.exe" tools.esptool.upload.protocol="esp" tools.esptool.upload.params.verbose="-vv" tools.esptool.upload.params.quiet="" tools.esptool.upload.pattern="&quot;{path}/{cmd}&quot; {upload.verbose} -cd {upload.resetmethod} -cb {upload.speed} -cp &quot;{serial.port}&quot; -ca 0x00000 -cf &quot;{build.path}/{build.project_name}.bin&quot;" tools.esptool.upload.network_pattern="&quot;{network_cmd}&quot; &quot;{runtime.platform.path}/tools/espota.py&quot; -i &quot;{serial.port}&quot; -p &quot;{network.port}&quot; &quot;--auth={network.password}&quot; -f &quot;{build.path}/{build.project_name}.bin&quot;" tools.mkspiffs.cmd="mkspiffs.exe" tools.mkspiffs.cmd.windows="mkspiffs.exe" tools.mkspiffs.path="{runtime.tools.mkspiffs.path}" tools.espota.cmd="python.exe" tools.espota.cmd.windows="python.exe" tools.espota.path="{runtime.platform.path}/tools" tools.espota.upload.protocol="espota" tools.espota.upload.params.verbose="" tools.espota.upload.params.quiet="" tools.espota.upload.pattern="&quot;{cmd}&quot; &quot;{path}/espota.py&quot; -i &quot;{serial.port}&quot; -p 8266 -f &quot;{build.path}/{build.project_name}.bin&quot;" vm.platform.root.path="Z:\Programme\visual studio 2015\Common7\IDE\Extensions\ov4gogvo.2y3\Micro Platforms\arduino16x" runtime.tools.avrdude.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\arduino\tools\avrdude\6.0.1-arduino5" runtime.tools.avrdude-6.0.1-arduino5.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\arduino\tools\avrdude\6.0.1-arduino5" runtime.tools.avr-gcc.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\arduino\tools\avr-gcc\4.8.1-arduino5" runtime.tools.avr-gcc-4.8.1-arduino5.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\arduino\tools\avr-gcc\4.8.1-arduino5" runtime.tools.esptool.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\esptool\0.4.8" runtime.tools.esptool-0.4.8.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\esptool\0.4.8" runtime.tools.mkspiffs.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\mkspiffs\0.1.2" runtime.tools.mkspiffs-0.1.2.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\mkspiffs\0.1.2" runtime.tools.xtensa-lx106-elf-gcc.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" runtime.tools.xtensa-lx106-elf-gcc-1.20.0-26-gb404fb9-2.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" ide.hint="For use with Arduino.cc 1.6.2+ ide" ide.location.key="Arduino16x" ide.location.ide.winreg="Arduino 1.6.x Application" ide.location.sketchbook.winreg="Arduino 1.6.x Sketchbook" ide.location.sketchbook.preferences="sketchbook.path" ide.default.revision_name="1.6.7" ide.default.version="10607" ide.default.package="arduino" ide.default.platform="avr" ide.multiplatform="true" ide.includes="arduino.h" ide.exe_name="arduino" ide.platformswithoutpackage="false" ide.includes.fallback="wprogram.h" ide.extension="ino" ide.extension.fallback="pde" ide.versionGTEQ="160" ide.exe="arduino.exe" ide.hosts="atmel" ide.url="http://arduino.cc/en/Main/Software" ide.help.reference.path="reference\arduino.cc\en\Reference" ide.help.reference.path2="reference\www.arduino.cc\en\Reference" ide.help.reference.serial="reference\www.arduino.cc\en\Serial" vm.debug="true" software="ARDUINO" ssh.user.name="root" ssh.user.default.password="arduino" ssh.host.wwwfiles.path="/www/sd" build.working_directory="{runtime.ide.path}" ide.location.preferences.portable="{runtime.ide.path}\portable" ide.location.preferences="%VM_APPDATA_LOCAL%\arduino15\preferences.txt" ide.location.preferences_fallback="%VM_APPDATA_ROAMING%\arduino15\preferences.txt" ide.location.contributions="%VM_APPDATA_LOCAL%\arduino15" ide.location.contributions_fallback="%VM_APPDATA_ROAMING%\arduino15" ide.contributions.boards.allow="true" ide.contributions.boards.ignore_unless_rewrite_found="true" ide.contributions.libraries.allow="true" ide.contributions.boards.support.urls.wiki="https://github.com/arduino/Arduino/wiki/Unofficial-list-of-3rd-party-boards-support-urls" ide.create_platforms_from_boardsTXT.teensy="build.core" ide.appid="arduino16x" location.sketchbook="Z:\Benutzer\Sven\Documents\Arduino" build.core.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266" build.core.parentfolder.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores" build.core.coresparentfolder.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0" vm.core.include="arduino.h" vm.boardsource.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0" runtime.platform.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0" vm.platformname.name="esp8266" build.arch="ESP8266" build.flash_ld="eagle.flash.4m.ld" build.spiffs_start="0x100000" build.spiffs_end="0x3FB000" build.spiffs_blocksize="8192" build.spiffs_pagesize="256" upload.verbose="-vv" build.variant.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu" build.architecture="1.20.0-26-gb404fb9-2" vmresolved.compiler.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\bin\" vmresolved.tools.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" vm.runtime.compiler.showwarnings="false" vm.runtime.compiler.auto_discover_includes="true" vm.last.buildpath="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" vm.build.verbose_build_properties="true" build.source.path="Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP\SIGNALESP.ino" build.path="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" PreProcessor.HeaderCount="1" PreProcessor.PrototypeCount="9" vm.last.preproc.file.0.file="SIGNALESP.ino" vm.last.preproc.file.0.offset="1" vm.last.preproc.file.0.length="15539" vm.last.preproc.file.0.linecount="628" vm.last.preproc.file.0.linestart="0" vm.last.preproc.file.0.lineend="628" vm.last.preproc.file.0.prefix_lines="0" vm.last.preproc.file.1.file="SimpleFIFO.cpp" vm.last.preproc.file.1.offset="0" vm.last.preproc.file.1.length="46" vm.last.preproc.file.1.linecount="8" vm.last.preproc.file.1.linestart="628" vm.last.preproc.file.1.lineend="636" vm.last.preproc.file.1.prefix_lines="0" vm.last.preproc.file.2.file="SimpleFIFO.h" vm.last.preproc.file.2.offset="0" vm.last.preproc.file.2.length="2938" vm.last.preproc.file.2.linecount="98" vm.last.preproc.file.2.linestart="636" vm.last.preproc.file.2.lineend="734" vm.last.preproc.file.2.prefix_lines="0" vm.last.preproc.file.3.file="bitstore.cpp" vm.last.preproc.file.3.offset="0" vm.last.preproc.file.3.length="25" vm.last.preproc.file.3.linecount="3" vm.last.preproc.file.3.linestart="734" vm.last.preproc.file.3.lineend="737" vm.last.preproc.file.3.prefix_lines="0" vm.last.preproc.file.4.file="bitstore.h" vm.last.preproc.file.4.offset="0" vm.last.preproc.file.4.length="5163" vm.last.preproc.file.4.linecount="169" vm.last.preproc.file.4.linestart="737" vm.last.preproc.file.4.lineend="906" vm.last.preproc.file.4.prefix_lines="0" serial.port.file="COM4" serial.port="COM4" serial.port.num="4" sketch_path="Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP" build.project_name="SIGNALESP.ino" runtime.vm.ide.platforms.path="Z:\Programme\visual studio 2015\Common7\IDE\Extensions\ov4gogvo.2y3\Micro Platforms" build.variant.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu" build.core.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266" archive_file="core.a" archive_file_path="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\core.a" extra.time.local="78208749" tools.ctags.path="{runtime.tools.ctags.path}" tools.ctags.cmd.path="{path}/ctags" tools.ctags.pattern="&quot;{cmd.path}&quot; -u --language-force=c++ -f - --c++-kinds=svpf --fields=KSTtzns --line-directives &quot;{source_file}&quot;" tools.avrdude.path="{runtime.tools.avrdude.path}" preproc.includes.flags="-w -x c++ -M -MG -MP" preproc.includes.compatibility_flags="{build.mbed_api_include} {build.nRF51822_api_include} {build.ble_api_include} {compiler.libsam.c.flags} {compiler.arm.cmsis.path} {build.variant_system_include}" recipe.preproc.includes="&quot;{compiler.path}{compiler.cpp.cmd}&quot; {preproc.includes.flags} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.cpp.extra_flags} {build.extra_flags} {preproc.includes.compatibility_flags} {includes} &quot;{source_file}&quot;" preproc.macros.flags="-w -x c++ -E -CC" preproc.macros.compatibility_flags="{build.mbed_api_include} {build.nRF51822_api_include} {build.ble_api_include} {compiler.libsam.c.flags} {compiler.arm.cmsis.path} {build.variant_system_include}" recipe.preproc.macros="&quot;{compiler.path}{compiler.cpp.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.cpp.flags} {preproc.macros.flags} -DF_CPU={build.f_cpu} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} {compiler.cpp.extra_flags} {build.extra_flags} {preproc.macros.compatibility_flags} {includes} &quot;{source_file}&quot; -o &quot;{preprocessed_file_path}&quot;" vm_all_includes=" -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries\EEPROM&quot;  -I&quot;z:\Programme\Arduino\libraries&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries&quot;  -I&quot;Z:\Programme\visual studio 2015\Common7\IDE\Extensions\ov4gogvo.2y3\Micro Platforms\default\debuggers&quot;  -I&quot;Z:\Benutzer\Sven\Documents\Arduino\libraries&quot; " vm_core_includes=" -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu&quot; " includes=" -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\cores\esp8266&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\variants\nodemcu&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\bitstore&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\signalDecoder&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO\src&quot;  -I&quot;Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\src\_micro-api\libraries\SimpleFIFO&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries\EEPROM&quot;  -I&quot;z:\Programme\Arduino\libraries&quot;  -I&quot;C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.1.0\libraries&quot;  -I&quot;Z:\Programme\visual studio 2015\Common7\IDE\Extensions\ov4gogvo.2y3\Micro Platforms\default\debuggers&quot;  -I&quot;Z:\Benutzer\Sven\Documents\Arduino\libraries&quot; " build.path_sketch="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" build.path_core="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\core" build.path_libraries="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" object_file="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\SIGNALESP.cpp.o" source_file="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\SIGNALESP.cpp" vm.last.preproc.file.5.file="signalDecoder.cpp" vm.last.preproc.file.5.offset="0" vm.last.preproc.file.5.length="37530" vm.last.preproc.file.5.linecount="1277" vm.last.preproc.file.5.linestart="906" vm.last.preproc.file.5.lineend="2183" vm.last.preproc.file.5.prefix_lines="0" vm.last.preproc.file.6.file="signalDecoder.h" vm.last.preproc.file.6.offset="0" vm.last.preproc.file.6.length="5961" vm.last.preproc.file.6.linecount="166" vm.last.preproc.file.6.linestart="2183" vm.last.preproc.file.6.lineend="2349" vm.last.preproc.file.6.prefix_lines="0" object_files=" &quot;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\SIGNALESP.cpp.o&quot;  &quot;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\SimpleFIFO\SimpleFIFO.cpp.o&quot;  &quot;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\signalDecoder\signalDecoder.cpp.o&quot;  &quot;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\bitstore\bitstore.cpp.o&quot;  &quot;C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2\EEPROM\EEPROM.cpp.o&quot; " />
-    </Platform>
-    <Debug DebugEnabled="0" EnableBreak="1" />
-  </Program>
-</VisualMicro>
\ No newline at end of file
diff -ruwN ./__vm/Configuration.Release.vmps.xml ../../trebron106/SIGNALEsp-20170510/__vm/Configuration.Release.vmps.xml
--- ./__vm/Configuration.Release.vmps.xml	2017-08-17 12:43:36.538057925 +0200
+++ ../../trebron106/SIGNALEsp-20170510/__vm/Configuration.Release.vmps.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,9 +0,0 @@
-<VisualMicro>
-  <Program Name="SIGNALESP" Ext=".ino" Location="Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP">
-    <Compile IsDebugStart="1" IsCompiled="0" CompilerErrors="0" ConfigurationName="Release" StopOnError="False" OptimiseLibs="True" OptimiseCore="True" IsGdb="0" BuildPath="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" ReCompileIfSourceIsNewer="1" />
-    <Platform Name="arduino16x" Package="esp8266" Platform="esp8266" Architecture="1.20.0-26-gb404fb9-2">
-      <Board Name="esp8266_nodemcuv2" Description="NodeMCU 1.0 (ESP-12E Module)" CoreFolder="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266" VariantFullPath="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\variants\nodemcu" McuIdePath="z:\Programme\Arduino" McuSketchBookPath="Z:\Benutzer\Sven\Documents\Arduino" name="NodeMCU 1.0 (ESP-12E Module)" upload.tool="esptool" upload.speed="115200" upload.resetmethod="nodemcu" upload.maximum_size="1044464" upload.maximum_data_size="81920" upload.wait_for_upload_port="true" serial.disableDTR="true" serial.disableRTS="true" build.mcu="esp8266" build.f_cpu="80000000L" build.board="ESP8266_NODEMCU" build.core="esp8266" build.variant="nodemcu" build.flash_mode="dio" build.flash_size="4M" build.flash_freq="40" build.debug_port="" build.debug_level="" menu.CpuFrequency.80="80 MHz" menu.CpuFrequency.80.build.f_cpu="80000000L" menu.CpuFrequency.160="160 MHz" menu.CpuFrequency.160.build.f_cpu="160000000L" menu.UploadSpeed.115200="115200" menu.UploadSpeed.115200.upload.speed="115200" menu.UploadSpeed.9600="9600" menu.UploadSpeed.9600.upload.speed="9600" menu.UploadSpeed.57600="57600" menu.UploadSpeed.57600.upload.speed="57600" menu.UploadSpeed.256000.windows="256000" menu.UploadSpeed.256000.upload.speed="256000" menu.UploadSpeed.230400.linux="230400" menu.UploadSpeed.230400.macosx="230400" menu.UploadSpeed.230400.upload.speed="230400" menu.UploadSpeed.460800.linux="460800" menu.UploadSpeed.460800.macosx="460800" menu.UploadSpeed.460800.upload.speed="460800" menu.UploadSpeed.512000.windows="512000" menu.UploadSpeed.512000.upload.speed="512000" menu.UploadSpeed.921600="921600" menu.UploadSpeed.921600.upload.speed="921600" menu.FlashSize.4M3M="4M (3M SPIFFS)" menu.FlashSize.4M3M.build.flash_size="4M" menu.FlashSize.4M3M.build.flash_ld="eagle.flash.4m.ld" menu.FlashSize.4M3M.build.spiffs_start="0x100000" menu.FlashSize.4M3M.build.spiffs_end="0x3FB000" menu.FlashSize.4M3M.build.spiffs_blocksize="8192" menu.FlashSize.4M3M.build.spiffs_pagesize="256" menu.FlashSize.4M1M="4M (1M SPIFFS)" menu.FlashSize.4M1M.build.flash_size="4M" menu.FlashSize.4M1M.build.flash_ld="eagle.flash.4m1m.ld" menu.FlashSize.4M1M.build.spiffs_start="0x300000" menu.FlashSize.4M1M.build.spiffs_end="0x3FB000" menu.FlashSize.4M1M.build.spiffs_blocksize="8192" menu.FlashSize.4M1M.build.spiffs_pagesize="256" menu.UploadSpeed.256000="256000" menu.UploadSpeed.512000="512000" runtime.ide.path="z:\Programme\Arduino" runtime.os="windows" build.system.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\system" runtime.ide.version="106011" target_package="esp8266" target_platform="esp8266" runtime.hardware.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266" originalid="nodemcuv2" intellisense.tools.path="{compiler.toolchain.path}" intellisense.include.paths="{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include\c++\4.8.2;{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include\c++\4.8.2\xtensa-lx106-elf;{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include;{runtime.tools.xtensa-lx106-elf-gcc.path}\lib\gcc\xtensa-lx106-elf\4.8.2\include;{runtime.platform.path}\tools\sdk\include" tools.wwwfiles.name="ESP8266 Sketch Data Upload" tools.wwwfiles.ssh="false" tools.wwwfiles.cmd.windows="ESP8266FSUpload.exe" recipe.wwwfiles.upload.pattern="&quot;{vm.path}/{tools.wwwfiles.cmd}&quot; -serial.port={serial.port} -build.path=&quot;{build.path}&quot; -target_platform=&quot;{target_platform}&quot; -runtime.tools.mkspiffs.path=&quot;{runtime.tools.mkspiffs.path}&quot; -board.name=&quot;{name}&quot; -upload.verbose={upload.verbose} -upload.resetmethod={upload.resetmethod} -upload.speed={upload.speed}  -platform.path=&quot;{platform.path}&quot; -project.name=&quot;{project.name}&quot; -project.path=&quot;{project.path}&quot; -tools.esptool.cmd=&quot;{tools.esptool.cmd}&quot; -runtime.tools.esptool.path=&quot;{runtime.tools.esptool.path}&quot; -compiler.path=&quot;{compiler.path}&quot; -build.spiffs_start=&quot;{build.spiffs_start}&quot; -build.spiffs_end=&quot;{build.spiffs_end}&quot; -build.spiffs_pagesize=&quot;{build.spiffs_pagesize}&quot; -build.spiffs_blocksize=&quot;{build.spiffs_blocksize}&quot; -network.password={network.password} -network.auth_upload={network.auth_upload} -network.port={network.port}" tools.wwwfiles.cmd="ESP8266FSUpload.exe" version="2.2.0" compiler.warning_flags="-w" compiler.warning_flags.none="-w" compiler.warning_flags.default="" compiler.warning_flags.more="-Wall" compiler.warning_flags.all="-Wall -Wextra" build.lwip_lib="-llwip_gcc" build.lwip_flags="-DLWIP_OPEN_SRC" compiler.path="{runtime.tools.xtensa-lx106-elf-gcc.path}/bin/" compiler.sdk.path="{runtime.platform.path}/tools/sdk" compiler.cpreprocessor.flags="-D__ets__ -DICACHE_FLASH -U__STRICT_ANSI__ &quot;-I{compiler.sdk.path}/include&quot; &quot;-I{compiler.sdk.path}/lwip/include&quot; &quot;-I{build.path}/core&quot;" compiler.c.cmd="xtensa-lx106-elf-gcc" compiler.c.flags="-c {compiler.warning_flags} -Os -g -Wpointer-arith -Wno-implicit-function-declaration -Wl,-EL -fno-inline-functions -nostdlib -mlongcalls -mtext-section-literals -falign-functions=4 -MMD -std=gnu99 -ffunction-sections -fdata-sections" compiler.S.cmd="xtensa-lx106-elf-gcc" compiler.S.flags="-c -g -x assembler-with-cpp -MMD -mlongcalls" compiler.c.elf.flags="-g {compiler.warning_flags} -Os -nostdlib -Wl,--no-check-sections -u call_user_start -Wl,-static &quot;-L{compiler.sdk.path}/lib&quot; &quot;-L{compiler.sdk.path}/ld&quot; &quot;-T{build.flash_ld}&quot; -Wl,--gc-sections -Wl,-wrap,system_restart_local -Wl,-wrap,register_chipv6_phy" compiler.c.elf.cmd="xtensa-lx106-elf-gcc" compiler.c.elf.libs="-lm -lgcc -lhal -lphy -lpp -lnet80211 -lwpa -lcrypto -lmain -lwps -laxtls -lsmartconfig -lmesh -lwpa2 {build.lwip_lib} -lstdc++" compiler.cpp.cmd="xtensa-lx106-elf-g++" compiler.cpp.flags="-c {compiler.warning_flags} -Os -g -mlongcalls -mtext-section-literals -fno-exceptions -fno-rtti -falign-functions=4 -std=c++11 -MMD -ffunction-sections -fdata-sections" compiler.as.cmd="xtensa-lx106-elf-as" compiler.ar.cmd="xtensa-lx106-elf-ar" compiler.ar.flags="cru" compiler.elf2hex.cmd="esptool" compiler.elf2hex.flags="" compiler.size.cmd="xtensa-lx106-elf-size" compiler.esptool.cmd="esptool.exe" compiler.esptool.cmd.windows="esptool.exe" build.extra_flags="-DESP8266" compiler.c.extra_flags="" compiler.c.elf.extra_flags="" compiler.S.extra_flags="" compiler.cpp.extra_flags="" compiler.ar.extra_flags="" compiler.objcopy.eep.extra_flags="" compiler.elf2hex.extra_flags="" recipe.c.o.pattern="&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.c.flags} -DF_CPU={build.f_cpu} {build.lwip_flags} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=&quot;{build.board}&quot; {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.cpp.o.pattern="&quot;{compiler.path}{compiler.cpp.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.cpp.flags} -DF_CPU={build.f_cpu} {build.lwip_flags} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=&quot;{build.board}&quot; {compiler.cpp.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.S.o.pattern="&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.S.flags} -DF_CPU={build.f_cpu} {build.lwip_flags} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=&quot;{build.board}&quot; {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.ar.pattern="&quot;{compiler.path}{compiler.ar.cmd}&quot; {compiler.ar.flags} {compiler.ar.extra_flags} &quot;{archive_file_path}&quot; &quot;{object_file}&quot;" recipe.c.combine.pattern="&quot;{compiler.path}{compiler.c.elf.cmd}&quot; {compiler.c.elf.flags} {compiler.c.elf.extra_flags} -o &quot;{build.path}/{build.project_name}.elf&quot; -Wl,--start-group {object_files} &quot;{build.path}/{archive_file}&quot; {compiler.c.elf.libs} -Wl,--end-group  &quot;-L{build.path}&quot;" recipe.objcopy.eep.pattern="" recipe.objcopy.hex.pattern="&quot;{runtime.tools.esptool.path}/{compiler.esptool.cmd}&quot; -eo &quot;{runtime.platform.path}/bootloaders/eboot/eboot.elf&quot; -bo &quot;{build.path}/{build.project_name}.bin&quot; -bm {build.flash_mode} -bf {build.flash_freq} -bz {build.flash_size} -bs .text -bp 4096 -ec -eo &quot;{build.path}/{build.project_name}.elf&quot; -bs .irom0.text -bs .text -bs .data -bs .rodata -bc -ec" recipe.output.tmp_file="{build.project_name}.bin" recipe.output.save_file="{build.project_name}.{build.variant}.bin" recipe.size.pattern="&quot;{compiler.path}{compiler.size.cmd}&quot; -A &quot;{build.path}/{build.project_name}.elf&quot;" recipe.size.regex="^(?:\.irom0\.text|\.text|\.data|\.rodata|)\s+([0-9]+).*" recipe.size.regex.data="^(?:\.data|\.rodata|\.bss)\s+([0-9]+).*" tools.esptool.cmd="esptool.exe" tools.esptool.cmd.windows="esptool.exe" tools.esptool.path="{runtime.tools.esptool.path}" tools.esptool.network_cmd="python.exe" tools.esptool.network_cmd.windows="python.exe" tools.esptool.upload.protocol="esp" tools.esptool.upload.params.verbose="-vv" tools.esptool.upload.params.quiet="" tools.esptool.upload.pattern="&quot;{path}/{cmd}&quot; {upload.verbose} -cd {upload.resetmethod} -cb {upload.speed} -cp &quot;{serial.port}&quot; -ca 0x00000 -cf &quot;{build.path}/{build.project_name}.bin&quot;" tools.esptool.upload.network_pattern="&quot;{network_cmd}&quot; &quot;{runtime.platform.path}/tools/espota.py&quot; -i &quot;{serial.port}&quot; -p &quot;{network.port}&quot; &quot;--auth={network.password}&quot; -f &quot;{build.path}/{build.project_name}.bin&quot;" tools.mkspiffs.cmd="mkspiffs.exe" tools.mkspiffs.cmd.windows="mkspiffs.exe" tools.mkspiffs.path="{runtime.tools.mkspiffs.path}" vm.platform.root.path="Z:\Programme\visual studio 2015\Common7\IDE\Extensions\1leckq1b.pja\Micro Platforms\arduino16x" runtime.tools.esptool.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\esptool\0.4.9" runtime.tools.esptool-0.4.9.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\esptool\0.4.9" runtime.tools.xtensa-lx106-elf-gcc.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" runtime.tools.xtensa-lx106-elf-gcc-1.20.0-26-gb404fb9-2.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" runtime.tools.mkspiffs.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\mkspiffs\0.1.2" runtime.tools.mkspiffs-0.1.2.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\mkspiffs\0.1.2" runtime.tools.avrdude.path="z:\Programme\Arduino\hardware\tools\avr" runtime.tools.avrdude-6.0.1-arduino2.path="z:\Programme\Arduino\hardware\tools\avr" runtime.tools.avr-gcc.path="z:\Programme\Arduino\hardware\tools\avr" runtime.tools.avr-gcc-4.9.2-atmel3.5.3-arduino.path="z:\Programme\Arduino\hardware\tools\avr" runtime.vm.boardinfo.id="esp8266_nodemcuv2" runtime.vm.boardinfo.name="esp8266_nodemcuv2" runtime.vm.boardinfo.desc="NodeMCU 1.0 (ESP-12E Module)" runtime.vm.boardinfo.src_location="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" ide.hint="For all platforms that use Board Manager" ide.location.key="Arduino16x" ide.location.ide.winreg="Arduino 1.6.x Application" ide.location.sketchbook.winreg="Arduino 1.6.x Sketchbook" ide.location.sketchbook.preferences="sketchbook.path" ide.default.revision_name="1.6.9" ide.default.version="10609" ide.default.package="arduino" ide.default.platform="avr" ide.multiplatform="true" ide.includes="arduino.h" ide.exe_name="arduino" ide.platformswithoutpackage="false" ide.includes.fallback="wprogram.h" ide.extension="ino" ide.extension.fallback="pde" ide.versionGTEQ="160" ide.exe="arduino.exe" ide.hosts="atmel" ide.url="http://arduino.cc/en/Main/Software" ide.help.reference.path="reference" ide.help.reference.path2="reference\www.arduino.cc\en\Reference" ide.help.reference.serial="reference\www.arduino.cc\en\Serial" vm.debug="true" software="ARDUINO" ssh.user.name="root" ssh.user.default.password="arduino" ssh.host.wwwfiles.path="/www/sd" build.working_directory="{runtime.ide.path}" ide.location.preferences.portable="{runtime.ide.path}\portable" ide.location.preferences="%VM_APPDATA_LOCAL%\arduino15\preferences.txt" ide.location.preferences_fallback="%VM_APPDATA_ROAMING%\arduino15\preferences.txt" ide.location.contributions="%VM_APPDATA_LOCAL%\arduino15" ide.location.contributions_fallback="%VM_APPDATA_ROAMING%\arduino15" ide.contributions.boards.allow="true" ide.contributions.boards.ignore_unless_rewrite_found="true" ide.contributions.libraries.allow="true" ide.contributions.boards.support.urls.wiki="https://github.com/arduino/Arduino/wiki/Unofficial-list-of-3rd-party-boards-support-urls" ide.create_platforms_from_boardsTXT.teensy="build.core" ide.appid="arduino16x" location.sketchbook="Z:\Benutzer\Sven\Documents\Arduino" build.core.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266" build.core.parentfolder.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores" build.core.coresparentfolder.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" build.core.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266" vm.core.include="arduino.h" vm.boardsource.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" runtime.platform.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" vm.platformname.name="esp8266" build.arch="ESP8266" build.flash_ld="eagle.flash.4m.ld" build.spiffs_start="0x100000" build.spiffs_end="0x3FB000" build.spiffs_blocksize="8192" build.spiffs_pagesize="256" builder.noino="false" build.variant.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\variants\nodemcu" build.architecture="1.20.0-26-gb404fb9-2" vmresolved.compiler.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\bin\" vmresolved.tools.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" vm.runtime.compiler.showwarnings="false" vm.runtime.upload.verbose="false" vm.runtime.upload.verify="true" serial.port.file="COM3" serial.port="COM3" serial.port.num="3" vm.runtime.compiler.auto_discover_includes="false" build.vm.build.vmdebug="0" build.vm.build.isgdb="0" build.vm.build.optimised="1" vm.last.buildpath="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" />
-    </Platform>
-    <Debug DebugEnabled="0" EnableBreak="1" />
-  </Program>
-</VisualMicro>
\ No newline at end of file
diff -ruwN ./__vm/.SIGNALESP.vsarduino.h ../../trebron106/SIGNALEsp-20170510/__vm/.SIGNALESP.vsarduino.h
--- ./__vm/.SIGNALESP.vsarduino.h	2017-08-17 12:43:36.538057925 +0200
+++ ../../trebron106/SIGNALEsp-20170510/__vm/.SIGNALESP.vsarduino.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,98 +0,0 @@
-/* 
-	Editor: http://www.visualmicro.com
-	        visual micro and the arduino ide ignore this code during compilation. this code is automatically maintained by visualmicro, manual changes to this file will be overwritten
-	        the contents of the Visual Micro sketch sub folder can be deleted prior to publishing a project
-	        all non-arduino files created by visual micro and all visual studio project or solution files can be freely deleted and are not required to compile a sketch (do not delete your own code!).
-	        note: debugger breakpoints are stored in '.sln' or '.asln' files, knowledge of last uploaded breakpoints is stored in the upload.vmps.xml file. Both files are required to continue a previous debug session without needing to compile and upload again
-	
-	Hardware: NodeMCU 1.0 (ESP-12E Module), Platform=esp8266, Package=esp8266
-*/
-
-#ifndef _VSARDUINO_H_
-#define _VSARDUINO_H_
-#define __ESP8266_ESp8266__
-#define __ESP8266_ESP8266__
-#define __ets__
-#define ICACHE_FLASH
-#define F_CPU 80000000L
-#define LWIP_OPEN_SRC
-#define ARDUINO 106011
-#define ARDUINO_ESP8266_NODEMCU
-#define ARDUINO_ARCH_ESP8266
-#define ESP8266
-#define __cplusplus 201103L
-#undef __cplusplus
-#define __cplusplus 201103L
-#define __STDC__
-#define __ARM__
-#define __arm__
-#define __inline__
-#define __asm__(x)
-#define __asm__
-#define __extension__
-#define __ATTR_PURE__
-#define __ATTR_CONST__
-#define __volatile__
-
-
-#define __ASM
-#define __INLINE
-#define __attribute__(noinline)
-
-//#define _STD_BEGIN
-//#define EMIT
-#define WARNING
-#define _Lockit
-#define __CLR_OR_THIS_CALL
-#define C4005
-//
-//typedef int uint8_t;
-//#define __ARMCC_VERSION 400678
-//#define PROGMEM
-//#define string_literal
-//
-//#define prog_void
-//#define PGM_VOID_P int
-//
-
-typedef int _read;
-typedef int _seek;
-typedef int _write;
-typedef int _close;
-typedef int __cleanup;
-
-//#define inline 
-
-#define __builtin_clz
-#define __builtin_clzl
-#define __builtin_clzll
-#define __builtin_labs
-#define __builtin_va_list
-typedef int __gnuc_va_list;
-
-#define __ATOMIC_ACQ_REL
-
-#define __CHAR_BIT__
-#define _EXFUN()
-
-typedef unsigned char byte;
-extern "C" void __cxa_pure_virtual() {;}
-
-
-#include "new"
-#include "Esp.h"
-
-
-#include <arduino.h>
-#include <pins_arduino.h> 
-#undef F
-#define F(string_literal) ((const PROGMEM char *)(string_literal))
-#undef PSTR
-#define PSTR(string_literal) ((const PROGMEM char *)(string_literal))
-//current vc++ does not understand this syntax so use older arduino example for intellisense
-//todo:move to the new clang/gcc project types.
-#define interrupts() sei()
-#define noInterrupts() cli()
-
-#include "SIGNALESP.ino"
-#endif
diff -ruwN ./__vm/Upload.vmps.xml ../../trebron106/SIGNALEsp-20170510/__vm/Upload.vmps.xml
--- ./__vm/Upload.vmps.xml	2017-08-17 12:43:36.538057925 +0200
+++ ../../trebron106/SIGNALEsp-20170510/__vm/Upload.vmps.xml	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
-<VisualMicro>
-  <Program Name="SIGNALESP" Ext=".ino" Location="Z:\Benutzer\Sven\Documents\RFD-FHEM\SIGNALESP\SIGNALESP">
-    <Compile IsDebugStart="1" CompilerErrors="0" ConfigurationName="Release" StopOnError="False" OptimiseLibs="True" OptimiseCore="True" IsGdb="0" BuildPath="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" ReCompileIfSourceIsNewer="1" IncludeDebug="0" IncludesDebug="0" SketchName="SIGNALESP" IsCompiled="1" />
-    <Platform Name="arduino16x" Package="esp8266" Platform="esp8266" Architecture="1.20.0-26-gb404fb9-2">
-      <Board Name="esp8266_nodemcuv2" Description="NodeMCU 1.0 (ESP-12E Module)" CoreFolder="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266" VariantFullPath="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\variants\nodemcu" McuIdePath="z:\Programme\Arduino" McuSketchBookPath="Z:\Benutzer\Sven\Documents\Arduino" name="NodeMCU 1.0 (ESP-12E Module)" upload.tool="esptool" upload.speed="115200" upload.resetmethod="nodemcu" upload.maximum_size="1044464" upload.maximum_data_size="81920" upload.wait_for_upload_port="true" serial.disableDTR="true" serial.disableRTS="true" build.mcu="esp8266" build.f_cpu="80000000L" build.board="ESP8266_NODEMCU" build.core="esp8266" build.variant="nodemcu" build.flash_mode="dio" build.flash_size="4M" build.flash_freq="40" build.debug_port="" build.debug_level="" menu.CpuFrequency.80="80 MHz" menu.CpuFrequency.80.build.f_cpu="80000000L" menu.CpuFrequency.160="160 MHz" menu.CpuFrequency.160.build.f_cpu="160000000L" menu.UploadSpeed.115200="115200" menu.UploadSpeed.115200.upload.speed="115200" menu.UploadSpeed.9600="9600" menu.UploadSpeed.9600.upload.speed="9600" menu.UploadSpeed.57600="57600" menu.UploadSpeed.57600.upload.speed="57600" menu.UploadSpeed.256000.windows="256000" menu.UploadSpeed.256000.upload.speed="256000" menu.UploadSpeed.230400.linux="230400" menu.UploadSpeed.230400.macosx="230400" menu.UploadSpeed.230400.upload.speed="230400" menu.UploadSpeed.460800.linux="460800" menu.UploadSpeed.460800.macosx="460800" menu.UploadSpeed.460800.upload.speed="460800" menu.UploadSpeed.512000.windows="512000" menu.UploadSpeed.512000.upload.speed="512000" menu.UploadSpeed.921600="921600" menu.UploadSpeed.921600.upload.speed="921600" menu.FlashSize.4M3M="4M (3M SPIFFS)" menu.FlashSize.4M3M.build.flash_size="4M" menu.FlashSize.4M3M.build.flash_ld="eagle.flash.4m.ld" menu.FlashSize.4M3M.build.spiffs_start="0x100000" menu.FlashSize.4M3M.build.spiffs_end="0x3FB000" menu.FlashSize.4M3M.build.spiffs_blocksize="8192" menu.FlashSize.4M3M.build.spiffs_pagesize="256" menu.FlashSize.4M1M="4M (1M SPIFFS)" menu.FlashSize.4M1M.build.flash_size="4M" menu.FlashSize.4M1M.build.flash_ld="eagle.flash.4m1m.ld" menu.FlashSize.4M1M.build.spiffs_start="0x300000" menu.FlashSize.4M1M.build.spiffs_end="0x3FB000" menu.FlashSize.4M1M.build.spiffs_blocksize="8192" menu.FlashSize.4M1M.build.spiffs_pagesize="256" menu.UploadSpeed.256000="256000" menu.UploadSpeed.512000="512000" runtime.ide.path="z:\Programme\Arduino" runtime.os="windows" build.system.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\system" runtime.ide.version="106011" target_package="esp8266" target_platform="esp8266" runtime.hardware.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266" originalid="nodemcuv2" intellisense.tools.path="{compiler.toolchain.path}" intellisense.include.paths="{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include\c++\4.8.2;{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include\c++\4.8.2\xtensa-lx106-elf;{runtime.tools.xtensa-lx106-elf-gcc.path}\xtensa-lx106-elf\include;{runtime.tools.xtensa-lx106-elf-gcc.path}\lib\gcc\xtensa-lx106-elf\4.8.2\include;{runtime.platform.path}\tools\sdk\include" tools.wwwfiles.name="ESP8266 Sketch Data Upload" tools.wwwfiles.ssh="false" tools.wwwfiles.cmd.windows="ESP8266FSUpload.exe" recipe.wwwfiles.upload.pattern="&quot;{vm.path}/{tools.wwwfiles.cmd}&quot; -serial.port={serial.port} -build.path=&quot;{build.path}&quot; -target_platform=&quot;{target_platform}&quot; -runtime.tools.mkspiffs.path=&quot;{runtime.tools.mkspiffs.path}&quot; -board.name=&quot;{name}&quot; -upload.verbose={upload.verbose} -upload.resetmethod={upload.resetmethod} -upload.speed={upload.speed}  -platform.path=&quot;{platform.path}&quot; -project.name=&quot;{project.name}&quot; -project.path=&quot;{project.path}&quot; -tools.esptool.cmd=&quot;{tools.esptool.cmd}&quot; -runtime.tools.esptool.path=&quot;{runtime.tools.esptool.path}&quot; -compiler.path=&quot;{compiler.path}&quot; -build.spiffs_start=&quot;{build.spiffs_start}&quot; -build.spiffs_end=&quot;{build.spiffs_end}&quot; -build.spiffs_pagesize=&quot;{build.spiffs_pagesize}&quot; -build.spiffs_blocksize=&quot;{build.spiffs_blocksize}&quot; -network.password={network.password} -network.auth_upload={network.auth_upload} -network.port={network.port}" tools.wwwfiles.cmd="ESP8266FSUpload.exe" version="2.2.0" compiler.warning_flags="-w" compiler.warning_flags.none="-w" compiler.warning_flags.default="" compiler.warning_flags.more="-Wall" compiler.warning_flags.all="-Wall -Wextra" build.lwip_lib="-llwip_gcc" build.lwip_flags="-DLWIP_OPEN_SRC" compiler.path="{runtime.tools.xtensa-lx106-elf-gcc.path}/bin/" compiler.sdk.path="{runtime.platform.path}/tools/sdk" compiler.cpreprocessor.flags="-D__ets__ -DICACHE_FLASH -U__STRICT_ANSI__ &quot;-I{compiler.sdk.path}/include&quot; &quot;-I{compiler.sdk.path}/lwip/include&quot; &quot;-I{build.path}/core&quot;" compiler.c.cmd="xtensa-lx106-elf-gcc" compiler.c.flags="-c {compiler.warning_flags} -Os -g -Wpointer-arith -Wno-implicit-function-declaration -Wl,-EL -fno-inline-functions -nostdlib -mlongcalls -mtext-section-literals -falign-functions=4 -MMD -std=gnu99 -ffunction-sections -fdata-sections" compiler.S.cmd="xtensa-lx106-elf-gcc" compiler.S.flags="-c -g -x assembler-with-cpp -MMD -mlongcalls" compiler.c.elf.flags="-g {compiler.warning_flags} -Os -nostdlib -Wl,--no-check-sections -u call_user_start -Wl,-static &quot;-L{compiler.sdk.path}/lib&quot; &quot;-L{compiler.sdk.path}/ld&quot; &quot;-T{build.flash_ld}&quot; -Wl,--gc-sections -Wl,-wrap,system_restart_local -Wl,-wrap,register_chipv6_phy" compiler.c.elf.cmd="xtensa-lx106-elf-gcc" compiler.c.elf.libs="-lm -lgcc -lhal -lphy -lpp -lnet80211 -lwpa -lcrypto -lmain -lwps -laxtls -lsmartconfig -lmesh -lwpa2 {build.lwip_lib} -lstdc++" compiler.cpp.cmd="xtensa-lx106-elf-g++" compiler.cpp.flags="-c {compiler.warning_flags} -Os -g -mlongcalls -mtext-section-literals -fno-exceptions -fno-rtti -falign-functions=4 -std=c++11 -MMD -ffunction-sections -fdata-sections" compiler.as.cmd="xtensa-lx106-elf-as" compiler.ar.cmd="xtensa-lx106-elf-ar" compiler.ar.flags="cru" compiler.elf2hex.cmd="esptool" compiler.elf2hex.flags="" compiler.size.cmd="xtensa-lx106-elf-size" compiler.esptool.cmd="esptool.exe" compiler.esptool.cmd.windows="esptool.exe" build.extra_flags="-DESP8266" compiler.c.extra_flags="" compiler.c.elf.extra_flags="" compiler.S.extra_flags="" compiler.cpp.extra_flags="" compiler.ar.extra_flags="" compiler.objcopy.eep.extra_flags="" compiler.elf2hex.extra_flags="" recipe.c.o.pattern="&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.c.flags} -DF_CPU={build.f_cpu} {build.lwip_flags} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=&quot;{build.board}&quot; {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.cpp.o.pattern="&quot;{compiler.path}{compiler.cpp.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.cpp.flags} -DF_CPU={build.f_cpu} {build.lwip_flags} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=&quot;{build.board}&quot; {compiler.cpp.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.S.o.pattern="&quot;{compiler.path}{compiler.c.cmd}&quot; {compiler.cpreprocessor.flags} {compiler.S.flags} -DF_CPU={build.f_cpu} {build.lwip_flags} {build.debug_port} {build.debug_level} -DARDUINO={runtime.ide.version} -DARDUINO_{build.board} -DARDUINO_ARCH_{build.arch} -DARDUINO_BOARD=&quot;{build.board}&quot; {compiler.c.extra_flags} {build.extra_flags} {includes} &quot;{source_file}&quot; -o &quot;{object_file}&quot;" recipe.ar.pattern="&quot;{compiler.path}{compiler.ar.cmd}&quot; {compiler.ar.flags} {compiler.ar.extra_flags} &quot;{archive_file_path}&quot; &quot;{object_file}&quot;" recipe.c.combine.pattern="&quot;{compiler.path}{compiler.c.elf.cmd}&quot; {compiler.c.elf.flags} {compiler.c.elf.extra_flags} -o &quot;{build.path}/{build.project_name}.elf&quot; -Wl,--start-group {object_files} &quot;{build.path}/{archive_file}&quot; {compiler.c.elf.libs} -Wl,--end-group  &quot;-L{build.path}&quot;" recipe.objcopy.eep.pattern="" recipe.objcopy.hex.pattern="&quot;{runtime.tools.esptool.path}/{compiler.esptool.cmd}&quot; -eo &quot;{runtime.platform.path}/bootloaders/eboot/eboot.elf&quot; -bo &quot;{build.path}/{build.project_name}.bin&quot; -bm {build.flash_mode} -bf {build.flash_freq} -bz {build.flash_size} -bs .text -bp 4096 -ec -eo &quot;{build.path}/{build.project_name}.elf&quot; -bs .irom0.text -bs .text -bs .data -bs .rodata -bc -ec" recipe.output.tmp_file="{build.project_name}.bin" recipe.output.save_file="{build.project_name}.{build.variant}.bin" recipe.size.pattern="&quot;{compiler.path}{compiler.size.cmd}&quot; -A &quot;{build.path}/{build.project_name}.elf&quot;" recipe.size.regex="^(?:\.irom0\.text|\.text|\.data|\.rodata|)\s+([0-9]+).*" recipe.size.regex.data="^(?:\.data|\.rodata|\.bss)\s+([0-9]+).*" tools.esptool.cmd="esptool.exe" tools.esptool.cmd.windows="esptool.exe" tools.esptool.path="{runtime.tools.esptool.path}" tools.esptool.network_cmd="python.exe" tools.esptool.network_cmd.windows="python.exe" tools.esptool.upload.protocol="esp" tools.esptool.upload.params.verbose="-vv" tools.esptool.upload.params.quiet="" tools.esptool.upload.pattern="&quot;{path}/{cmd}&quot; {upload.verbose} -cd {upload.resetmethod} -cb {upload.speed} -cp &quot;{serial.port}&quot; -ca 0x00000 -cf &quot;{build.path}/{build.project_name}.bin&quot;" tools.esptool.upload.network_pattern="&quot;{network_cmd}&quot; &quot;{runtime.platform.path}/tools/espota.py&quot; -i &quot;{serial.port}&quot; -p &quot;{network.port}&quot; &quot;--auth={network.password}&quot; -f &quot;{build.path}/{build.project_name}.bin&quot;" tools.mkspiffs.cmd="mkspiffs.exe" tools.mkspiffs.cmd.windows="mkspiffs.exe" tools.mkspiffs.path="{runtime.tools.mkspiffs.path}" vm.platform.root.path="Z:\Programme\visual studio 2015\Common7\IDE\Extensions\1leckq1b.pja\Micro Platforms\arduino16x" runtime.tools.esptool.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\esptool\0.4.9" runtime.tools.esptool-0.4.9.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\esptool\0.4.9" runtime.tools.xtensa-lx106-elf-gcc.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" runtime.tools.xtensa-lx106-elf-gcc-1.20.0-26-gb404fb9-2.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" runtime.tools.mkspiffs.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\mkspiffs\0.1.2" runtime.tools.mkspiffs-0.1.2.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\mkspiffs\0.1.2" runtime.tools.avrdude.path="z:\Programme\Arduino\hardware\tools\avr" runtime.tools.avrdude-6.0.1-arduino2.path="z:\Programme\Arduino\hardware\tools\avr" runtime.tools.avr-gcc.path="z:\Programme\Arduino\hardware\tools\avr" runtime.tools.avr-gcc-4.9.2-atmel3.5.3-arduino.path="z:\Programme\Arduino\hardware\tools\avr" runtime.vm.boardinfo.id="esp8266_nodemcuv2" runtime.vm.boardinfo.name="esp8266_nodemcuv2" runtime.vm.boardinfo.desc="NodeMCU 1.0 (ESP-12E Module)" runtime.vm.boardinfo.src_location="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" ide.hint="For all platforms that use Board Manager" ide.location.key="Arduino16x" ide.location.ide.winreg="Arduino 1.6.x Application" ide.location.sketchbook.winreg="Arduino 1.6.x Sketchbook" ide.location.sketchbook.preferences="sketchbook.path" ide.default.revision_name="1.6.9" ide.default.version="10609" ide.default.package="arduino" ide.default.platform="avr" ide.multiplatform="true" ide.includes="arduino.h" ide.exe_name="arduino" ide.platformswithoutpackage="false" ide.includes.fallback="wprogram.h" ide.extension="ino" ide.extension.fallback="pde" ide.versionGTEQ="160" ide.exe="arduino.exe" ide.hosts="atmel" ide.url="http://arduino.cc/en/Main/Software" ide.help.reference.path="reference" ide.help.reference.path2="reference\www.arduino.cc\en\Reference" ide.help.reference.serial="reference\www.arduino.cc\en\Serial" vm.debug="true" software="ARDUINO" ssh.user.name="root" ssh.user.default.password="arduino" ssh.host.wwwfiles.path="/www/sd" build.working_directory="{runtime.ide.path}" ide.location.preferences.portable="{runtime.ide.path}\portable" ide.location.preferences="%VM_APPDATA_LOCAL%\arduino15\preferences.txt" ide.location.preferences_fallback="%VM_APPDATA_ROAMING%\arduino15\preferences.txt" ide.location.contributions="%VM_APPDATA_LOCAL%\arduino15" ide.location.contributions_fallback="%VM_APPDATA_ROAMING%\arduino15" ide.contributions.boards.allow="true" ide.contributions.boards.ignore_unless_rewrite_found="true" ide.contributions.libraries.allow="true" ide.contributions.boards.support.urls.wiki="https://github.com/arduino/Arduino/wiki/Unofficial-list-of-3rd-party-boards-support-urls" ide.create_platforms_from_boardsTXT.teensy="build.core" ide.appid="arduino16x" location.sketchbook="Z:\Benutzer\Sven\Documents\Arduino" build.core.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266" build.core.parentfolder.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores" build.core.coresparentfolder.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" build.core.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\cores\esp8266" vm.core.include="arduino.h" vm.boardsource.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" runtime.platform.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0" vm.platformname.name="esp8266" build.arch="ESP8266" build.flash_ld="eagle.flash.4m.ld" build.spiffs_start="0x100000" build.spiffs_end="0x3FB000" build.spiffs_blocksize="8192" build.spiffs_pagesize="256" builder.noino="false" build.variant.vmresolved="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\hardware\esp8266\2.3.0\variants\nodemcu" build.architecture="1.20.0-26-gb404fb9-2" vmresolved.compiler.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2\bin\" vmresolved.tools.path="C:\Users\sidewinder\AppData\Local\arduino15\packages\esp8266\tools\xtensa-lx106-elf-gcc\1.20.0-26-gb404fb9-2" vm.runtime.compiler.showwarnings="false" vm.runtime.upload.verbose="false" vm.runtime.upload.verify="true" serial.port.file="COM3" serial.port="COM3" serial.port.num="3" vm.runtime.compiler.auto_discover_includes="false" build.vm.build.vmdebug="0" build.vm.build.isgdb="0" build.vm.build.optimised="1" vm.last.buildpath="C:\Users\sidewinder\AppData\Local\Temp\VMicroBuilds\SIGNALESP\esp8266_nodemcuv2" />
-    </Platform>
-    <Debug DebugEnabled="0" EnableBreak="1" />
-    <VCCodeModel>
-      <VCCodeMacros />
-    </VCCodeModel>
-  </Program>
-</VisualMicro>
\ No newline at end of file
